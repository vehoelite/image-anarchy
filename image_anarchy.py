#!/usr/bin/env python3
"""
Image Anarchy - Android Image Swiss Army Knife
Version: 3.2

A modern PyQt6 application for extracting, creating, and manipulating
Android OTA payloads and image formats.

GitHub: https://github.com/vehoelite/image-anarchy

Features:
- EXTRACT: Dump partitions from payload.bin files
- CREATE: Repack partition images into a new payload.bin  
- IMAGE EXTRACT: Analyze and extract Android image formats:
  * Sparse images → Raw images
  * Boot/recovery/vendor_boot images → kernel, ramdisk, DTB
  * Super (dynamic partition) images → individual partition images
  * vbmeta patching (disable verity/verification) with optional re-signing
  * ext4/FAT filesystem extraction
  * ELF/bootloader analysis
- IMAGE REPACK: Create Android images from components:
  * Boot/recovery/vendor_boot images (v0-v4)
  * Sparse images from raw
  * vbmeta images (disabled AVB)
  * Ramdisk from directory
- PLUGINS: Extensible plugin system with ADB/Fastboot toolkits
  * ADB Toolkit - Device info, partitions, files, apps, shell, reboot
  * Fastboot Toolkit - Flash, boot, fetch, erase, OEM unlock, slots
  * Create your own plugins with monetization support!
- Support for local files and remote URLs (http, https, s3, gs)
- Automatic zip file handling
- Differential OTA support (extract only)
- Multiple compression formats: ZSTD, XZ, BZ2, Brotli
- Modern dark-themed GUI with drag & drop
- Non-blocking threaded operations
- Custom AVB key signing support

Dependencies:
    pip install PyQt6 bsdiff4 brotli zstandard fsspec protobuf
    pip install cryptography  # Optional: for AVB signing

Usage:
    python image_anarchy.py                           # Launch GUI
    
    # Extract mode (payload)
    python image_anarchy.py --extract payload.bin     # Extract all partitions
    python image_anarchy.py --extract ota.zip -i system,vendor
    
    # Create mode  
    python image_anarchy.py --create ./images -o new_payload.bin
    python image_anarchy.py --create ./images --compression xz --level 6
    
    # Image extraction mode
    python image_anarchy.py --image super.img         # Extract super partitions
    python image_anarchy.py --image boot.img          # Extract boot components
    python image_anarchy.py --image sparse.img        # Convert sparse to raw
    python image_anarchy.py --image system.img --analyze  # Analyze only
"""

import argparse
import bz2
import gzip
import hashlib
import io
import json
import logging
import os
import shutil
import struct
import subprocess
import sys
import urllib.parse
import uuid
import webbrowser
import zipfile
from dataclasses import dataclass
from pathlib import Path
from typing import Any, BinaryIO, Callable, Dict, List, Optional, Tuple

# Fix for PyInstaller windowed mode: sys.stdout/stderr are None, but some
# libraries (like mtkclient) call sys.stdout.detach() which crashes.
# Create a proper mock stream that supports detach() for binary mode conversion.
if sys.stdout is None or sys.stderr is None:
    class _NullStream:
        """Null stream that supports both text and binary operations including detach()."""
        def write(self, *args, **kwargs): return 0
        def read(self, *args, **kwargs): return ''
        def flush(self, *args, **kwargs): pass
        def close(self, *args, **kwargs): pass
        def fileno(self, *args, **kwargs): raise OSError("Null stream has no file descriptor")
        def isatty(self): return False
        def readable(self): return False
        def writable(self): return True
        def seekable(self): return False
        def detach(self): return _NullBinaryStream()
        def __enter__(self): return self
        def __exit__(self, *args): pass
        encoding = 'utf-8'
        errors = 'strict'
        newlines = None
        buffer = None
        closed = False
        
    class _NullBinaryStream:
        """Null binary stream returned by detach()."""
        def write(self, *args, **kwargs): return 0
        def read(self, *args, **kwargs): return b''
        def flush(self, *args, **kwargs): pass
        def close(self, *args, **kwargs): pass
        def fileno(self, *args, **kwargs): raise OSError("Null stream has no file descriptor")
        def isatty(self): return False
        def readable(self): return False
        def writable(self): return True
        def seekable(self): return False
        def __enter__(self): return self
        def __exit__(self, *args): pass
        mode = 'wb'
        closed = False
    
    if sys.stdout is None:
        sys.stdout = _NullStream()
    if sys.stderr is None:
        sys.stderr = _NullStream()

# Plugin dependency support: When running as a frozen exe, plugins install their
# pip dependencies to a local site-packages directory. Add it to sys.path so
# the bundled Python can find packages installed after the exe was built.
def _setup_plugin_site_packages():
    """Add local plugin site-packages to sys.path for frozen exe support."""
    if getattr(sys, 'frozen', False):
        # Running as PyInstaller exe
        base_dir = os.path.dirname(sys.executable)
    else:
        # Running from source
        base_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Add base_dir to sys.path so visual_plugin_maker_v2.py can be found
    if base_dir not in sys.path:
        sys.path.insert(0, base_dir)
    
    # Local site-packages for plugin dependencies
    local_site_packages = os.path.join(base_dir, 'plugin_packages')
    
    # Create if doesn't exist
    if not os.path.exists(local_site_packages):
        try:
            os.makedirs(local_site_packages, exist_ok=True)
        except Exception:
            pass  # May fail if no write permission, that's OK
    
    # Add to sys.path if not already there (insert at front for priority)
    if local_site_packages not in sys.path:
        sys.path.insert(0, local_site_packages)
    
    return local_site_packages

# Initialize plugin site-packages path
_PLUGIN_PACKAGES_DIR = _setup_plugin_site_packages()

# =============================================================================
# ADMIN ELEVATION (Windows) - Required for USB device access
# =============================================================================

def is_admin():
    """Check if the current process has administrator privileges."""
    if sys.platform != 'win32':
        return True  # Not needed on Linux/Mac (use sudo if needed)
    
    try:
        import ctypes
        return ctypes.windll.shell32.IsUserAnAdmin() != 0
    except Exception:
        return False

def run_as_admin():
    """Re-launch the current script with administrator privileges.
    
    Returns True if elevation was requested (and script should exit),
    False if already admin or elevation not needed.
    """
    if sys.platform != 'win32':
        return False  # Not Windows
    
    if is_admin():
        return False  # Already admin
    
    try:
        import ctypes
        
        # Get the script/exe path
        if getattr(sys, 'frozen', False):
            # Running as PyInstaller exe
            script = sys.executable
            params = ' '.join(sys.argv[1:])
        else:
            # Running as Python script
            script = sys.executable
            params = f'"{os.path.abspath(sys.argv[0])}"'
            if len(sys.argv) > 1:
                params += ' ' + ' '.join(f'"{arg}"' for arg in sys.argv[1:])
        
        # Request UAC elevation
        # SW_SHOWNORMAL = 1
        ret = ctypes.windll.shell32.ShellExecuteW(
            None,           # hwnd
            "runas",        # lpOperation (run as admin)
            script,         # lpFile
            params,         # lpParameters
            None,           # lpDirectory
            1               # nShowCmd (SW_SHOWNORMAL)
        )
        
        # ShellExecuteW returns > 32 on success
        if ret > 32:
            return True  # Elevation requested, caller should exit
        else:
            return False  # Elevation failed or was cancelled
            
    except Exception:
        return False

# Third-party imports
import brotli
import bsdiff4
import fsspec
import zstandard
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

# Cryptography imports for AVB signing
try:
    from cryptography.hazmat.primitives import hashes, serialization  # type: ignore
    from cryptography.hazmat.primitives.asymmetric import rsa, padding  # type: ignore
    from cryptography.hazmat.backends import default_backend  # type: ignore
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

# Visual Plugin Maker v2 - AST-based plugin editor module
# Imported lazily to avoid import errors during initial load
_VisualPluginMakerV2 = None

def _get_visual_plugin_maker_v2():
    """Lazy import of VisualPluginMakerV2 to avoid circular imports."""
    global _VisualPluginMakerV2
    if _VisualPluginMakerV2 is None:
        try:
            from visual_plugin_maker_v2 import VisualPluginMakerV2
            _VisualPluginMakerV2 = VisualPluginMakerV2
        except ImportError as e:
            logger.warning(f"Could not import VisualPluginMakerV2: {e}")
            _VisualPluginMakerV2 = None
    return _VisualPluginMakerV2

# Application version - used for update checking
APP_VERSION = "3.2"
APP_VERSION_CODE = 320  # Numeric version for comparison (3.2 = 320)


def get_app_dir() -> str:
    """Get the application directory, handling frozen exe correctly.

    Returns:
        str: Path to the directory containing the app (exe location or script location)

    When running as frozen exe: returns directory containing ImageAnarchy.exe
    When running from source: returns directory containing image_anarchy.py

    IMPORTANT: Use this function instead of __file__ for consistent path handling.
    """
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    else:
        return os.path.dirname(os.path.abspath(__file__))


def _extract_bundled_resources():
    """Extract bundled resources from PyInstaller _MEIPASS to app directory.
    
    When running as a frozen exe, PyInstaller extracts files to a temp directory.
    This function copies necessary resources (drivers, etc.) to the app's directory
    so they persist and can be used by plugins.
    
    NOTE: platform-tools (ADB/Fastboot) are NOT bundled with the main exe.
    Plugins that need them should declare them in their manifest.json using
    bundled_binaries with download URLs. This keeps the exe smaller and follows
    the plugin dependency system.
    """
    if not getattr(sys, 'frozen', False):
        return  # Not running as frozen exe
    
    # PyInstaller temp directory with bundled files
    meipass = getattr(sys, '_MEIPASS', None)
    if not meipass:
        return
    
    # App directory (where exe is located)
    app_dir = os.path.dirname(sys.executable)
    
    # First run marker file
    first_run_marker = os.path.join(app_dir, '.first_run_complete')
    is_first_run = not os.path.exists(first_run_marker)
    
    # Resources to extract if they don't exist
    # These are bundled in the exe via ImageAnarchy.spec and extracted on first run
    # - drivers: Android USB drivers + VC++ Redistributable for device connections
    # - PortableGit: Git for Windows (used by plugins that need git clone)
    # - plugins: Plugin system with built-in and user-installed plugins
    # - tools: CLI utilities (EROFS tools, Allwinner imgRePacker, Rockchip imgRePackerRK)
    # - python_embedded: Embedded Python for plugin pip installs (no system Python needed)
    resources = ['drivers', 'PortableGit', 'plugins', 'tools', 'python_embedded']
    
    for resource in resources:
        src = os.path.join(meipass, resource)
        dst = os.path.join(app_dir, resource)
        
        if os.path.exists(src) and not os.path.exists(dst):
            try:
                if os.path.isdir(src):
                    shutil.copytree(src, dst)
                else:
                    shutil.copy2(src, dst)
            except Exception:
                pass  # Silently continue if extraction fails
    
    # Install VC++ Redistributable on first run (required for PyQt6/Qt6 DLLs)
    if is_first_run:
        _install_vc_redist(app_dir)
        # Create first run marker
        try:
            with open(first_run_marker, 'w') as f:
                f.write('1')
        except:
            pass


def _install_vc_redist(app_dir: str):
    """Install Visual C++ Redistributable silently on first run.
    
    The VC++ Redist is required for PyQt6/Qt6 DLLs to work properly.
    It's bundled in drivers/VC_redist.x64.exe and runs silently with /quiet.
    """
    vc_redist = os.path.join(app_dir, 'drivers', 'VC_redist.x64.exe')
    
    if not os.path.exists(vc_redist):
        return  # Not found, skip
    
    try:
        # Run silently with /quiet /norestart flags
        # This won't show any UI and won't require restart
        subprocess.run(
            [vc_redist, '/quiet', '/norestart'],
            capture_output=True,
            timeout=120  # 2 minute timeout
        )
    except Exception:
        pass  # Silently continue if install fails - user may already have it


# Extract bundled resources on import (runs once on first launch)
_extract_bundled_resources()


def _get_python_executable() -> Optional[str]:
    """Get the Python interpreter path, handling frozen exe case.
    
    When running as a PyInstaller frozen exe, sys.executable points to the exe,
    not Python. This function finds the actual Python interpreter.
    
    Priority:
    1. Bundled python_embedded (extracted next to exe)
    2. System Python in PATH
    
    Returns:
        Path to Python interpreter, or None if not found when frozen.
    """
    if getattr(sys, 'frozen', False):
        # Running as frozen exe
        # First check for bundled python_embedded
        base_dir = os.path.dirname(sys.executable)
        embedded_python = os.path.join(base_dir, 'python_embedded', 'python.exe')
        
        # Check if embedded Python exists and is valid
        if os.path.isfile(embedded_python):
            # Verify it's actually executable by checking file size
            try:
                if os.path.getsize(embedded_python) > 0:
                    return embedded_python
            except Exception:
                pass
        
        # Try to extract it if it doesn't exist (may have been deleted)
        meipass = getattr(sys, '_MEIPASS', None)
        if meipass:
            src_python_embedded = os.path.join(meipass, 'python_embedded')
            dst_python_embedded = os.path.join(base_dir, 'python_embedded')
            if os.path.exists(src_python_embedded) and not os.path.exists(dst_python_embedded):
                try:
                    shutil.copytree(src_python_embedded, dst_python_embedded)
                    if os.path.isfile(embedded_python):
                        return embedded_python
                except Exception:
                    pass
        
        # Fallback to system Python in PATH (only if embedded not found)
        # This is a last resort - prefer embedded Python for consistency
        fallback = shutil.which('python') or shutil.which('python3')
        # Avoid 'py' launcher as it may return different Python versions
        if not fallback:
            fallback = shutil.which('py')
        return fallback
    return sys.executable


def _get_clean_python_env() -> dict:
    """Get a clean environment for running embedded Python.
    
    When running as a frozen exe, we need to ensure the embedded Python
    doesn't get confused by the user's system Python installation.
    This removes Python-related environment variables that could interfere.
    
    Returns:
        dict: Clean environment dictionary for subprocess calls
    """
    env = os.environ.copy()
    
    if not getattr(sys, 'frozen', False):
        return env  # Not frozen, use normal env
    
    # Remove variables that could make embedded Python use wrong paths
    python_vars_to_remove = [
        'PYTHONPATH',
        'PYTHONHOME', 
        'PYTHONSTARTUP',
        'PYTHONUSERBASE',
        'VIRTUAL_ENV',
        'CONDA_PREFIX',
        'CONDA_DEFAULT_ENV',
    ]
    
    for var in python_vars_to_remove:
        env.pop(var, None)
    
    # Set PYTHONNOUSERSITE to prevent loading user site-packages
    env['PYTHONNOUSERSITE'] = '1'
    
    # Ensure embedded Python's directory is at the front of PATH
    base_dir = os.path.dirname(sys.executable)
    embedded_dir = os.path.join(base_dir, 'python_embedded')
    embedded_scripts = os.path.join(embedded_dir, 'Scripts')
    
    if os.path.exists(embedded_dir):
        # Prepend embedded Python paths to PATH
        current_path = env.get('PATH', '')
        new_path = f"{embedded_dir};{embedded_scripts};{current_path}"
        env['PATH'] = new_path
    
    return env


try:
    import lzma
except ImportError:
    from backports import lzma  # type: ignore

# =============================================================================
# EMBEDDED PROTOBUF DEFINITIONS
# =============================================================================
# This replaces the need for update_metadata_pb2.py
# Generated from update_metadata.proto (ChromeOS/Android OTA format)

_sym_db = _symbol_database.Default()

_PROTOBUF_DESCRIPTOR = (
    b'\n\x15update_metadata.proto\x12\x16chromeos_update_engine\"1\n\x06Extent'
    b'\x12\x13\n\x0bstart_block\x18\x01 \x01(\x04\x12\x12\n\nnum_blocks\x18\x02'
    b' \x01(\x04\"\x9f\x01\n\nSignatures\x12@\n\nsignatures\x18\x01 \x03(\x0b2'
    b',.chromeos_update_engine.Signatures.Signature\x1aO\n\tSignature\x12\x13\n'
    b'\x07version\x18\x01 \x01(\rB\x02\x18\x01\x12\x0c\n\x04data\x18\x02 \x01(\x0c'
    b'\x12\x1f\n\x17unpadded_signature_size\x18\x03 \x01(\x07\"+\n\rPartitionInfo'
    b'\x12\x0c\n\x04size\x18\x01 \x01(\x04\x12\x0c\n\x04hash\x18\x02 \x01(\x0c\"'
    b'\xb0\x04\n\x10InstallOperation\x12;\n\x04type\x18\x01 \x02(\x0e2-.chromeos'
    b'_update_engine.InstallOperation.Type\x12\x13\n\x0bdata_offset\x18\x02 \x01'
    b'(\x04\x12\x13\n\x0bdata_length\x18\x03 \x01(\x04\x123\n\x0bsrc_extents\x18'
    b'\x04 \x03(\x0b2\x1e.chromeos_update_engine.Extent\x12\x12\n\nsrc_length\x18'
    b'\x05 \x01(\x04\x123\n\x0bdst_extents\x18\x06 \x03(\x0b2\x1e.chromeos_update'
    b'_engine.Extent\x12\x12\n\ndst_length\x18\x07 \x01(\x04\x12\x18\n\x10data_sha'
    b'256_hash\x18\x08 \x01(\x0c\x12\x17\n\x0fsrc_sha256_hash\x18\t \x01(\x0c\"\xef'
    b'\x01\n\x04Type\x12\x0b\n\x07REPLACE\x10\x00\x12\x0e\n\nREPLACE_BZ\x10\x01'
    b'\x12\x0c\n\x04MOVE\x10\x02\x1a\x02\x08\x01\x12\x0e\n\x06BSDIFF\x10\x03\x1a'
    b'\x02\x08\x01\x12\x0f\n\x0bSOURCE_COPY\x10\x04\x12\x11\n\rSOURCE_BSDIFF\x10'
    b'\x05\x12\x0e\n\nREPLACE_XZ\x10\x08\x12\x08\n\x04ZERO\x10\x06\x12\x0b\n\x07'
    b'DISCARD\x10\x07\x12\x11\n\rBROTLI_BSDIFF\x10\n\x12\x0c\n\x08PUFFDIFF\x10\t'
    b'\x12\x0c\n\x08ZUCCHINI\x10\x0b\x12\x12\n\x0eLZ4DIFF_BSDIFF\x10\x0c\x12\x14'
    b'\n\x10LZ4DIFF_PUFFDIFF\x10\r\x12\x08\n\x04ZSTD\x10\x0e\"\x81\x02\n\x11Cow'
    b'MergeOperation\x12<\n\x04type\x18\x01 \x01(\x0e2..chromeos_update_engine.'
    b'CowMergeOperation.Type\x122\n\nsrc_extent\x18\x02 \x01(\x0b2\x1e.chromeos'
    b'_update_engine.Extent\x122\n\ndst_extent\x18\x03 \x01(\x0b2\x1e.chromeos_'
    b'update_engine.Extent\x12\x12\n\nsrc_offset\x18\x04 \x01(\r\"2\n\x04Type\x12'
    b'\x0c\n\x08COW_COPY\x10\x00\x12\x0b\n\x07COW_XOR\x10\x01\x12\x0f\n\x0bCOW_'
    b'REPLACE\x10\x02\"\xe7\x06\n\x0fPartitionUpdate\x12\x16\n\x0epartition_name'
    b'\x18\x01 \x02(\t\x12\x17\n\x0frun_postinstall\x18\x02 \x01(\x08\x12\x18\n'
    b'\x10postinstall_path\x18\x03 \x01(\t\x12\x17\n\x0ffilesystem_type\x18\x04'
    b' \x01(\t\x12M\n\x17new_partition_signature\x18\x05 \x03(\x0b2,.chromeos_'
    b'update_engine.Signatures.Signature\x12A\n\x12old_partition_info\x18\x06 '
    b'\x01(\x0b2%.chromeos_update_engine.PartitionInfo\x12A\n\x12new_partition_'
    b'info\x18\x07 \x01(\x0b2%.chromeos_update_engine.PartitionInfo\x12<\n\n'
    b'operations\x18\x08 \x03(\x0b2(.chromeos_update_engine.InstallOperation'
    b'\x12\x1c\n\x14postinstall_optional\x18\t \x01(\x08\x12=\n\x15hash_tree_data'
    b'_extent\x18\n \x01(\x0b2\x1e.chromeos_update_engine.Extent\x128\n\x10hash'
    b'_tree_extent\x18\x0b \x01(\x0b2\x1e.chromeos_update_engine.Extent\x12\x1b'
    b'\n\x13hash_tree_algorithm\x18\x0c \x01(\t\x12\x16\n\x0ehash_tree_salt\x18'
    b'\r \x01(\x0c\x127\n\x0ffec_data_extent\x18\x0e \x01(\x0b2\x1e.chromeos_'
    b'update_engine.Extent\x122\n\nfec_extent\x18\x0f \x01(\x0b2\x1e.chromeos_'
    b'update_engine.Extent\x12\x14\n\tfec_roots\x18\x10 \x01(\r:\x012\x12\x0f\n'
    b'\x07version\x18\x11 \x01(\t\x12C\n\x10merge_operations\x18\x12 \x03(\x0b2)'
    b'.chromeos_update_engine.CowMergeOperation\x12\x19\n\x11estimate_cow_size'
    b'\x18\x13 \x01(\x04\x12\x1d\n\x15estimate_op_count_max\x18\x14 \x01(\x04\"L'
    b'\n\x15DynamicPartitionGroup\x12\x0c\n\x04name\x18\x01 \x02(\t\x12\x0c\n\x04'
    b'size\x18\x02 \x01(\x04\x12\x17\n\x0fpartition_names\x18\x03 \x03(\t\"8\n\x0e'
    b'VABCFeatureSet\x12\x10\n\x08threaded\x18\x01 \x01(\x08\x12\x14\n\x0cbatch_'
    b'writes\x18\x02 \x01(\x08\"\x9c\x02\n\x18DynamicPartitionMetadata\x12=\n\x06'
    b'groups\x18\x01 \x03(\x0b2-.chromeos_update_engine.DynamicPartitionGroup'
    b'\x12\x18\n\x10snapshot_enabled\x18\x02 \x01(\x08\x12\x14\n\x0cvabc_enabled'
    b'\x18\x03 \x01(\x08\x12\x1e\n\x16vabc_compression_param\x18\x04 \x01(\t\x12'
    b'\x13\n\x0bcow_version\x18\x05 \x01(\r\x12@\n\x10vabc_feature_set\x18\x06 '
    b'\x01(\x0b2&.chromeos_update_engine.VABCFeatureSet\x12\x1a\n\x12compression'
    b'_factor\x18\x07 \x01(\x04\"c\n\x08ApexInfo\x12\x14\n\x0cpackage_name\x18'
    b'\x01 \x01(\t\x12\x0f\n\x07version\x18\x02 \x01(\x03\x12\x15\n\ris_compressed'
    b'\x18\x03 \x01(\x08\x12\x19\n\x11decompressed_size\x18\x04 \x01(\x03\"C\n\x0c'
    b'ApexMetadata\x123\n\tapex_info\x18\x01 \x03(\x0b2 .chromeos_update_engine.'
    b'ApexInfo\"\xc3\x03\n\x14DeltaArchiveManifest\x12\x18\n\nblock_size\x18\x03'
    b' \x01(\r:\x044096\x12\x19\n\x11signatures_offset\x18\x04 \x01(\x04\x12\x17'
    b'\n\x0fsignatures_size\x18\x05 \x01(\x04\x12\x18\n\rminor_version\x18\x0c '
    b'\x01(\r:\x010\x12;\n\npartitions\x18\r \x03(\x0b2\'.chromeos_update_engine.'
    b'PartitionUpdate\x12\x15\n\rmax_timestamp\x18\x0e \x01(\x03\x12T\n\x1adynamic'
    b'_partition_metadata\x18\x0f \x01(\x0b20.chromeos_update_engine.Dynamic'
    b'PartitionMetadata\x12\x16\n\x0epartial_update\x18\x10 \x01(\x08\x123\n\t'
    b'apex_info\x18\x11 \x03(\x0b2 .chromeos_update_engine.ApexInfo\x12\x1c\n\x14'
    b'security_patch_level\x18\x12 \x01(\tJ\x04\x08\x01\x10\x02J\x04\x08\x02\x10'
    b'\x03J\x04\x08\x06\x10\x07J\x04\x08\x07\x10\x08J\x04\x08\x08\x10\tJ\x04\x08'
    b'\t\x10\nJ\x04\x08\n\x10\x0bJ\x04\x08\x0b\x10\x0c'
)

DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(_PROTOBUF_DESCRIPTOR)

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'update_metadata_pb2', _globals)

# Reference the built message classes (created by BuildTopDescriptorsAndMessages)
DeltaArchiveManifest = _globals['DeltaArchiveManifest']
InstallOperation = _globals['InstallOperation']
Extent = _globals['Extent']
PartitionUpdate = _globals['PartitionUpdate']
Signatures = _globals['Signatures']
PartitionInfo = _globals['PartitionInfo']


# =============================================================================
# CONSTANTS AND LOGGING
# =============================================================================

PAYLOAD_MAGIC = b'CrAU'
BSDF2_MAGIC = b'BSDF2'
SUPPORTED_FORMAT_VERSION = 2

logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger(__name__)


# =============================================================================
# EXCEPTIONS
# =============================================================================

class PayloadError(Exception):
    """Base exception for payload processing errors."""
    pass


class UnsupportedOperationError(PayloadError):
    """Raised when an unsupported operation type is encountered."""
    pass


class DifferentialOTAError(PayloadError):
    """Raised when differential OTA requirements are not met."""
    pass


# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

def unpack_u32(data: bytes) -> int:
    """Unpack a big-endian 32-bit unsigned integer."""
    return struct.unpack('>I', data)[0]


def unpack_u64(data: bytes) -> int:
    """Unpack a big-endian 64-bit unsigned integer."""
    return struct.unpack('>Q', data)[0]


def bsdf2_decompress(algorithm: int, data: bytes) -> bytes:
    """Decompress data using the specified BSDF2 algorithm."""
    decompressors = {
        0: lambda d: d,
        1: bz2.decompress,
        2: brotli.decompress,
    }
    if algorithm not in decompressors:
        raise PayloadError(f"Unknown BSDF2 compression algorithm: {algorithm}")
    return decompressors[algorithm](data)


def bsdf2_read_patch(stream: BinaryIO) -> tuple:
    """Read a bsdiff/BSDF2-format patch from a stream."""
    magic = stream.read(8)
    
    if magic == bsdiff4.format.MAGIC:
        alg_control = alg_diff = alg_extra = 1
    elif magic[:5] == BSDF2_MAGIC:
        alg_control, alg_diff, alg_extra = magic[5], magic[6], magic[7]
    else:
        raise PayloadError("Invalid bsdiff/BSDF2 header")

    len_control = bsdiff4.core.decode_int64(stream.read(8))
    len_diff = bsdiff4.core.decode_int64(stream.read(8))
    len_dst = bsdiff4.core.decode_int64(stream.read(8))

    bcontrol = bsdf2_decompress(alg_control, stream.read(len_control))
    tcontrol = [
        (
            bsdiff4.core.decode_int64(bcontrol[i:i + 8]),
            bsdiff4.core.decode_int64(bcontrol[i + 8:i + 16]),
            bsdiff4.core.decode_int64(bcontrol[i + 16:i + 24])
        )
        for i in range(0, len(bcontrol), 24)
    ]

    bdiff = bsdf2_decompress(alg_diff, stream.read(len_diff))
    bextra = bsdf2_decompress(alg_extra, stream.read())
    
    return len_dst, tcontrol, bdiff, bextra


# =============================================================================
# PAYLOAD FILE HANDLING
# =============================================================================

class PayloadFile:
    """Context manager for opening payload files (local, remote, or inside zip)."""
    
    def __init__(self, file_path: str):
        self.file_path = file_path
        self._file: Optional[BinaryIO] = None
        self._zip_file: Optional[zipfile.ZipFile] = None
        self._remote_file: Optional[BinaryIO] = None
    
    def __enter__(self) -> BinaryIO:
        is_url = self.file_path.startswith(('http://', 'https://', 's3://', 'gs://'))
        self._file = self._open_remote() if is_url else self._open_local()
        return self._file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self._file:
            self._file.close()
        if self._zip_file:
            self._zip_file.close()
        if self._remote_file:
            self._remote_file.close()
    
    def _open_remote(self) -> BinaryIO:
        protocol = urllib.parse.urlparse(self.file_path).scheme
        fs = fsspec.filesystem(protocol)
        self._remote_file = fs.open(self.file_path)
        
        if zipfile.is_zipfile(self._remote_file):
            self._remote_file.seek(0)
            self._zip_file = zipfile.ZipFile(self._remote_file)
            return self._extract_payload_from_zip(self._zip_file)
        
        self._remote_file.seek(0)
        return self._remote_file
    
    def _open_local(self) -> BinaryIO:
        if zipfile.is_zipfile(self.file_path):
            self._zip_file = zipfile.ZipFile(self.file_path)
            return self._extract_payload_from_zip(self._zip_file)
        return open(self.file_path, 'rb')
    
    @staticmethod
    def _extract_payload_from_zip(zf: zipfile.ZipFile) -> BinaryIO:
        if "payload.bin" not in zf.namelist():
            raise PayloadError("payload.bin not found in zip file")
        return zf.open("payload.bin")


# =============================================================================
# OPERATION HANDLER
# =============================================================================

class OperationHandler:
    """Handles different operation types for partition extraction."""
    
    def __init__(self, payload_file: BinaryIO, data_offset: int, block_size: int):
        self.payload_file = payload_file
        self.data_offset = data_offset
        self.block_size = block_size
    
    def process(self, op, out_file: BinaryIO, old_file: Optional[BinaryIO] = None) -> bytes:
        """Process an operation and write the result to the output file."""
        data = self._read_operation_data(op)
        
        handlers = {
            op.REPLACE_XZ: self._handle_replace_xz,
            op.ZSTD: self._handle_zstd,
            op.REPLACE_BZ: self._handle_replace_bz,
            op.REPLACE: self._handle_replace,
            op.SOURCE_COPY: self._handle_source_copy,
            op.SOURCE_BSDIFF: self._handle_bsdiff,
            op.BROTLI_BSDIFF: self._handle_bsdiff,
            op.ZERO: self._handle_zero,
        }
        
        handler = handlers.get(op.type)
        if handler is None:
            raise UnsupportedOperationError(f"Unsupported operation type: {op.type}")
        
        handler(op, data, out_file, old_file)
        return data
    
    def _read_operation_data(self, op) -> bytes:
        self.payload_file.seek(self.data_offset + op.data_offset)
        data = self.payload_file.read(op.data_length)
        
        if op.data_sha256_hash:
            if hashlib.sha256(data).digest() != op.data_sha256_hash:
                raise PayloadError("Operation data hash mismatch")
        return data
    
    def _handle_replace_xz(self, op, data: bytes, out_file: BinaryIO, _old_file) -> None:
        decompressed = lzma.LZMADecompressor().decompress(data)
        self._write_to_extent(out_file, op.dst_extents[0], decompressed)
    
    def _handle_zstd(self, op, data: bytes, out_file: BinaryIO, _old_file) -> None:
        decompressed = zstandard.ZstdDecompressor().decompressobj().decompress(data)
        self._write_to_extent(out_file, op.dst_extents[0], decompressed)
    
    def _handle_replace_bz(self, op, data: bytes, out_file: BinaryIO, _old_file) -> None:
        decompressed = bz2.BZ2Decompressor().decompress(data)
        self._write_to_extent(out_file, op.dst_extents[0], decompressed)
    
    def _handle_replace(self, op, data: bytes, out_file: BinaryIO, _old_file) -> None:
        self._write_to_extent(out_file, op.dst_extents[0], data)
    
    def _handle_source_copy(self, op, _data: bytes, out_file: BinaryIO, old_file: Optional[BinaryIO]) -> None:
        if not old_file:
            raise DifferentialOTAError("SOURCE_COPY requires original image for differential OTA")
        
        out_file.seek(op.dst_extents[0].start_block * self.block_size)
        for ext in op.src_extents:
            old_file.seek(ext.start_block * self.block_size)
            out_file.write(old_file.read(ext.num_blocks * self.block_size))
    
    def _handle_bsdiff(self, op, data: bytes, out_file: BinaryIO, old_file: Optional[BinaryIO]) -> None:
        if not old_file:
            raise DifferentialOTAError("BSDIFF requires original image for differential OTA")
        
        src_buffer = io.BytesIO()
        for ext in op.src_extents:
            old_file.seek(ext.start_block * self.block_size)
            src_buffer.write(old_file.read(ext.num_blocks * self.block_size))
        
        src_buffer.seek(0)
        patched = bsdiff4.core.patch(src_buffer.read(), *bsdf2_read_patch(io.BytesIO(data)))
        
        patched_buffer = io.BytesIO(patched)
        block_offset = 0
        for ext in op.dst_extents:
            patched_buffer.seek(block_offset * self.block_size)
            block_offset += ext.num_blocks
            out_file.seek(ext.start_block * self.block_size)
            out_file.write(patched_buffer.read(ext.num_blocks * self.block_size))
    
    def _handle_zero(self, op, _data: bytes, out_file: BinaryIO, _old_file) -> None:
        for ext in op.dst_extents:
            out_file.seek(ext.start_block * self.block_size)
            out_file.write(b'\x00' * ext.num_blocks * self.block_size)
    
    def _write_to_extent(self, out_file: BinaryIO, extent, data: bytes) -> None:
        out_file.seek(extent.start_block * self.block_size)
        out_file.write(data)


# =============================================================================
# PAYLOAD CREATOR (REPACKER)
# =============================================================================

class CompressionType:
    """Supported compression types for payload creation."""
    NONE = 'none'
    ZSTD = 'zstd'
    XZ = 'xz'
    BZ2 = 'bz2'
    
    @classmethod
    def all(cls) -> list[str]:
        return [cls.NONE, cls.ZSTD, cls.XZ, cls.BZ2]


def pack_u32(value: int) -> bytes:
    """Pack a big-endian 32-bit unsigned integer."""
    return struct.pack('>I', value)


def pack_u64(value: int) -> bytes:
    """Pack a big-endian 64-bit unsigned integer."""
    return struct.pack('>Q', value)


def compress_data(data: bytes, compression: str, level: int = 9) -> tuple[bytes, int]:
    """
    Compress data using the specified algorithm.
    Returns (compressed_data, operation_type).
    """
    if compression == CompressionType.NONE:
        return data, 0  # REPLACE
    elif compression == CompressionType.ZSTD:
        cctx = zstandard.ZstdCompressor(level=level)
        return cctx.compress(data), 14  # ZSTD
    elif compression == CompressionType.XZ:
        return lzma.compress(data, preset=level), 8  # REPLACE_XZ
    elif compression == CompressionType.BZ2:
        return bz2.compress(data, compresslevel=level), 1  # REPLACE_BZ
    else:
        raise PayloadError(f"Unknown compression type: {compression}")


class PayloadCreator:
    """Creates OTA payload files from partition images."""
    
    DEFAULT_BLOCK_SIZE = 4096
    BLOCKS_PER_OPERATION = 2048  # ~8MB per operation for better parallelism
    
    def __init__(
        self,
        output_path: str,
        block_size: int = DEFAULT_BLOCK_SIZE,
        compression: str = CompressionType.ZSTD,
        compression_level: int = 9,
        progress_callback: Optional[Callable] = None
    ):
        self.output_path = Path(output_path)
        self.block_size = block_size
        self.compression = compression
        self.compression_level = compression_level
        self.progress_callback = progress_callback
    
    def create(self, image_paths: list[str]) -> None:
        """
        Create a payload.bin from partition images.
        
        Args:
            image_paths: List of paths to partition image files.
                        Partition names are derived from filenames (e.g., system.img -> system)
        """
        logger.info(f"Creating payload with {len(image_paths)} partition(s)...")
        logger.info(f"Compression: {self.compression}, Block size: {self.block_size}")
        
        # Collect all operation data first
        partitions_data = []
        all_data_blobs = []
        current_data_offset = 0
        
        total_size = sum(os.path.getsize(p) for p in image_paths)
        processed_size = 0
        
        for image_path in image_paths:
            path = Path(image_path)
            partition_name = path.stem  # system.img -> system
            
            logger.info(f"Processing {partition_name}...")
            
            partition_ops, data_blobs, partition_size = self._process_partition(
                path, partition_name, current_data_offset
            )
            
            # Update data offset for next partition
            for blob in data_blobs:
                current_data_offset += len(blob)
                all_data_blobs.append(blob)
            
            partitions_data.append((partition_name, partition_ops, partition_size))
            
            processed_size += os.path.getsize(image_path)
            if self.progress_callback:
                self.progress_callback(processed_size, total_size, f"Processed {partition_name}")
        
        # Build manifest
        manifest = self._build_manifest(partitions_data)
        manifest_bytes = manifest.SerializeToString()
        
        # Write payload file
        logger.info(f"Writing payload to {self.output_path}...")
        self._write_payload(manifest_bytes, all_data_blobs)
        
        logger.info(f"Payload created successfully: {self.output_path}")
        logger.info(f"Total size: {self.output_path.stat().st_size / (1024*1024):.2f} MB")
    
    def _process_partition(
        self, 
        image_path: Path, 
        partition_name: str,
        base_data_offset: int
    ) -> tuple[list, list[bytes], int]:
        """Process a single partition image and return operations and data blobs."""
        operations = []
        data_blobs = []
        current_offset = base_data_offset
        
        file_size = image_path.stat().st_size
        total_blocks = (file_size + self.block_size - 1) // self.block_size
        
        with open(image_path, 'rb') as f:
            block_num = 0
            
            while block_num < total_blocks:
                # Determine how many blocks to process in this operation
                remaining_blocks = total_blocks - block_num
                op_blocks = min(self.BLOCKS_PER_OPERATION, remaining_blocks)
                
                # Read the data
                chunk_size = op_blocks * self.block_size
                data = f.read(chunk_size)
                
                # Pad last chunk if needed
                if len(data) < chunk_size:
                    data = data + b'\x00' * (chunk_size - len(data))
                
                # Check if block is all zeros (can use ZERO operation)
                if data == b'\x00' * len(data):
                    op = InstallOperation()
                    op.type = 6  # ZERO
                    
                    dst_extent = op.dst_extents.add()
                    dst_extent.start_block = block_num
                    dst_extent.num_blocks = op_blocks
                    
                    operations.append(op)
                else:
                    # Compress the data
                    compressed, op_type = compress_data(
                        data, self.compression, self.compression_level
                    )
                    
                    # Create operation
                    op = InstallOperation()
                    op.type = op_type
                    op.data_offset = current_offset
                    op.data_length = len(compressed)
                    op.data_sha256_hash = hashlib.sha256(compressed).digest()
                    
                    dst_extent = op.dst_extents.add()
                    dst_extent.start_block = block_num
                    dst_extent.num_blocks = op_blocks
                    
                    operations.append(op)
                    data_blobs.append(compressed)
                    current_offset += len(compressed)
                
                block_num += op_blocks
        
        return operations, data_blobs, file_size
    
    def _build_manifest(self, partitions_data: list) -> DeltaArchiveManifest:
        """Build the DeltaArchiveManifest protobuf message."""
        manifest = DeltaArchiveManifest()
        manifest.block_size = self.block_size
        manifest.minor_version = 0
        
        for partition_name, operations, partition_size in partitions_data:
            partition = manifest.partitions.add()
            partition.partition_name = partition_name
            
            # Add partition info
            partition.new_partition_info.size = partition_size
            
            # Add operations
            for op in operations:
                new_op = partition.operations.add()
                new_op.CopyFrom(op)
        
        return manifest
    
    def _write_payload(self, manifest_bytes: bytes, data_blobs: list[bytes]) -> None:
        """Write the complete payload file."""
        with open(self.output_path, 'wb') as f:
            # Write header
            f.write(PAYLOAD_MAGIC)  # Magic: "CrAU"
            f.write(pack_u64(SUPPORTED_FORMAT_VERSION))  # Version: 2
            f.write(pack_u64(len(manifest_bytes)))  # Manifest size
            f.write(pack_u32(0))  # Metadata signature size (none)
            
            # Write manifest
            f.write(manifest_bytes)
            
            # Write all data blobs
            for blob in data_blobs:
                f.write(blob)


def run_create(args) -> None:
    """Run payload creation from command line."""
    image_paths = []
    input_dir = Path(args.input_dir)
    
    if args.images:
        # Specific images requested
        for name in args.images.split(','):
            name = name.strip()
            img_path = input_dir / f"{name}.img"
            if img_path.exists():
                image_paths.append(str(img_path))
            else:
                logger.warning(f"Image not found: {img_path}")
    else:
        # All .img files in directory
        image_paths = sorted([str(p) for p in input_dir.glob("*.img")])
    
    if not image_paths:
        raise PayloadError(f"No partition images found in {input_dir}")
    
    logger.info(f"Found {len(image_paths)} partition image(s)")
    
    def progress(current, total, msg):
        pct = int(current / total * 100)
        logger.info(f"  [{pct:3d}%] {msg}")
    
    creator = PayloadCreator(
        output_path=args.output,
        compression=args.compression,
        compression_level=args.level,
        progress_callback=progress
    )
    creator.create(image_paths)


# =============================================================================
# ANDROID IMAGE EXTRACTION
# =============================================================================

# Magic numbers for Android image formats
SPARSE_HEADER_MAGIC = 0xED26FF3A
BOOT_MAGIC = b'ANDROID!'
BOOT_MAGIC_V3 = b'ANDROID!'
VENDOR_BOOT_MAGIC = b'VNDRBOOT'
LP_METADATA_MAGIC = 0x414C5030  # "0PLA" - Android Logical Partition metadata header
LP_GEOMETRY_MAGIC = 0x616c4467  # "gDla" - Android Logical Partition geometry
EROFS_MAGIC = 0xE0F5E1E2
EXT4_MAGIC = 0xEF53
FAT_BOOT_SIG = 0xAA55  # FAT boot signature at offset 0x1FE
ELF_MAGIC = b'\x7fELF'  # ELF executable format
MBN_MAGIC = 0x00000005  # Qualcomm MBN type 5 (common)
AVB_MAGIC = b'AVB0'  # Android Verified Boot magic

# Bootloader format magic numbers
LK_MAGIC = b'BOOTLDR!'  # Little Kernel bootloader (MediaTek)
QCOM_MBN_MAGIC_1 = 0x00000005  # Qualcomm MBN format (type 5)
QCOM_MBN_MAGIC_2 = 0x00000007  # Qualcomm MBN format (type 7)
QCOM_ELF_MAGIC = b'\x7fELF'  # Qualcomm signed ELF (XBL, ABL, etc.)
MTK_LOGO_MAGIC = b'LOGO'  # MediaTek logo partition
GZIP_MAGIC = b'\x1f\x8b'  # Gzip compressed
DTBO_MAGIC = 0xD7B7AB1E  # DTBO table magic (Android Device Tree Blob Overlay)


@dataclass
class SparseHeader:
    """Android sparse image header."""
    magic: int
    major_version: int
    minor_version: int
    file_header_size: int
    chunk_header_size: int
    block_size: int
    total_blocks: int
    total_chunks: int
    checksum: int


@dataclass  
class BootImageInfo:
    """Parsed boot image information."""
    header_version: int
    kernel_size: int
    kernel_offset: int
    ramdisk_size: int
    ramdisk_offset: int
    second_size: int
    second_offset: int
    dtb_size: int
    dtb_offset: int
    page_size: int
    os_version: str
    cmdline: str
    extra_cmdline: str


@dataclass
class LpMetadataPartition:
    """Logical partition metadata."""
    name: str
    group_name: str
    first_sector: int
    size: int
    attributes: int


def detect_image_type(file_path: str) -> str:
    """Detect the type of Android image file."""
    with open(file_path, 'rb') as f:
        header = f.read(64)
    
    if len(header) < 4:
        return 'unknown'
    
    # Check for sparse image
    magic = struct.unpack('<I', header[:4])[0]
    if magic == SPARSE_HEADER_MAGIC:
        return 'sparse'
    
    # Check for boot image
    if header[:8] == BOOT_MAGIC:
        return 'boot'
    
    # Check for vendor boot image
    if header[:8] == VENDOR_BOOT_MAGIC:
        return 'vendor_boot'
    
    # Check for super partition (LP geometry at offset 4096)
    with open(file_path, 'rb') as f:
        f.seek(4096)  # LP_METADATA_GEOMETRY_OFFSET
        lp_header = f.read(4)
        if len(lp_header) >= 4:
            lp_magic = struct.unpack('<I', lp_header)[0]
            # Check for geometry magic "gDla" (0x616c4467)
            if lp_magic == LP_GEOMETRY_MAGIC:
                return 'super'
            # Also check for metadata magic "0PLA" (0x414C5030) as fallback
            if lp_magic == LP_METADATA_MAGIC:
                return 'super'
    
    # Check for ext4 (superblock at offset 0x400)
    with open(file_path, 'rb') as f:
        f.seek(0x438)  # ext4 magic offset
        ext4_header = f.read(2)
        if len(ext4_header) >= 2:
            ext4_magic = struct.unpack('<H', ext4_header)[0]
            if ext4_magic == EXT4_MAGIC:
                return 'ext4'
    
    # Check for EROFS
    with open(file_path, 'rb') as f:
        f.seek(0x400)  # EROFS superblock offset
        erofs_header = f.read(4)
        if len(erofs_header) >= 4:
            erofs_magic = struct.unpack('<I', erofs_header)[0]
            if erofs_magic == EROFS_MAGIC:
                return 'erofs'
    
    # Check for LZ4 compressed file (common for .lz4 images)
    # LZ4 frame magic: 0x184D2204 (little endian reads as 04 22 4D 18)
    with open(file_path, 'rb') as f:
        lz4_header = f.read(4)
        if len(lz4_header) >= 4:
            if lz4_header == b'\x04\x22\x4d\x18':  # LZ4 frame magic
                return 'lz4'
            # Also check for legacy LZ4 (block format) - magic 0x184C2102
            if lz4_header == b'\x02\x21\x4c\x18':
                return 'lz4'
    
    # Check for FAT filesystem (common for modem, firmware partitions)
    with open(file_path, 'rb') as f:
        # Check boot signature at offset 0x1FE
        f.seek(0x1FE)
        boot_sig = f.read(2)
        if len(boot_sig) >= 2 and struct.unpack('<H', boot_sig)[0] == FAT_BOOT_SIG:
            # Check for FAT string
            f.seek(0x36)
            fat_type = f.read(8)
            if fat_type[:3] == b'FAT':
                return 'fat'
            # Check for FAT32
            f.seek(0x52)
            fat32_type = f.read(8)
            if fat32_type[:5] == b'FAT32':
                return 'fat'
    
    # Check for ELF - further classify as bootloader if it's a signed Qualcomm image
    if header[:4] == ELF_MAGIC:
        # Check for Qualcomm signed ELF characteristics
        # Qualcomm bootloader ELFs often have specific machine types and program headers
        with open(file_path, 'rb') as f:
            f.seek(0)
            elf_header = f.read(64)
            if len(elf_header) >= 52:
                # Check ELF machine type (0x12 offset for 32-bit, same for 64-bit conceptually)
                ei_class = elf_header[4]  # 1=32-bit, 2=64-bit
                if ei_class == 1:  # 32-bit
                    e_machine = struct.unpack('<H', elf_header[18:20])[0]
                else:  # 64-bit
                    e_machine = struct.unpack('<H', elf_header[18:20])[0]
                
                # ARM=40, AArch64=183, Hexagon=164
                # Check file name hints for bootloader
                filename = Path(file_path).stem.lower()
                
                # ABL is special - return specific type for deeper analysis
                if 'abl' in filename:
                    return 'abl'
                
                bootloader_names = ['xbl', 'hyp', 'tz', 'tzsq', 'devcfg', 'aop', 
                                    'keymaster', 'cmnlib', 'qupfw', 'storsec', 'uefi',
                                    'lk', 'preloader', 'sbl1', 'rpm', 'pmic']
                if any(bl in filename for bl in bootloader_names):
                    return 'bootloader'
        return 'elf'
    
    # Check for AVB vbmeta (Android Verified Boot)
    if header[:4] == AVB_MAGIC:
        return 'vbmeta'
    
    # Check for DTBO (Device Tree Blob Overlay) image
    if len(header) >= 4:
        dtbo_magic = struct.unpack('>I', header[:4])[0]  # Big endian!
        if dtbo_magic == DTBO_MAGIC:
            return 'dtbo'
    
    # Check for Little Kernel bootloader (MediaTek)
    if header[:8] == LK_MAGIC:
        return 'bootloader'
    
    # Check for Qualcomm MBN format
    if len(header) >= 40:
        # MBN has a specific header structure
        mbn_type = struct.unpack('<I', header[0:4])[0]
        if mbn_type in (QCOM_MBN_MAGIC_1, QCOM_MBN_MAGIC_2):
            # Further verify by checking header fields
            flash_parti_ver = struct.unpack('<I', header[4:8])[0]
            if flash_parti_ver in (3, 4, 5, 6, 7):  # Known versions
                return 'bootloader'
    
    # Check filename for ABL even if not ELF (Pixel/Tensor, Samsung Exynos)
    # These devices use signed binary blobs instead of ELF
    filename = Path(file_path).stem.lower()
    if 'abl' in filename or filename in ['bl1', 'bl2', 'bl31']:
        return 'abl'
    
    # Check for NVRAM (MTK proprietary format) - return special type
    # NVRAM contains calibration data, IMEI keys, WiFi/BT MAC, etc.
    if 'nvram' in filename or 'nvdata' in filename or 'nvcfg' in filename or 'protect' in filename:
        return 'nvram'
    
    return 'raw'


class SparseImageConverter:
    """Convert Android sparse images to raw images."""
    
    CHUNK_TYPE_RAW = 0xCAC1
    CHUNK_TYPE_FILL = 0xCAC2
    CHUNK_TYPE_DONT_CARE = 0xCAC3
    CHUNK_TYPE_CRC32 = 0xCAC4
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
    
    def convert(self, input_path: str, output_path: str) -> None:
        """Convert sparse image to raw image."""
        with open(input_path, 'rb') as f_in:
            # Read sparse header
            header = self._read_header(f_in)
            
            logger.info(f"Sparse image: {header.total_blocks} blocks of {header.block_size} bytes")
            logger.info(f"Output size: {header.total_blocks * header.block_size / (1024*1024):.2f} MB")
            
            with open(output_path, 'wb') as f_out:
                for chunk_idx in range(header.total_chunks):
                    self._process_chunk(f_in, f_out, header)
                    
                    if self.progress_callback:
                        self.progress_callback(
                            chunk_idx + 1, 
                            header.total_chunks,
                            f"Converting chunk {chunk_idx + 1}/{header.total_chunks}"
                        )
    
    def _read_header(self, f: BinaryIO) -> SparseHeader:
        """Read and parse sparse image header."""
        data = f.read(28)
        if len(data) < 28:
            raise PayloadError("Invalid sparse image header")
        
        magic, major, minor, file_hdr_sz, chunk_hdr_sz, block_sz, total_blks, total_chunks, checksum = \
            struct.unpack('<IHHHHIIII', data)
        
        if magic != SPARSE_HEADER_MAGIC:
            raise PayloadError(f"Invalid sparse magic: {hex(magic)}")
        
        # Skip any extra header bytes
        if file_hdr_sz > 28:
            f.read(file_hdr_sz - 28)
        
        return SparseHeader(
            magic=magic,
            major_version=major,
            minor_version=minor,
            file_header_size=file_hdr_sz,
            chunk_header_size=chunk_hdr_sz,
            block_size=block_sz,
            total_blocks=total_blks,
            total_chunks=total_chunks,
            checksum=checksum
        )
    
    def _process_chunk(self, f_in: BinaryIO, f_out: BinaryIO, header: SparseHeader) -> None:
        """Process a single chunk from sparse image."""
        chunk_header = f_in.read(12)
        if len(chunk_header) < 12:
            raise PayloadError("Unexpected end of sparse image")
        
        chunk_type, reserved, chunk_sz, total_sz = struct.unpack('<HHII', chunk_header)
        
        # Skip any extra chunk header bytes
        if header.chunk_header_size > 12:
            f_in.read(header.chunk_header_size - 12)
        
        data_size = total_sz - header.chunk_header_size
        
        if chunk_type == self.CHUNK_TYPE_RAW:
            # Raw data - copy directly
            data = f_in.read(data_size)
            f_out.write(data)
        
        elif chunk_type == self.CHUNK_TYPE_FILL:
            # Fill with repeated 4-byte value
            fill_data = f_in.read(4)
            fill_count = chunk_sz * header.block_size // 4
            f_out.write(fill_data * fill_count)
        
        elif chunk_type == self.CHUNK_TYPE_DONT_CARE:
            # Skip (write zeros)
            f_out.write(b'\x00' * (chunk_sz * header.block_size))
        
        elif chunk_type == self.CHUNK_TYPE_CRC32:
            # CRC32 checksum - skip
            f_in.read(4)
        
        else:
            raise PayloadError(f"Unknown chunk type: {hex(chunk_type)}")


class BootImageExtractor:
    """Extract components from Android boot/recovery images.
    
    Supports:
    - boot.img (v0-v4)
    - recovery.img (same format as boot.img)
    - vendor_boot.img (v3-v4)
    
    Extracts: kernel, ramdisk, DTB, second bootloader, recovery_dtbo
    """
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
    
    def extract(self, input_path: str, output_dir: str) -> dict:
        """Extract kernel, ramdisk, and other components from boot image."""
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        
        with open(input_path, 'rb') as f:
            info = self._parse_header(f)
            extracted = {}
            
            # Extract kernel
            if info.kernel_size > 0:
                f.seek(info.kernel_offset)
                kernel_data = f.read(info.kernel_size)
                kernel_path = Path(output_dir) / 'kernel'
                kernel_path.write_bytes(kernel_data)
                extracted['kernel'] = str(kernel_path)
                logger.info(f"  Extracted kernel: {info.kernel_size} bytes")
                
                # Check if kernel is gzip compressed
                if kernel_data[:2] == b'\x1f\x8b':
                    extracted['kernel_compressed'] = 'gzip'
                elif kernel_data[:4] == b'\x28\xb5\x2f\xfd':
                    extracted['kernel_compressed'] = 'zstd'
                elif kernel_data[:2] == b'\x5d\x00':
                    extracted['kernel_compressed'] = 'lzma'
            
            # Extract ramdisk
            if info.ramdisk_size > 0:
                f.seek(info.ramdisk_offset)
                ramdisk_data = f.read(info.ramdisk_size)
                
                # Determine ramdisk format
                if ramdisk_data[:2] == b'\x1f\x8b':
                    ramdisk_ext = 'ramdisk.cpio.gz'
                elif ramdisk_data[:4] == b'\x28\xb5\x2f\xfd':
                    ramdisk_ext = 'ramdisk.cpio.zst'
                elif ramdisk_data[:6] == b'070701' or ramdisk_data[:6] == b'070702':
                    ramdisk_ext = 'ramdisk.cpio'
                elif ramdisk_data[:4] == b'\x5d\x00\x00\x00':
                    ramdisk_ext = 'ramdisk.cpio.lz4'
                else:
                    ramdisk_ext = 'ramdisk'
                
                ramdisk_path = Path(output_dir) / ramdisk_ext
                ramdisk_path.write_bytes(ramdisk_data)
                extracted['ramdisk'] = str(ramdisk_path)
                logger.info(f"  Extracted ramdisk: {info.ramdisk_size} bytes")
            
            # Extract second stage bootloader (if present)
            if info.second_size > 0:
                f.seek(info.second_offset)
                second_data = f.read(info.second_size)
                second_path = Path(output_dir) / 'second'
                second_path.write_bytes(second_data)
                extracted['second'] = str(second_path)
                logger.info(f"  Extracted second: {info.second_size} bytes")
            
            # Extract DTB (if present)
            if info.dtb_size > 0:
                f.seek(info.dtb_offset)
                dtb_data = f.read(info.dtb_size)
                dtb_path = Path(output_dir) / 'dtb'
                dtb_path.write_bytes(dtb_data)
                extracted['dtb'] = str(dtb_path)
                logger.info(f"  Extracted DTB: {info.dtb_size} bytes")
            
            # Save boot image info
            info_path = Path(output_dir) / 'boot_info.txt'
            with open(info_path, 'w') as f_info:
                f_info.write(f"Header Version: {info.header_version}\n")
                f_info.write(f"Page Size: {info.page_size}\n")
                f_info.write(f"OS Version: {info.os_version}\n")
                f_info.write(f"Kernel Size: {info.kernel_size}\n")
                f_info.write(f"Ramdisk Size: {info.ramdisk_size}\n")
                f_info.write(f"Second Size: {info.second_size}\n")
                f_info.write(f"DTB Size: {info.dtb_size}\n")
                f_info.write(f"Cmdline: {info.cmdline}\n")
                if info.extra_cmdline:
                    f_info.write(f"Extra Cmdline: {info.extra_cmdline}\n")
            extracted['info'] = str(info_path)
            
            return extracted
    
    def _parse_header(self, f: BinaryIO) -> BootImageInfo:
        """Parse boot image header (supports v0-v4 and vendor_boot v3/v4)."""
        magic = f.read(8)
        
        if magic == VENDOR_BOOT_MAGIC:
            # Parse vendor_boot image
            return self._parse_vendor_boot_header(f)
        
        if magic != BOOT_MAGIC:
            raise PayloadError(f"Invalid boot image magic: {magic!r}")
        
        # First, we need to determine the header version
        # In v0/v1/v2: header_version is at offset 40
        # In v3/v4: header_version is at offset 40 as well, but structure differs
        
        # Read first part common to detect version
        # Save position after magic
        f.seek(8)
        
        # Read kernel_size (4 bytes) - same position in all versions
        kernel_size = struct.unpack('<I', f.read(4))[0]
        
        # In v3/v4, the next field is ramdisk_size directly
        # In v0/v1/v2, next is kernel_addr
        # We can detect by reading ahead to get header_version
        
        # Save current position
        f.seek(8)
        
        # Try to read as v0/v1/v2 first to get header_version location
        # v0/v1/v2 header structure:
        # 0-7: magic, 8-11: kernel_size, 12-15: kernel_addr, 16-19: ramdisk_size, 20-23: ramdisk_addr
        # 24-27: second_size, 28-31: second_addr, 32-35: tags_addr, 36-39: page_size
        # 40-43: header_version (or dt_size for v0), 44-47: os_version
        
        # v3/v4 header structure:
        # 0-7: magic, 8-11: kernel_size, 12-15: ramdisk_size
        # 16-19: os_version, 20-23: header_size, 24-39: reserved[4]
        # 40-43: header_version, 44-47: cmdline_size (v4) or start of cmdline (v3)
        
        # Read enough to check header_version at offset 40
        f.seek(40)
        header_version = struct.unpack('<I', f.read(4))[0]
        
        # Validate - header_version should be 0-4 typically
        if header_version > 10:
            # Might be reading garbage, assume v0
            header_version = 0
        
        f.seek(8)  # Reset to after magic
        
        if header_version >= 3:
            # Parse v3/v4 header
            return self._parse_header_v3_v4(f, header_version)
        else:
            # Parse v0/v1/v2 header
            return self._parse_header_v0_v2(f, header_version)
    
    def _parse_header_v0_v2(self, f: BinaryIO, header_version: int) -> BootImageInfo:
        """Parse boot image header v0/v1/v2."""
        # f is positioned at offset 8 (after magic)
        kernel_size, kernel_addr, ramdisk_size, ramdisk_addr = struct.unpack('<IIII', f.read(16))
        second_size, second_addr, tags_addr, page_size = struct.unpack('<IIII', f.read(16))
        
        # Skip header_version (already known) and read os_version
        f.read(4)  # header_version
        os_version_raw = struct.unpack('<I', f.read(4))[0]
        
        # Parse OS version
        os_version = self._parse_os_version(os_version_raw)
        
        # Product name (16 bytes)
        f.read(16)
        
        # Command line (512 bytes)
        cmdline = f.read(512).rstrip(b'\x00').decode('utf-8', errors='ignore')
        
        # SHA1 hash (32 bytes)
        f.read(32)
        
        # Extra command line (1024 bytes)
        extra_cmdline = f.read(1024).rstrip(b'\x00').decode('utf-8', errors='ignore')
        
        # Validate page_size
        if page_size == 0 or page_size > 65536:
            page_size = 4096
        
        # Calculate offsets
        def align_page(size, page):
            if page == 0:
                return size
            return ((size + page - 1) // page) * page
        
        kernel_offset = page_size  # After header
        ramdisk_offset = kernel_offset + align_page(kernel_size, page_size)
        second_offset = ramdisk_offset + align_page(ramdisk_size, page_size)
        
        # DTB for header version 2
        dtb_size = 0
        dtb_offset = 0
        if header_version == 2:
            f.seek(1632)  # DTB size offset in v2 header
            dtb_data = f.read(8)
            if len(dtb_data) >= 8:
                dtb_size = struct.unpack('<I', dtb_data[:4])[0]
                dtb_offset = second_offset + align_page(second_size, page_size)
        
        return BootImageInfo(
            header_version=header_version,
            kernel_size=kernel_size,
            kernel_offset=kernel_offset,
            ramdisk_size=ramdisk_size,
            ramdisk_offset=ramdisk_offset,
            second_size=second_size,
            second_offset=second_offset,
            dtb_size=dtb_size,
            dtb_offset=dtb_offset,
            page_size=page_size,
            os_version=os_version,
            cmdline=cmdline,
            extra_cmdline=extra_cmdline
        )
    
    def _parse_header_v3_v4(self, f: BinaryIO, header_version: int) -> BootImageInfo:
        """Parse boot image header v3/v4."""
        # v3/v4 header structure (starting at offset 8, after magic):
        # 8-11: kernel_size
        # 12-15: ramdisk_size
        # 16-19: os_version
        # 20-23: header_size
        # 24-39: reserved[4] (16 bytes)
        # 40-43: header_version
        # 44-1579: cmdline (1536 bytes)
        
        kernel_size = struct.unpack('<I', f.read(4))[0]
        ramdisk_size = struct.unpack('<I', f.read(4))[0]
        os_version_raw = struct.unpack('<I', f.read(4))[0]
        header_size = struct.unpack('<I', f.read(4))[0]
        
        # Skip reserved (16 bytes) and header_version (4 bytes, already known)
        f.read(20)
        
        # Command line (1536 bytes for v3/v4)
        cmdline = f.read(1536).rstrip(b'\x00').decode('utf-8', errors='ignore')
        
        os_version = self._parse_os_version(os_version_raw)
        
        # v3/v4 always uses 4096 page size
        page_size = 4096
        
        # Calculate offsets - v3/v4 has simpler layout
        # Header is one page (4096 bytes)
        # Kernel follows immediately after header page
        # Ramdisk follows kernel (page aligned)
        
        def align_page(size, page=4096):
            return ((size + page - 1) // page) * page
        
        kernel_offset = page_size  # After 4096-byte header
        ramdisk_offset = kernel_offset + align_page(kernel_size)
        
        # v3/v4 don't have second stage or DTB in boot image
        # (DTB is in vendor_boot for v3+)
        
        return BootImageInfo(
            header_version=header_version,
            kernel_size=kernel_size,
            kernel_offset=kernel_offset,
            ramdisk_size=ramdisk_size,
            ramdisk_offset=ramdisk_offset,
            second_size=0,
            second_offset=0,
            dtb_size=0,
            dtb_offset=0,
            page_size=page_size,
            os_version=os_version,
            cmdline=cmdline,
            extra_cmdline=""
        )
    
    def _parse_os_version(self, os_version_raw: int) -> str:
        """Parse OS version from raw value."""
        if os_version_raw == 0:
            return "unknown"
        
        # OS version format:
        # bits 0-10: patch level year-month (YYYY*12 + MM - 2000*12)
        # bits 11-17: version C (patch)
        # bits 18-24: version B (minor)
        # bits 25-31: version A (major)
        
        patch_level = os_version_raw & 0x7ff
        version_c = (os_version_raw >> 11) & 0x7f
        version_b = (os_version_raw >> 18) & 0x7f
        version_a = (os_version_raw >> 25) & 0x7f
        
        if patch_level > 0:
            patch_year = 2000 + (patch_level // 12)
            patch_month = (patch_level % 12) or 12
            return f"{version_a}.{version_b}.{version_c} ({patch_year}-{patch_month:02d})"
        else:
            return f"{version_a}.{version_b}.{version_c}"
    
    def _parse_vendor_boot_header(self, f: BinaryIO) -> BootImageInfo:
        """Parse vendor_boot image header (v3/v4).
        
        Vendor boot image structure (after 8-byte magic):
        v3:
            8-11: header_version
            12-15: page_size
            16-19: kernel_addr
            20-23: ramdisk_addr  
            24-27: vendor_ramdisk_size
            28-2075: cmdline (2048 bytes)
            2076-2079: tags_addr
            2080-2095: name (16 bytes)
            2096-2099: header_size
            2100-2103: dtb_size
            2104-2111: dtb_addr
        v4 adds:
            vendor_ramdisk_table_size
            vendor_ramdisk_table_entry_num
            vendor_ramdisk_table_entry_size
            bootconfig_size
        """
        # f is positioned at offset 8 (after magic)
        header_version = struct.unpack('<I', f.read(4))[0]
        page_size = struct.unpack('<I', f.read(4))[0]
        kernel_addr = struct.unpack('<I', f.read(4))[0]
        ramdisk_addr = struct.unpack('<I', f.read(4))[0]
        vendor_ramdisk_size = struct.unpack('<I', f.read(4))[0]
        
        # Command line (2048 bytes)
        cmdline = f.read(2048).rstrip(b'\x00').decode('utf-8', errors='ignore')
        
        tags_addr = struct.unpack('<I', f.read(4))[0]
        
        # Product name (16 bytes)
        product_name = f.read(16).rstrip(b'\x00').decode('utf-8', errors='ignore')
        
        header_size = struct.unpack('<I', f.read(4))[0]
        dtb_size = struct.unpack('<I', f.read(4))[0]
        dtb_addr = struct.unpack('<Q', f.read(8))[0]
        
        # Validate page_size
        if page_size == 0 or page_size > 65536:
            page_size = 4096
        
        # Calculate offsets
        def align_page(size, page):
            if page == 0:
                return size
            return ((size + page - 1) // page) * page
        
        # Vendor boot layout:
        # [header pages] [vendor ramdisk pages] [dtb pages]
        header_pages = align_page(header_size, page_size)
        ramdisk_offset = header_pages
        dtb_offset = ramdisk_offset + align_page(vendor_ramdisk_size, page_size)
        
        # vendor_boot doesn't have a kernel - it's in boot.img
        # The "ramdisk" in vendor_boot is the vendor ramdisk
        return BootImageInfo(
            header_version=header_version,
            kernel_size=0,  # No kernel in vendor_boot
            kernel_offset=0,
            ramdisk_size=vendor_ramdisk_size,
            ramdisk_offset=ramdisk_offset,
            second_size=0,
            second_offset=0,
            dtb_size=dtb_size,
            dtb_offset=dtb_offset,
            page_size=page_size,
            os_version=f"vendor_boot v{header_version}",
            cmdline=cmdline,
            extra_cmdline=f"product: {product_name}" if product_name else ""
        )


class FatImageExtractor:
    """Extract files from FAT filesystem images (modem, firmware, etc.)."""
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
    
    def list_files(self, input_path: str) -> list[dict]:
        """List all files in a FAT image."""
        files = []
        
        with open(input_path, 'rb') as f:
            boot_sector = self._read_boot_sector(f)
            
            if boot_sector['fat_type'] == 'FAT32':
                self._list_fat32(f, boot_sector, '', files)
            else:
                self._list_fat16(f, boot_sector, '', files)
        
        return files
    
    def extract(self, input_path: str, output_dir: str, 
                file_list: Optional[list[str]] = None) -> dict:
        """Extract files from FAT image."""
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        extracted = {}
        
        with open(input_path, 'rb') as f:
            boot_sector = self._read_boot_sector(f)
            
            if boot_sector['fat_type'] == 'FAT32':
                self._extract_fat32(f, boot_sector, '', output_dir, file_list, extracted)
            else:
                self._extract_fat16(f, boot_sector, '', output_dir, file_list, extracted)
        
        return extracted
    
    def _read_boot_sector(self, f: BinaryIO) -> dict:
        """Read and parse FAT boot sector."""
        f.seek(0)
        data = f.read(512)
        
        bytes_per_sector = struct.unpack('<H', data[0x0B:0x0D])[0]
        sectors_per_cluster = data[0x0D]
        reserved_sectors = struct.unpack('<H', data[0x0E:0x10])[0]
        num_fats = data[0x10]
        root_entry_count = struct.unpack('<H', data[0x11:0x13])[0]
        total_sectors_16 = struct.unpack('<H', data[0x13:0x15])[0]
        fat_size_16 = struct.unpack('<H', data[0x16:0x18])[0]
        total_sectors_32 = struct.unpack('<I', data[0x20:0x24])[0]
        
        # Determine FAT type
        if fat_size_16 != 0:
            fat_size = fat_size_16
            root_cluster = 0
        else:
            fat_size = struct.unpack('<I', data[0x24:0x28])[0]
            root_cluster = struct.unpack('<I', data[0x2C:0x30])[0]
        
        total_sectors = total_sectors_16 if total_sectors_16 != 0 else total_sectors_32
        
        root_dir_sectors = ((root_entry_count * 32) + (bytes_per_sector - 1)) // bytes_per_sector
        first_data_sector = reserved_sectors + (num_fats * fat_size) + root_dir_sectors
        data_sectors = total_sectors - first_data_sector
        cluster_count = data_sectors // sectors_per_cluster if sectors_per_cluster > 0 else 0
        
        # Determine FAT type based on cluster count
        if cluster_count < 4085:
            fat_type = 'FAT12'
        elif cluster_count < 65525:
            fat_type = 'FAT16'
        else:
            fat_type = 'FAT32'
        
        return {
            'fat_type': fat_type,
            'bytes_per_sector': bytes_per_sector,
            'sectors_per_cluster': sectors_per_cluster,
            'reserved_sectors': reserved_sectors,
            'num_fats': num_fats,
            'root_entry_count': root_entry_count,
            'fat_size': fat_size,
            'root_cluster': root_cluster,
            'first_data_sector': first_data_sector,
            'root_dir_sector': reserved_sectors + (num_fats * fat_size),
            'cluster_size': bytes_per_sector * sectors_per_cluster,
        }
    
    def _cluster_to_offset(self, cluster: int, boot: dict) -> int:
        """Convert cluster number to byte offset."""
        return ((cluster - 2) * boot['sectors_per_cluster'] + boot['first_data_sector']) * boot['bytes_per_sector']
    
    def _read_cluster_chain(self, f: BinaryIO, boot: dict, start_cluster: int) -> bytes:
        """Read all data from a cluster chain."""
        data = bytearray()
        cluster = start_cluster
        visited = set()
        
        while cluster >= 2 and cluster not in visited:
            visited.add(cluster)
            
            # Read cluster data
            offset = self._cluster_to_offset(cluster, boot)
            f.seek(offset)
            data.extend(f.read(boot['cluster_size']))
            
            # Get next cluster from FAT
            cluster = self._get_next_cluster(f, boot, cluster)
            
            # Check for end of chain
            if boot['fat_type'] == 'FAT32':
                if cluster >= 0x0FFFFFF8:
                    break
            else:
                if cluster >= 0xFFF8:
                    break
        
        return bytes(data)
    
    def _get_next_cluster(self, f: BinaryIO, boot: dict, cluster: int) -> int:
        """Get next cluster number from FAT."""
        fat_offset = boot['reserved_sectors'] * boot['bytes_per_sector']
        
        if boot['fat_type'] == 'FAT32':
            f.seek(fat_offset + cluster * 4)
            return struct.unpack('<I', f.read(4))[0] & 0x0FFFFFFF
        elif boot['fat_type'] == 'FAT16':
            f.seek(fat_offset + cluster * 2)
            return struct.unpack('<H', f.read(2))[0]
        else:  # FAT12
            f.seek(fat_offset + (cluster * 3) // 2)
            data = f.read(2)
            val = struct.unpack('<H', data)[0]
            if cluster % 2 == 0:
                return val & 0xFFF
            else:
                return val >> 4
    
    def _parse_dir_entry(self, data: bytes) -> Optional[dict]:
        """Parse a 32-byte directory entry."""
        if len(data) < 32:
            return None
        
        first_byte = data[0]
        if first_byte == 0x00:  # End of directory
            return None
        if first_byte == 0xE5:  # Deleted entry
            return {'deleted': True}
        
        attr = data[0x0B]
        
        # Skip long filename entries
        if attr == 0x0F:
            return {'lfn': True}
        
        # Parse 8.3 filename
        name = data[0:8].rstrip(b' ').decode('ascii', errors='ignore')
        ext = data[8:11].rstrip(b' ').decode('ascii', errors='ignore')
        
        if ext:
            filename = f"{name}.{ext}"
        else:
            filename = name
        
        # Get cluster and size
        cluster_high = struct.unpack('<H', data[0x14:0x16])[0]
        cluster_low = struct.unpack('<H', data[0x1A:0x1C])[0]
        cluster = (cluster_high << 16) | cluster_low
        size = struct.unpack('<I', data[0x1C:0x20])[0]
        
        is_dir = bool(attr & 0x10)
        
        return {
            'name': filename,
            'cluster': cluster,
            'size': size,
            'is_dir': is_dir,
            'attr': attr,
        }
    
    def _list_fat16(self, f: BinaryIO, boot: dict, path: str, files: list):
        """List files in FAT12/FAT16 root directory."""
        root_offset = boot['root_dir_sector'] * boot['bytes_per_sector']
        f.seek(root_offset)
        
        for _ in range(boot['root_entry_count']):
            entry = self._parse_dir_entry(f.read(32))
            if entry is None:
                break
            if entry.get('deleted') or entry.get('lfn'):
                continue
            
            full_path = f"{path}/{entry['name']}" if path else entry['name']
            
            if entry['is_dir'] and entry['name'] not in ('.', '..'):
                self._list_dir_cluster(f, boot, entry['cluster'], full_path, files)
            elif not entry['is_dir']:
                files.append({'name': full_path, 'size': entry['size'], 'type': 'file'})
    
    def _list_fat32(self, f: BinaryIO, boot: dict, path: str, files: list):
        """List files in FAT32 starting from root cluster."""
        self._list_dir_cluster(f, boot, boot['root_cluster'], path, files)
    
    def _list_dir_cluster(self, f: BinaryIO, boot: dict, cluster: int, path: str, files: list):
        """List files in a directory cluster chain."""
        if cluster < 2:
            return
        
        dir_data = self._read_cluster_chain(f, boot, cluster)
        
        for i in range(0, len(dir_data), 32):
            entry = self._parse_dir_entry(dir_data[i:i+32])
            if entry is None:
                break
            if entry.get('deleted') or entry.get('lfn'):
                continue
            
            full_path = f"{path}/{entry['name']}" if path else entry['name']
            
            if entry['is_dir'] and entry['name'] not in ('.', '..'):
                self._list_dir_cluster(f, boot, entry['cluster'], full_path, files)
            elif not entry['is_dir']:
                files.append({'name': full_path, 'size': entry['size'], 'type': 'file'})
    
    def _extract_fat16(self, f: BinaryIO, boot: dict, path: str, output_dir: str,
                       file_list: Optional[list[str]], extracted: dict):
        """Extract files from FAT12/FAT16."""
        root_offset = boot['root_dir_sector'] * boot['bytes_per_sector']
        f.seek(root_offset)
        
        for _ in range(boot['root_entry_count']):
            entry = self._parse_dir_entry(f.read(32))
            if entry is None:
                break
            if entry.get('deleted') or entry.get('lfn'):
                continue
            
            full_path = f"{path}/{entry['name']}" if path else entry['name']
            
            if entry['is_dir'] and entry['name'] not in ('.', '..'):
                dir_path = Path(output_dir) / full_path
                dir_path.mkdir(parents=True, exist_ok=True)
                self._extract_dir_cluster(f, boot, entry['cluster'], full_path, output_dir, file_list, extracted)
            elif not entry['is_dir']:
                if file_list is None or full_path in file_list:
                    self._extract_file(f, boot, entry, full_path, output_dir, extracted)
    
    def _extract_fat32(self, f: BinaryIO, boot: dict, path: str, output_dir: str,
                       file_list: Optional[list[str]], extracted: dict):
        """Extract files from FAT32."""
        self._extract_dir_cluster(f, boot, boot['root_cluster'], path, output_dir, file_list, extracted)
    
    def _extract_dir_cluster(self, f: BinaryIO, boot: dict, cluster: int, path: str,
                             output_dir: str, file_list: Optional[list[str]], extracted: dict):
        """Extract files from a directory cluster chain."""
        if cluster < 2:
            return
        
        dir_data = self._read_cluster_chain(f, boot, cluster)
        
        for i in range(0, len(dir_data), 32):
            entry = self._parse_dir_entry(dir_data[i:i+32])
            if entry is None:
                break
            if entry.get('deleted') or entry.get('lfn'):
                continue
            
            full_path = f"{path}/{entry['name']}" if path else entry['name']
            
            if entry['is_dir'] and entry['name'] not in ('.', '..'):
                dir_path = Path(output_dir) / full_path
                dir_path.mkdir(parents=True, exist_ok=True)
                self._extract_dir_cluster(f, boot, entry['cluster'], full_path, output_dir, file_list, extracted)
            elif not entry['is_dir']:
                if file_list is None or full_path in file_list:
                    self._extract_file(f, boot, entry, full_path, output_dir, extracted)
    
    def _extract_file(self, f: BinaryIO, boot: dict, entry: dict, full_path: str,
                      output_dir: str, extracted: dict):
        """Extract a single file."""
        output_path = Path(output_dir) / full_path
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        if entry['cluster'] >= 2 and entry['size'] > 0:
            data = self._read_cluster_chain(f, boot, entry['cluster'])
            output_path.write_bytes(data[:entry['size']])
        else:
            output_path.write_bytes(b'')
        
        extracted[full_path] = str(output_path)
        logger.info(f"  Extracted: {full_path} ({entry['size']} bytes)")


class ElfImageExtractor:
    """Extract segments from ELF (Executable and Linkable Format) files.
    
    Common for Qualcomm modem firmware (modem.bin), bootloaders, and executables.
    Extracts program segments and provides detailed header information.
    """
    
    # ELF classes
    ELFCLASS32 = 1
    ELFCLASS64 = 2
    
    # ELF data encoding
    ELFDATA2LSB = 1  # Little endian
    ELFDATA2MSB = 2  # Big endian
    
    # ELF types
    ET_NONE = 0
    ET_REL = 1    # Relocatable
    ET_EXEC = 2   # Executable
    ET_DYN = 3    # Shared object
    ET_CORE = 4   # Core dump
    
    # Segment types
    PT_NULL = 0
    PT_LOAD = 1       # Loadable segment
    PT_DYNAMIC = 2    # Dynamic linking info
    PT_INTERP = 3     # Interpreter path
    PT_NOTE = 4       # Auxiliary information
    PT_SHLIB = 5      # Reserved
    PT_PHDR = 6       # Program header table
    PT_TLS = 7        # Thread-local storage
    
    # Qualcomm-specific segment types
    PT_QUALCOMM_HASH = 0x6FFFFFFD
    
    SEGMENT_NAMES = {
        0: "NULL",
        1: "LOAD",
        2: "DYNAMIC",
        3: "INTERP",
        4: "NOTE",
        5: "SHLIB",
        6: "PHDR",
        7: "TLS",
        0x6474e550: "GNU_EH_FRAME",
        0x6474e551: "GNU_STACK",
        0x6474e552: "GNU_RELRO",
        0x6FFFFFFD: "QC_HASH",
    }
    
    ELF_TYPES = {
        0: "NONE",
        1: "REL (Relocatable)",
        2: "EXEC (Executable)",
        3: "DYN (Shared object)",
        4: "CORE (Core dump)",
    }
    
    def __init__(self, input_path: str, output_dir: str, 
                 progress_callback: Optional[Callable[[int], None]] = None):
        self.input_path = Path(input_path)
        self.output_dir = Path(output_dir)
        self.progress_callback = progress_callback
        self.is_64bit = False
        self.is_little_endian = True
        self.header = {}
        self.segments = []
        
    def extract(self) -> bool:
        """Extract ELF segments to output directory."""
        try:
            with open(self.input_path, 'rb') as f:
                # Parse ELF header
                if not self._parse_elf_header(f):
                    return False
                
                # Parse program headers (segments)
                self._parse_program_headers(f)
                
                # Create output directory
                self.output_dir.mkdir(parents=True, exist_ok=True)
                
                # Write ELF info file
                self._write_info_file()
                
                # Extract loadable segments
                self._extract_segments(f)
                
            return True
        except Exception as e:
            logger.error(f"Failed to extract ELF file: {e}")
            return False
    
    def _parse_elf_header(self, f: BinaryIO) -> bool:
        """Parse the ELF header."""
        f.seek(0)
        e_ident = f.read(16)
        
        # Verify magic
        if e_ident[:4] != ELF_MAGIC:
            logger.error("Invalid ELF magic")
            return False
        
        # ELF class (32-bit or 64-bit)
        ei_class = e_ident[4]
        self.is_64bit = (ei_class == self.ELFCLASS64)
        
        # Data encoding (endianness)
        ei_data = e_ident[5]
        self.is_little_endian = (ei_data == self.ELFDATA2LSB)
        endian = '<' if self.is_little_endian else '>'
        
        # ELF version
        ei_version = e_ident[6]
        
        self.header['class'] = '64-bit' if self.is_64bit else '32-bit'
        self.header['endian'] = 'Little endian' if self.is_little_endian else 'Big endian'
        self.header['version'] = ei_version
        
        # Read rest of header based on class
        if self.is_64bit:
            header_fmt = f'{endian}HHIQQQIHHHHHH'
            header_size = 64
        else:
            header_fmt = f'{endian}HHIIIIIHHHHHH'
            header_size = 52
        
        f.seek(16)
        header_data = f.read(header_size - 16)
        fields = struct.unpack(header_fmt, header_data)
        
        self.header['type'] = fields[0]
        self.header['type_name'] = self.ELF_TYPES.get(fields[0], f"Unknown ({fields[0]})")
        self.header['machine'] = fields[1]
        self.header['version2'] = fields[2]
        self.header['entry'] = fields[3]
        self.header['phoff'] = fields[4]  # Program header offset
        self.header['shoff'] = fields[5]  # Section header offset
        self.header['flags'] = fields[6]
        self.header['ehsize'] = fields[7]
        self.header['phentsize'] = fields[8]  # Program header entry size
        self.header['phnum'] = fields[9]      # Number of program headers
        self.header['shentsize'] = fields[10]
        self.header['shnum'] = fields[11]
        self.header['shstrndx'] = fields[12]
        
        # Common machine types
        machine_names = {
            0: "None",
            3: "Intel 386",
            8: "MIPS",
            40: "ARM",
            62: "x86-64",
            164: "Qualcomm Hexagon",
            183: "AArch64",
        }
        self.header['machine_name'] = machine_names.get(fields[1], f"Unknown ({fields[1]})")
        
        logger.info(f"ELF Header: {self.header['class']}, {self.header['endian']}, "
                   f"{self.header['type_name']}, {self.header['machine_name']}")
        
        return True
    
    def _parse_program_headers(self, f: BinaryIO):
        """Parse program headers (segments)."""
        endian = '<' if self.is_little_endian else '>'
        
        if self.is_64bit:
            ph_fmt = f'{endian}IIQQQQQQ'
            ph_size = 56
        else:
            ph_fmt = f'{endian}IIIIIIII'
            ph_size = 32
        
        f.seek(self.header['phoff'])
        
        for i in range(self.header['phnum']):
            ph_data = f.read(ph_size)
            if len(ph_data) < ph_size:
                break
            
            fields = struct.unpack(ph_fmt, ph_data)
            
            if self.is_64bit:
                segment = {
                    'type': fields[0],
                    'flags': fields[1],
                    'offset': fields[2],
                    'vaddr': fields[3],
                    'paddr': fields[4],
                    'filesz': fields[5],
                    'memsz': fields[6],
                    'align': fields[7],
                }
            else:
                segment = {
                    'type': fields[0],
                    'offset': fields[1],
                    'vaddr': fields[2],
                    'paddr': fields[3],
                    'filesz': fields[4],
                    'memsz': fields[5],
                    'flags': fields[6],
                    'align': fields[7],
                }
            
            segment['type_name'] = self.SEGMENT_NAMES.get(segment['type'], f"0x{segment['type']:08X}")
            segment['index'] = i
            self.segments.append(segment)
        
        logger.info(f"Found {len(self.segments)} program segments")
    
    def _write_info_file(self):
        """Write ELF information to a text file."""
        info_path = self.output_dir / "elf_info.txt"
        with open(info_path, 'w') as f:
            f.write("ELF File Information\n")
            f.write("=" * 60 + "\n\n")
            
            f.write("Header:\n")
            f.write(f"  Class:        {self.header['class']}\n")
            f.write(f"  Endian:       {self.header['endian']}\n")
            f.write(f"  Type:         {self.header['type_name']}\n")
            f.write(f"  Machine:      {self.header['machine_name']}\n")
            f.write(f"  Entry point:  0x{self.header['entry']:X}\n")
            f.write(f"  Flags:        0x{self.header['flags']:X}\n")
            f.write("\n")
            
            f.write("Program Segments:\n")
            f.write("-" * 60 + "\n")
            
            for seg in self.segments:
                f.write(f"\nSegment {seg['index']}: {seg['type_name']}\n")
                f.write(f"  Offset:       0x{seg['offset']:X}\n")
                f.write(f"  Virtual addr: 0x{seg['vaddr']:X}\n")
                f.write(f"  Physical addr:0x{seg['paddr']:X}\n")
                f.write(f"  File size:    {seg['filesz']} bytes\n")
                f.write(f"  Memory size:  {seg['memsz']} bytes\n")
                
                # Decode flags
                flags = []
                if seg['flags'] & 0x1:
                    flags.append('X (Execute)')
                if seg['flags'] & 0x2:
                    flags.append('W (Write)')
                if seg['flags'] & 0x4:
                    flags.append('R (Read)')
                f.write(f"  Flags:        {', '.join(flags) if flags else 'None'}\n")
        
        logger.info(f"Wrote ELF info to: {info_path}")
    
    def _extract_segments(self, f: BinaryIO):
        """Extract loadable segments to files."""
        total_segments = len([s for s in self.segments if s['filesz'] > 0])
        extracted = 0
        
        for seg in self.segments:
            if seg['filesz'] == 0:
                continue
            
            # Create descriptive filename
            type_name = seg['type_name'].replace(' ', '_').replace('/', '_')
            filename = f"segment_{seg['index']:02d}_{type_name}_0x{seg['paddr']:08X}.bin"
            
            output_path = self.output_dir / filename
            
            # Read and write segment data
            f.seek(seg['offset'])
            data = f.read(seg['filesz'])
            
            with open(output_path, 'wb') as out:
                out.write(data)
            
            extracted += 1
            logger.info(f"  Extracted: {filename} ({seg['filesz']} bytes)")
            
            if self.progress_callback:
                progress = int(extracted * 100 / total_segments) if total_segments > 0 else 100
                self.progress_callback(progress)
        
        logger.info(f"Extracted {extracted} segments from ELF file")


class AblAnalyzer:
    """Analyze and patch Android Bootloader (ABL) images.
    
    ABL (abl.img) is critical for device boot, especially on:
    - LG devices (LAF mode, unlock verification, device checks)
    - Qualcomm devices (fastboot, AVB verification, anti-rollback)
    
    This class provides:
    - Deep analysis of ABL structure and embedded strings
    - Detection of unlock status checks
    - Detection of anti-rollback fuses
    - LG-specific LAF mode detection
    - Optional patching capabilities (DANGEROUS - can brick device!)
    
    EDUCATIONAL NOTES:
    ==================
    ABL is an ELF binary that runs on the Application Processor (AP).
    It's responsible for:
    1. Initializing hardware after XBL (eXtensible Bootloader)
    2. Implementing fastboot protocol
    3. Verifying boot/recovery images (AVB)
    4. Checking bootloader unlock status
    5. Loading and booting the kernel
    
    On LG devices, ABL also handles:
    - LAF (Download) mode entry
    - Device unlock token verification
    - IMEI/device binding checks
    
    Common ABL strings to look for:
    - "device is UNLOCKED" / "device is LOCKED"
    - "Orange State" / "Red State" / "Green State"
    - "Press VOLUME UP to continue"
    - "Start fastboot mode"
    - "SECURE BOOT"
    - "anti-rollback"
    
    WARNING: Patching ABL incorrectly WILL brick your device!
    Always have a backup and understand what you're doing.
    """
    
    # Known ABL string patterns for various checks
    UNLOCK_PATTERNS = [
        b'device is UNLOCKED',
        b'device is LOCKED',
        b'DEVICE_UNLOCKED',
        b'DEVICE_LOCKED',
        b'unlock_status',
        b'is_unlocked',
        b'get_unlock_state',
        b'verify_unlock',
        b'oem_unlock',
        b'UNLOCK=',
        b'LOCK=',
        b'unlock_ability',
        b'unlockable',
        b'unlock_allowed',
    ]
    
    SECURE_BOOT_PATTERNS = [
        b'SECURE BOOT',
        b'secure boot',
        b'secureboot',
        b'is_secure_boot',
        b'secure_boot_enabled',
        b'verify_secure_boot',
        b'verified boot',
        b'VERIFIED BOOT',
    ]
    
    AVB_PATTERNS = [
        b'avb_',
        b'AVB_',
        b'vbmeta',
        b'dm-verity',
        b'verify_vbmeta',
        b'avb_verify',
        b'verify_boot',
        b'android_verify_boot',
        b'AVB0',
        b'AvbFooter',
        b'AvbVBMeta',
    ]
    
    ANTI_ROLLBACK_PATTERNS = [
        b'anti-rollback',
        b'anti_rollback',
        b'rollback_index',
        b'ROLLBACK',
        b'fuse_read',
        b'fuse_write',
        b'qfprom',
        b'QFPROM',
        b'otp_read',
        b'efuse',
        b'EFUSE',
    ]
    
    # Google Pixel / Tensor specific patterns
    PIXEL_PATTERNS = [
        b'Pixel',
        b'pixel',
        b'GOOGLE',
        b'google',
        b'Tensor',
        b'tensor',
        b'gs101',  # Tensor G1
        b'gs201',  # Tensor G2
        b'gs301',  # Tensor G3
        b'zuma',   # Tensor G3 codename
        b'slider', # Pixel 6 codename
        b'cloudripper',  # Pixel 6 Pro codename
        b'oriole',  # Pixel 6 codename
        b'raven',   # Pixel 6 Pro codename
        b'bluejay', # Pixel 6a codename
        b'panther', # Pixel 7 codename
        b'cheetah', # Pixel 7 Pro codename
        b'lynx',    # Pixel 7a codename
        b'tangorpro', # Pixel Tablet codename
        b'felix',   # Pixel Fold codename
        b'shiba',   # Pixel 8 codename
        b'husky',   # Pixel 8 Pro codename
        b'akita',   # Pixel 8a codename
        b'tokay',   # Pixel 9 codename
        b'caiman',  # Pixel 9 Pro codename
        b'komodo',  # Pixel 9 Pro XL codename
        b'comet',   # Pixel 9 Pro Fold codename
        b'trusty',
        b'BL31',
        b'BL2',
    ]
    
    LG_PATTERNS = [
        b'LAF',
        b'laf_mode',
        b'download_mode',
        b'LG_UNLOCK',
        b'lg_unlock',
        b'device_unlock_token',
        b'LGUP',
        b'kdz',
        b'KDZ',
    ]
    
    FASTBOOT_PATTERNS = [
        b'fastboot',
        b'FASTBOOT',
        b'getvar:',
        b'oem ',
        b'flash:',
        b'boot:',
        b'reboot',
        b'continue',
        b'flashing unlock',
        b'flashing lock',
    ]
    
    WARNING_PATTERNS = [
        b'Orange State',
        b'Red State',
        b'Yellow State',
        b'green state',
        b'warranty void',
        b'WARRANTY VOID',
        b'tampered',
        b'TAMPERED',
        b'PRESS VOLUME',
        b'Press Volume',
    ]
    
    def __init__(self, input_path: str, output_dir: str = None,
                 progress_callback: Optional[Callable[[int], None]] = None):
        self.input_path = Path(input_path)
        self.output_dir = Path(output_dir) if output_dir else self.input_path.parent / 'abl_analysis'
        self.progress_callback = progress_callback
        self.data = None
        self.analysis = {}
        
    def analyze(self) -> dict:
        """Perform comprehensive ABL analysis."""
        logger.info(f"Analyzing ABL: {self.input_path.name}")
        
        with open(self.input_path, 'rb') as f:
            self.data = f.read()
        
        # Detect format
        is_elf = self.data[:4] == ELF_MAGIC
        is_signed_blob = False
        format_type = 'Unknown'
        
        if is_elf:
            format_type = 'ELF (Qualcomm)'
            is_64bit = len(self.data) > 4 and self.data[4] == 2
        else:
            # Check for common Pixel/Tensor/Exynos signatures
            # These are typically ARM Trusted Firmware (ATF) or signed blobs
            is_64bit = False  # Can't easily determine from blob
            
            # Check for certificate/signature headers (common in signed bootloaders)
            if self.data[:2] == b'\x30\x82':  # ASN.1 DER sequence (certificate)
                format_type = 'Signed Binary (Certificate Header)'
                is_signed_blob = True
            elif b'CERT' in self.data[:256] or b'RSA' in self.data[:256]:
                format_type = 'Signed Binary'
                is_signed_blob = True
            elif self.data[:4] == b'\x00\x00\xa0\xe1':  # ARM NOP instruction
                format_type = 'ARM Binary (Raw)'
            elif self.data[:4] == b'\xd5\x03\x20\x1f':  # AArch64 NOP
                format_type = 'AArch64 Binary (Raw)'
                is_64bit = True
            else:
                format_type = 'Binary Blob (Pixel/Tensor/Exynos format)'
        
        self.analysis = {
            'file': str(self.input_path),
            'size': len(self.data),
            'is_elf': is_elf,
            'is_64bit': is_64bit,
            'format': format_type,
            'is_signed_blob': is_signed_blob,
            'unlock_checks': [],
            'secure_boot': [],
            'avb_references': [],
            'anti_rollback': [],
            'lg_specific': [],
            'pixel_specific': [],
            'fastboot_commands': [],
            'warning_messages': [],
            'interesting_strings': [],
            'potential_patches': [],
        }
        
        if self.progress_callback:
            self.progress_callback(10)
        
        # Search for patterns
        self._find_patterns('unlock_checks', self.UNLOCK_PATTERNS)
        if self.progress_callback:
            self.progress_callback(20)
            
        self._find_patterns('secure_boot', self.SECURE_BOOT_PATTERNS)
        self._find_patterns('avb_references', self.AVB_PATTERNS)
        if self.progress_callback:
            self.progress_callback(35)
            
        self._find_patterns('anti_rollback', self.ANTI_ROLLBACK_PATTERNS)
        self._find_patterns('lg_specific', self.LG_PATTERNS)
        self._find_patterns('pixel_specific', self.PIXEL_PATTERNS)
        if self.progress_callback:
            self.progress_callback(50)
            
        self._find_patterns('fastboot_commands', self.FASTBOOT_PATTERNS)
        self._find_patterns('warning_messages', self.WARNING_PATTERNS)
        if self.progress_callback:
            self.progress_callback(65)
        
        # Find all printable strings (useful for further analysis)
        self._extract_interesting_strings()
        if self.progress_callback:
            self.progress_callback(80)
        
        # Identify potential patch points
        self._identify_patch_points()
        if self.progress_callback:
            self.progress_callback(100)
        
        return self.analysis
    
    def _find_patterns(self, category: str, patterns: list):
        """Search for byte patterns in the data."""
        for pattern in patterns:
            offset = 0
            while True:
                pos = self.data.find(pattern, offset)
                if pos == -1:
                    break
                
                # Get surrounding context
                context_start = max(0, pos - 20)
                context_end = min(len(self.data), pos + len(pattern) + 20)
                context = self.data[context_start:context_end]
                
                # Clean up context for display
                try:
                    context_str = context.decode('utf-8', errors='replace')
                    context_str = ''.join(c if c.isprintable() or c in '\n\r\t' else '.' for c in context_str)
                except:
                    context_str = repr(context)
                
                self.analysis[category].append({
                    'pattern': pattern.decode('utf-8', errors='replace'),
                    'offset': pos,
                    'hex_offset': f'0x{pos:08X}',
                    'context': context_str.strip(),
                })
                
                offset = pos + 1
    
    def _extract_interesting_strings(self):
        """Extract printable strings from ABL (like 'strings' command)."""
        min_length = 6
        strings = []
        current = b''
        start_offset = 0
        
        for i, byte in enumerate(self.data):
            if 32 <= byte <= 126:  # Printable ASCII
                if not current:
                    start_offset = i
                current += bytes([byte])
            else:
                if len(current) >= min_length:
                    try:
                        s = current.decode('ascii')
                        # Filter for interesting strings
                        if any(keyword in s.lower() for keyword in 
                               ['boot', 'unlock', 'lock', 'verify', 'secure', 'fuse', 
                                'avb', 'rollback', 'fastboot', 'oem', 'flash', 'error',
                                'failed', 'success', 'invalid', 'tamper', 'lg', 'laf']):
                            strings.append({
                                'string': s,
                                'offset': start_offset,
                                'hex_offset': f'0x{start_offset:08X}',
                            })
                    except:
                        pass
                current = b''
        
        # Deduplicate and limit
        seen = set()
        unique_strings = []
        for s in strings:
            if s['string'] not in seen:
                seen.add(s['string'])
                unique_strings.append(s)
        
        self.analysis['interesting_strings'] = unique_strings[:200]  # Limit to 200
    
    def _identify_patch_points(self):
        """Identify potential patch points (for educational purposes)."""
        patches = []
        
        # Common unlock bypass patterns
        # These are for EDUCATIONAL/RESEARCH purposes only
        
        # Pattern: Function returning lock status (return 0 vs return 1)
        # Often: mov w0, #1 (locked) can be changed to mov w0, #0 (unlocked)
        # ARM64: 20 00 80 52 (mov w0, #1) -> 00 00 80 52 (mov w0, #0)
        
        if self.analysis['is_64bit']:
            # ARM64 patterns
            mov_w0_1 = b'\x20\x00\x80\x52'  # mov w0, #1
            mov_w0_0 = b'\x00\x00\x80\x52'  # mov w0, #0
            
            for match in self.analysis['unlock_checks']:
                offset = match['offset']
                # Search nearby for the return instruction
                search_start = max(0, offset - 100)
                search_end = min(len(self.data), offset + 100)
                nearby = self.data[search_start:search_end]
                
                pos = nearby.find(mov_w0_1)
                if pos != -1:
                    patches.append({
                        'type': 'unlock_bypass_candidate',
                        'description': f"Potential unlock check near '{match['pattern']}'",
                        'offset': search_start + pos,
                        'hex_offset': f'0x{search_start + pos:08X}',
                        'original': mov_w0_1.hex(),
                        'patched': mov_w0_0.hex(),
                        'warning': 'DANGEROUS: Incorrect patching will brick device!',
                    })
        
        # Look for conditional branches after security checks
        for match in self.analysis['secure_boot']:
            patches.append({
                'type': 'secure_boot_check',
                'description': f"Secure boot check at '{match['pattern']}'",
                'offset': match['offset'],
                'hex_offset': match['hex_offset'],
                'warning': 'Research only - modifying secure boot checks is extremely risky',
            })
        
        self.analysis['potential_patches'] = patches
    
    def write_report(self) -> str:
        """Write detailed analysis report to file."""
        self.output_dir.mkdir(parents=True, exist_ok=True)
        report_path = self.output_dir / 'abl_analysis_report.txt'
        
        with open(report_path, 'w') as f:
            f.write("=" * 70 + "\n")
            f.write("ABL (Android Bootloader) Analysis Report\n")
            f.write("Generated by Image Anarchy\n")
            f.write("=" * 70 + "\n\n")
            
            f.write(f"File: {self.analysis['file']}\n")
            f.write(f"Size: {self.analysis['size']} bytes ({self.analysis['size'] / 1024:.2f} KB)\n")
            f.write(f"Format: {self.analysis.get('format', 'Unknown')}\n")
            if self.analysis.get('is_elf'):
                f.write(f"ELF Class: {'64-bit' if self.analysis['is_64bit'] else '32-bit'}\n")
            f.write("\n")
            
            # Device detection
            if self.is_pixel_device():
                f.write("📱 GOOGLE PIXEL / TENSOR DEVICE DETECTED\n")
                f.write("-" * 70 + "\n")
                f.write("This ABL is from a Google Pixel device with Tensor chip.\n")
                f.write("Pixel ABL uses signed binary format (not ELF like Qualcomm).\n")
                f.write("Pattern matches: " + ", ".join(set(
                    m['pattern'] for m in self.analysis['pixel_specific'][:10]
                )) + "\n")
                f.write("\n")
            
            if self.is_lg_device():
                f.write("⚡ LG DEVICE DETECTED\n")
                f.write("-" * 70 + "\n")
                f.write("This ABL is from an LG device with LAF mode support.\n\n")
            
            # Unlock checks
            f.write("-" * 70 + "\n")
            f.write("UNLOCK STATUS CHECKS\n")
            f.write("-" * 70 + "\n")
            if self.analysis['unlock_checks']:
                for item in self.analysis['unlock_checks']:
                    f.write(f"\n  Pattern: {item['pattern']}\n")
                    f.write(f"  Offset:  {item['hex_offset']}\n")
                    f.write(f"  Context: {item['context']}\n")
            else:
                f.write("  None found\n")
            f.write("\n")
            
            # Secure boot
            f.write("-" * 70 + "\n")
            f.write("SECURE BOOT REFERENCES\n")
            f.write("-" * 70 + "\n")
            if self.analysis['secure_boot']:
                for item in self.analysis['secure_boot']:
                    f.write(f"\n  Pattern: {item['pattern']}\n")
                    f.write(f"  Offset:  {item['hex_offset']}\n")
            else:
                f.write("  None found\n")
            f.write("\n")
            
            # AVB references
            f.write("-" * 70 + "\n")
            f.write("AVB (Android Verified Boot) REFERENCES\n")
            f.write("-" * 70 + "\n")
            if self.analysis['avb_references']:
                for item in self.analysis['avb_references'][:20]:  # Limit output
                    f.write(f"\n  Pattern: {item['pattern']}\n")
                    f.write(f"  Offset:  {item['hex_offset']}\n")
                f.write(f"\n  Total: {len(self.analysis['avb_references'])} references\n")
            else:
                f.write("  None found\n")
            f.write("\n")
            
            # Anti-rollback
            f.write("-" * 70 + "\n")
            f.write("ANTI-ROLLBACK REFERENCES\n")
            f.write("-" * 70 + "\n")
            if self.analysis['anti_rollback']:
                for item in self.analysis['anti_rollback']:
                    f.write(f"\n  Pattern: {item['pattern']}\n")
                    f.write(f"  Offset:  {item['hex_offset']}\n")
            else:
                f.write("  None found\n")
            f.write("\n")
            
            # LG specific
            f.write("-" * 70 + "\n")
            f.write("LG DEVICE SPECIFIC\n")
            f.write("-" * 70 + "\n")
            if self.analysis['lg_specific']:
                for item in self.analysis['lg_specific']:
                    f.write(f"\n  Pattern: {item['pattern']}\n")
                    f.write(f"  Offset:  {item['hex_offset']}\n")
                    f.write(f"  Context: {item['context']}\n")
            else:
                f.write("  None found (not an LG device or no LG-specific code)\n")
            f.write("\n")
            
            # Fastboot commands
            f.write("-" * 70 + "\n")
            f.write("FASTBOOT COMMANDS\n")
            f.write("-" * 70 + "\n")
            if self.analysis['fastboot_commands']:
                for item in self.analysis['fastboot_commands'][:30]:
                    f.write(f"  {item['hex_offset']}: {item['pattern']}\n")
            else:
                f.write("  None found\n")
            f.write("\n")
            
            # Warning messages
            f.write("-" * 70 + "\n")
            f.write("WARNING/STATE MESSAGES\n")
            f.write("-" * 70 + "\n")
            if self.analysis['warning_messages']:
                for item in self.analysis['warning_messages']:
                    f.write(f"\n  Pattern: {item['pattern']}\n")
                    f.write(f"  Offset:  {item['hex_offset']}\n")
                    f.write(f"  Context: {item['context']}\n")
            else:
                f.write("  None found\n")
            f.write("\n")
            
            # Potential patches (educational)
            if self.analysis['potential_patches']:
                f.write("-" * 70 + "\n")
                f.write("POTENTIAL PATCH POINTS (EDUCATIONAL/RESEARCH ONLY)\n")
                f.write("-" * 70 + "\n")
                f.write("\n⚠️  WARNING: DO NOT ATTEMPT PATCHING UNLESS YOU FULLY UNDERSTAND\n")
                f.write("    THE RISKS. INCORRECT PATCHES WILL PERMANENTLY BRICK YOUR DEVICE!\n\n")
                
                for patch in self.analysis['potential_patches']:
                    f.write(f"\n  Type: {patch['type']}\n")
                    f.write(f"  Description: {patch['description']}\n")
                    f.write(f"  Offset: {patch['hex_offset']}\n")
                    if 'original' in patch:
                        f.write(f"  Original bytes: {patch['original']}\n")
                        f.write(f"  Patched bytes:  {patch['patched']}\n")
                    f.write(f"  ⚠️  {patch['warning']}\n")
            
            # Interesting strings
            f.write("\n" + "-" * 70 + "\n")
            f.write("INTERESTING STRINGS (first 100)\n")
            f.write("-" * 70 + "\n")
            for item in self.analysis['interesting_strings'][:100]:
                f.write(f"  {item['hex_offset']}: {item['string']}\n")
        
        logger.info(f"Wrote ABL analysis report to: {report_path}")
        return str(report_path)
    
    def is_lg_device(self) -> bool:
        """Check if this ABL is from an LG device."""
        return len(self.analysis.get('lg_specific', [])) > 0
    
    def is_pixel_device(self) -> bool:
        """Check if this ABL is from a Google Pixel device."""
        return len(self.analysis.get('pixel_specific', [])) > 0
    
    def get_summary(self) -> str:
        """Get a brief summary of the analysis."""
        summary = []
        summary.append(f"ABL Analysis: {self.input_path.name}")
        summary.append(f"  Format: {self.analysis.get('format', 'Unknown')}")
        summary.append(f"  Size: {self.analysis['size'] / 1024:.2f} KB")
        summary.append(f"  Unlock checks found: {len(self.analysis['unlock_checks'])}")
        summary.append(f"  Secure boot refs: {len(self.analysis['secure_boot'])}")
        summary.append(f"  AVB references: {len(self.analysis['avb_references'])}")
        summary.append(f"  Anti-rollback refs: {len(self.analysis['anti_rollback'])}")
        summary.append(f"  Fastboot commands: {len(self.analysis['fastboot_commands'])}")
        
        if self.is_lg_device():
            summary.append(f"  LG-specific: {len(self.analysis['lg_specific'])}")
            summary.append("\n  ⚡ LG device detected - LAF mode references found")
        
        if self.is_pixel_device():
            summary.append(f"  Pixel-specific: {len(self.analysis['pixel_specific'])}")
            summary.append("\n  📱 Google Pixel/Tensor device detected")
        
        if not self.analysis.get('is_elf'):
            summary.append("\n  ℹ️  Non-ELF format (Pixel/Tensor/Exynos signed binary)")
        
        return '\n'.join(summary)


class DtboExtractor:
    """Extract and parse Android DTBO (Device Tree Blob Overlay) images.
    
    DTBO images contain device tree overlays that are applied on top of the
    base device tree (DTB). They allow OEMs to customize hardware descriptions
    without modifying the main DTB.
    
    DTBO Image Format:
    - Header (32 bytes):
      - magic (4 bytes): 0xD7B7AB1E (big endian)
      - total_size (4 bytes): Total file size
      - header_size (4 bytes): Size of header
      - dt_entry_size (4 bytes): Size of each entry
      - dt_entry_count (4 bytes): Number of DT entries
      - dt_entries_offset (4 bytes): Offset to entries
      - page_size (4 bytes): Page size (typically 4096)
      - version (4 bytes): DTBO version
    - DT Entries (32 bytes each):
      - dt_size (4 bytes): Size of this overlay
      - dt_offset (4 bytes): Offset to overlay data
      - id (4 bytes): Identifier
      - rev (4 bytes): Revision
      - custom[4] (16 bytes): Custom data
    - DT Overlay Data: FDT (Flattened Device Tree) blobs
    """
    
    DTBO_MAGIC = 0xD7B7AB1E
    HEADER_SIZE = 32
    ENTRY_SIZE = 32
    FDT_MAGIC = 0xD00DFEED  # Device Tree magic
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
        self.header = {}
        self.entries = []
    
    def analyze(self, file_path: str) -> Dict[str, Any]:
        """Analyze DTBO image and return metadata."""
        result = {
            'format': 'dtbo',
            'valid': False,
            'version': 0,
            'entry_count': 0,
            'page_size': 0,
            'total_size': 0,
            'entries': []
        }
        
        try:
            with open(file_path, 'rb') as f:
                # Read header (32 bytes, all big endian)
                header_data = f.read(32)
                if len(header_data) < 32:
                    return result
                
                magic = struct.unpack('>I', header_data[0:4])[0]
                if magic != self.DTBO_MAGIC:
                    return result
                
                total_size = struct.unpack('>I', header_data[4:8])[0]
                header_size = struct.unpack('>I', header_data[8:12])[0]
                dt_entry_size = struct.unpack('>I', header_data[12:16])[0]
                dt_entry_count = struct.unpack('>I', header_data[16:20])[0]
                dt_entries_offset = struct.unpack('>I', header_data[20:24])[0]
                page_size = struct.unpack('>I', header_data[24:28])[0]
                version = struct.unpack('>I', header_data[28:32])[0]
                
                self.header = {
                    'magic': magic,
                    'total_size': total_size,
                    'header_size': header_size,
                    'dt_entry_size': dt_entry_size,
                    'dt_entry_count': dt_entry_count,
                    'dt_entries_offset': dt_entries_offset,
                    'page_size': page_size,
                    'version': version
                }
                
                result['valid'] = True
                result['version'] = version
                result['entry_count'] = dt_entry_count
                result['page_size'] = page_size
                result['total_size'] = total_size
                result['header_size'] = header_size
                
                # Read entries
                f.seek(dt_entries_offset)
                entries = []
                for i in range(dt_entry_count):
                    entry_data = f.read(dt_entry_size)
                    if len(entry_data) < 32:
                        break
                    
                    dt_size = struct.unpack('>I', entry_data[0:4])[0]
                    dt_offset = struct.unpack('>I', entry_data[4:8])[0]
                    dt_id = struct.unpack('>I', entry_data[8:12])[0]
                    dt_rev = struct.unpack('>I', entry_data[12:16])[0]
                    custom = entry_data[16:32]
                    
                    # Try to identify overlay type from the FDT
                    overlay_info = self._get_overlay_info(f, dt_offset, dt_size)
                    
                    entry = {
                        'index': i,
                        'size': dt_size,
                        'offset': dt_offset,
                        'id': dt_id,
                        'rev': dt_rev,
                        'custom': custom.hex(),
                        'info': overlay_info
                    }
                    entries.append(entry)
                
                self.entries = entries
                result['entries'] = entries
                
        except Exception as e:
            logger.error(f"Error analyzing DTBO: {e}")
        
        return result
    
    def _get_overlay_info(self, f, offset: int, size: int) -> str:
        """Try to extract overlay identification from FDT."""
        try:
            current_pos = f.tell()
            f.seek(offset)
            fdt_data = f.read(min(size, 256))  # Read first 256 bytes
            f.seek(current_pos)
            
            # Check FDT magic
            if len(fdt_data) >= 4:
                fdt_magic = struct.unpack('>I', fdt_data[0:4])[0]
                if fdt_magic == self.FDT_MAGIC:
                    # Try to find compatible string
                    try:
                        # Search for 'compatible' property (rough search)
                        compat_idx = fdt_data.find(b'compatible')
                        if compat_idx > 0 and compat_idx < len(fdt_data) - 20:
                            # Extract string after 'compatible'
                            str_start = compat_idx + 11
                            str_end = fdt_data.find(b'\x00', str_start)
                            if str_end > str_start:
                                return fdt_data[str_start:str_end].decode('utf-8', errors='ignore')
                    except:
                        pass
                    return "Valid FDT overlay"
            return "Unknown"
        except:
            return "Unknown"
    
    def extract(self, file_path: str, output_dir: str) -> List[str]:
        """Extract all DT overlays from DTBO image."""
        if not self.header:
            self.analyze(file_path)
        
        if not self.entries:
            logger.warning("No DTBO entries found")
            return []
        
        os.makedirs(output_dir, exist_ok=True)
        extracted = []
        
        try:
            with open(file_path, 'rb') as f:
                for i, entry in enumerate(self.entries):
                    if self.progress_callback:
                        self.progress_callback(i, len(self.entries), f"Extracting overlay {i+1}...")
                    
                    f.seek(entry['offset'])
                    dt_data = f.read(entry['size'])
                    
                    # Name based on ID if available, otherwise index
                    if entry['id'] != 0:
                        out_name = f"dtbo_{entry['id']:08x}.dtbo"
                    else:
                        out_name = f"dtbo_{i:02d}.dtbo"
                    
                    out_path = os.path.join(output_dir, out_name)
                    with open(out_path, 'wb') as f_out:
                        f_out.write(dt_data)
                    
                    extracted.append(out_path)
                    logger.info(f"Extracted: {out_name} ({entry['size']} bytes)")
            
            # Write info file
            info_path = os.path.join(output_dir, 'dtbo_info.txt')
            self._write_info(info_path)
            extracted.append(info_path)
            
            if self.progress_callback:
                self.progress_callback(len(self.entries), len(self.entries), "Complete")
            
        except Exception as e:
            logger.error(f"Error extracting DTBO: {e}")
        
        return extracted
    
    def _write_info(self, info_path: str):
        """Write DTBO information to text file."""
        with open(info_path, 'w') as f:
            f.write("=" * 60 + "\n")
            f.write("DTBO (Device Tree Blob Overlay) Image Info\n")
            f.write("=" * 60 + "\n\n")
            
            f.write("Header Information:\n")
            f.write("-" * 40 + "\n")
            f.write(f"  Magic: 0x{self.header.get('magic', 0):08X}\n")
            f.write(f"  Version: {self.header.get('version', 0)}\n")
            f.write(f"  Total Size: {self.header.get('total_size', 0)} bytes\n")
            f.write(f"  Header Size: {self.header.get('header_size', 0)} bytes\n")
            f.write(f"  Page Size: {self.header.get('page_size', 0)}\n")
            f.write(f"  Entry Count: {self.header.get('dt_entry_count', 0)}\n")
            f.write(f"  Entry Size: {self.header.get('dt_entry_size', 0)} bytes\n")
            f.write(f"  Entries Offset: 0x{self.header.get('dt_entries_offset', 0):X}\n")
            f.write("\n")
            
            f.write("DT Overlay Entries:\n")
            f.write("-" * 40 + "\n")
            for entry in self.entries:
                f.write(f"\n  Entry {entry['index']}:\n")
                f.write(f"    Offset: 0x{entry['offset']:X}\n")
                f.write(f"    Size: {entry['size']} bytes\n")
                f.write(f"    ID: 0x{entry['id']:08X}\n")
                f.write(f"    Rev: 0x{entry['rev']:08X}\n")
                f.write(f"    Info: {entry['info']}\n")
            
            f.write("\n" + "=" * 60 + "\n")
            f.write("Extracted by Image Anarchy - https://github.com/vehoelite/image-anarchy\n")
    
    def get_summary(self) -> str:
        """Get human-readable summary of DTBO."""
        if not self.header:
            return "DTBO not analyzed"
        
        lines = [
            f"📦 DTBO Image (Device Tree Blob Overlay)",
            f"  Version: {self.header.get('version', 0)}",
            f"  Overlays: {self.header.get('dt_entry_count', 0)}",
            f"  Page Size: {self.header.get('page_size', 0)}",
            f"  Total Size: {self.header.get('total_size', 0) / 1024:.1f} KB"
        ]
        
        if self.entries:
            lines.append(f"\n  Overlay Details:")
            for entry in self.entries[:5]:  # Show first 5
                lines.append(f"    [{entry['index']:02d}] ID=0x{entry['id']:08X} Size={entry['size']} {entry['info'][:30]}")
            if len(self.entries) > 5:
                lines.append(f"    ... and {len(self.entries) - 5} more overlays")
        
        return '\n'.join(lines)


class VbmetaExtractor:
    """Extract and parse Android Verified Boot (AVB) vbmeta images.
    
    vbmeta images contain cryptographic metadata for verifying Android partitions.
    This extractor parses the AVB header, descriptors, and signatures.
    """
    
    # AVB descriptor types
    AVB_DESCRIPTOR_TAG_PROPERTY = 0
    AVB_DESCRIPTOR_TAG_HASHTREE = 1
    AVB_DESCRIPTOR_TAG_HASH = 2
    AVB_DESCRIPTOR_TAG_KERNEL_CMDLINE = 3
    AVB_DESCRIPTOR_TAG_CHAIN_PARTITION = 4
    
    DESCRIPTOR_NAMES = {
        0: "Property",
        1: "Hashtree",
        2: "Hash",
        3: "Kernel Cmdline",
        4: "Chain Partition",
    }
    
    # AVB algorithm types
    AVB_ALGORITHMS = {
        0: "NONE",
        1: "SHA256_RSA2048",
        2: "SHA256_RSA4096",
        3: "SHA256_RSA8192",
        4: "SHA512_RSA2048",
        5: "SHA512_RSA4096",
        6: "SHA512_RSA8192",
    }
    
    def __init__(self, input_path: str, output_dir: str,
                 progress_callback: Optional[Callable[[int], None]] = None):
        self.input_path = Path(input_path)
        self.output_dir = Path(output_dir)
        self.progress_callback = progress_callback
        self.header = {}
        self.descriptors = []
        
    def extract(self) -> bool:
        """Parse vbmeta image and extract information."""
        try:
            with open(self.input_path, 'rb') as f:
                if not self._parse_header(f):
                    return False
                
                self._parse_descriptors(f)
                
                # Create output directory
                self.output_dir.mkdir(parents=True, exist_ok=True)
                
                # Write info file
                self._write_info_file()
                
                # Extract raw sections if requested
                self._extract_sections(f)
                
            return True
        except Exception as e:
            logger.error(f"Failed to parse vbmeta: {e}")
            return False
    
    def _parse_header(self, f: BinaryIO) -> bool:
        """Parse the AVB vbmeta header."""
        f.seek(0)
        magic = f.read(4)
        
        if magic != AVB_MAGIC:
            logger.error(f"Invalid AVB magic: {magic}")
            return False
        
        # AVB header format (256 bytes total):
        # 0-3: magic "AVB0"
        # 4-7: required_libavb_version_major
        # 8-11: required_libavb_version_minor
        # 12-19: authentication_data_block_size
        # 20-27: auxiliary_data_block_size
        # 28-31: algorithm_type
        # 32-39: hash_offset
        # 40-47: hash_size
        # 48-55: signature_offset
        # 56-63: signature_size
        # 64-71: public_key_offset
        # 72-79: public_key_size
        # 80-87: public_key_metadata_offset
        # 88-95: public_key_metadata_size
        # 96-103: descriptors_offset
        # 104-111: descriptors_size
        # 112-115: rollback_index
        # 116-119: flags
        # 120-123: rollback_index_location
        # 124-171: release_string (48 bytes, null-terminated)
        # 172-255: reserved
        
        header_data = f.read(252)  # Rest of 256-byte header
        
        self.header['version_major'] = struct.unpack('>I', header_data[0:4])[0]
        self.header['version_minor'] = struct.unpack('>I', header_data[4:8])[0]
        self.header['auth_block_size'] = struct.unpack('>Q', header_data[8:16])[0]
        self.header['aux_block_size'] = struct.unpack('>Q', header_data[16:24])[0]
        self.header['algorithm'] = struct.unpack('>I', header_data[24:28])[0]
        self.header['algorithm_name'] = self.AVB_ALGORITHMS.get(
            self.header['algorithm'], f"Unknown ({self.header['algorithm']})"
        )
        self.header['hash_offset'] = struct.unpack('>Q', header_data[28:36])[0]
        self.header['hash_size'] = struct.unpack('>Q', header_data[36:44])[0]
        self.header['signature_offset'] = struct.unpack('>Q', header_data[44:52])[0]
        self.header['signature_size'] = struct.unpack('>Q', header_data[52:60])[0]
        self.header['public_key_offset'] = struct.unpack('>Q', header_data[60:68])[0]
        self.header['public_key_size'] = struct.unpack('>Q', header_data[68:76])[0]
        self.header['descriptors_offset'] = struct.unpack('>Q', header_data[92:100])[0]
        self.header['descriptors_size'] = struct.unpack('>Q', header_data[100:108])[0]
        self.header['rollback_index'] = struct.unpack('>Q', header_data[108:116])[0]
        self.header['flags'] = struct.unpack('>I', header_data[116:120])[0]
        
        # Release string (null-terminated)
        release_bytes = header_data[120:168]
        null_pos = release_bytes.find(b'\x00')
        if null_pos != -1:
            release_bytes = release_bytes[:null_pos]
        self.header['release_string'] = release_bytes.decode('utf-8', errors='replace')
        
        # Decode flags
        flags = []
        if self.header['flags'] & 0x1:
            flags.append("DISABLE_VERITY")
        if self.header['flags'] & 0x2:
            flags.append("DISABLE_VERIFICATION")
        self.header['flags_decoded'] = flags if flags else ["NONE"]
        
        logger.info(f"AVB Header: version {self.header['version_major']}.{self.header['version_minor']}, "
                   f"algorithm: {self.header['algorithm_name']}")
        
        return True
    
    def _parse_descriptors(self, f: BinaryIO):
        """Parse AVB descriptors from auxiliary data block."""
        # Descriptors start after header (256 bytes) + auth block
        desc_start = 256 + self.header['auth_block_size'] + self.header['descriptors_offset']
        desc_end = desc_start + self.header['descriptors_size']
        
        f.seek(desc_start)
        pos = desc_start
        
        while pos < desc_end:
            # Each descriptor has a tag (8 bytes) and length (8 bytes)
            tag_data = f.read(8)
            if len(tag_data) < 8:
                break
            
            tag = struct.unpack('>Q', tag_data)[0]
            num_bytes = struct.unpack('>Q', f.read(8))[0]
            
            descriptor = {
                'tag': tag,
                'tag_name': self.DESCRIPTOR_NAMES.get(tag, f"Unknown ({tag})"),
                'size': num_bytes,
            }
            
            # Read descriptor data
            data = f.read(num_bytes)
            
            if tag == self.AVB_DESCRIPTOR_TAG_HASH:
                self._parse_hash_descriptor(descriptor, data)
            elif tag == self.AVB_DESCRIPTOR_TAG_HASHTREE:
                self._parse_hashtree_descriptor(descriptor, data)
            elif tag == self.AVB_DESCRIPTOR_TAG_KERNEL_CMDLINE:
                self._parse_cmdline_descriptor(descriptor, data)
            elif tag == self.AVB_DESCRIPTOR_TAG_CHAIN_PARTITION:
                self._parse_chain_descriptor(descriptor, data)
            elif tag == self.AVB_DESCRIPTOR_TAG_PROPERTY:
                self._parse_property_descriptor(descriptor, data)
            
            self.descriptors.append(descriptor)
            pos = f.tell()
        
        logger.info(f"Found {len(self.descriptors)} AVB descriptor(s)")
    
    def _parse_hash_descriptor(self, desc: dict, data: bytes):
        """Parse hash descriptor - used for small partitions."""
        if len(data) < 72:
            return
        
        desc['image_size'] = struct.unpack('>Q', data[0:8])[0]
        desc['hash_algorithm'] = data[8:40].rstrip(b'\x00').decode('utf-8', errors='replace')
        partition_name_len = struct.unpack('>I', data[40:44])[0]
        salt_len = struct.unpack('>I', data[44:48])[0]
        digest_len = struct.unpack('>I', data[48:52])[0]
        # 52-55: flags
        # 56-63: reserved
        
        offset = 64
        desc['partition_name'] = data[offset:offset+partition_name_len].decode('utf-8', errors='replace')
        offset += partition_name_len
        desc['salt'] = data[offset:offset+salt_len].hex() if salt_len > 0 else ""
        offset += salt_len
        desc['digest'] = data[offset:offset+digest_len].hex() if digest_len > 0 else ""
    
    def _parse_hashtree_descriptor(self, desc: dict, data: bytes):
        """Parse hashtree descriptor - used for large partitions with dm-verity."""
        if len(data) < 120:
            return
        
        desc['dm_verity_version'] = struct.unpack('>I', data[0:4])[0]
        desc['image_size'] = struct.unpack('>Q', data[4:12])[0]
        desc['tree_offset'] = struct.unpack('>Q', data[12:20])[0]
        desc['tree_size'] = struct.unpack('>Q', data[20:28])[0]
        desc['data_block_size'] = struct.unpack('>I', data[28:32])[0]
        desc['hash_block_size'] = struct.unpack('>I', data[32:36])[0]
        desc['fec_num_roots'] = struct.unpack('>I', data[36:40])[0]
        desc['fec_offset'] = struct.unpack('>Q', data[40:48])[0]
        desc['fec_size'] = struct.unpack('>Q', data[48:56])[0]
        desc['hash_algorithm'] = data[56:88].rstrip(b'\x00').decode('utf-8', errors='replace')
        partition_name_len = struct.unpack('>I', data[88:92])[0]
        salt_len = struct.unpack('>I', data[92:96])[0]
        root_digest_len = struct.unpack('>I', data[96:100])[0]
        # 100-103: flags
        # 104-119: reserved
        
        offset = 120
        desc['partition_name'] = data[offset:offset+partition_name_len].decode('utf-8', errors='replace')
        offset += partition_name_len
        desc['salt'] = data[offset:offset+salt_len].hex() if salt_len > 0 else ""
        offset += salt_len
        desc['root_digest'] = data[offset:offset+root_digest_len].hex() if root_digest_len > 0 else ""
    
    def _parse_cmdline_descriptor(self, desc: dict, data: bytes):
        """Parse kernel command line descriptor."""
        if len(data) < 8:
            return
        
        # 0-3: flags
        cmdline_len = struct.unpack('>I', data[4:8])[0]
        desc['cmdline'] = data[8:8+cmdline_len].decode('utf-8', errors='replace')
    
    def _parse_chain_descriptor(self, desc: dict, data: bytes):
        """Parse chain partition descriptor - references vbmeta in another partition."""
        if len(data) < 28:
            return
        
        desc['rollback_index_location'] = struct.unpack('>I', data[0:4])[0]
        partition_name_len = struct.unpack('>I', data[4:8])[0]
        public_key_len = struct.unpack('>I', data[8:12])[0]
        # 12-27: reserved
        
        offset = 28
        desc['partition_name'] = data[offset:offset+partition_name_len].decode('utf-8', errors='replace')
        offset += partition_name_len
        if public_key_len > 0:
            desc['public_key_size'] = public_key_len
    
    def _parse_property_descriptor(self, desc: dict, data: bytes):
        """Parse property descriptor."""
        if len(data) < 8:
            return
        
        key_len = struct.unpack('>Q', data[0:8])[0]
        value_len = struct.unpack('>Q', data[8:16])[0]
        
        offset = 16
        desc['key'] = data[offset:offset+key_len].decode('utf-8', errors='replace')
        offset += key_len
        desc['value'] = data[offset:offset+value_len].decode('utf-8', errors='replace')
    
    def _write_info_file(self):
        """Write parsed vbmeta information to a text file."""
        info_path = self.output_dir / "vbmeta_info.txt"
        
        with open(info_path, 'w') as f:
            f.write("Android Verified Boot (AVB) vbmeta Information\n")
            f.write("=" * 60 + "\n\n")
            
            f.write("Header:\n")
            f.write(f"  AVB Version:      {self.header['version_major']}.{self.header['version_minor']}\n")
            f.write(f"  Algorithm:        {self.header['algorithm_name']}\n")
            f.write(f"  Rollback Index:   {self.header['rollback_index']}\n")
            f.write(f"  Flags:            {', '.join(self.header['flags_decoded'])}\n")
            f.write(f"  Release String:   {self.header['release_string']}\n")
            f.write(f"  Auth Block Size:  {self.header['auth_block_size']} bytes\n")
            f.write(f"  Aux Block Size:   {self.header['aux_block_size']} bytes\n")
            f.write(f"  Signature Size:   {self.header['signature_size']} bytes\n")
            f.write(f"  Public Key Size:  {self.header['public_key_size']} bytes\n")
            f.write("\n")
            
            f.write(f"Descriptors ({len(self.descriptors)}):\n")
            f.write("-" * 60 + "\n")
            
            for i, desc in enumerate(self.descriptors):
                f.write(f"\n[{i}] {desc['tag_name']}\n")
                
                if 'partition_name' in desc:
                    f.write(f"    Partition:      {desc['partition_name']}\n")
                if 'image_size' in desc:
                    f.write(f"    Image Size:     {desc['image_size']} bytes ({desc['image_size']/(1024*1024):.2f} MB)\n")
                if 'hash_algorithm' in desc:
                    f.write(f"    Hash Algorithm: {desc['hash_algorithm']}\n")
                if 'digest' in desc:
                    f.write(f"    Digest:         {desc['digest'][:64]}{'...' if len(desc.get('digest','')) > 64 else ''}\n")
                if 'root_digest' in desc:
                    f.write(f"    Root Digest:    {desc['root_digest'][:64]}{'...' if len(desc.get('root_digest','')) > 64 else ''}\n")
                if 'tree_size' in desc:
                    f.write(f"    Tree Size:      {desc['tree_size']} bytes\n")
                if 'cmdline' in desc:
                    cmdline = desc['cmdline']
                    if len(cmdline) > 100:
                        cmdline = cmdline[:100] + "..."
                    f.write(f"    Cmdline:        {cmdline}\n")
                if 'key' in desc:
                    f.write(f"    Key:            {desc['key']}\n")
                    f.write(f"    Value:          {desc['value']}\n")
                if 'rollback_index_location' in desc:
                    f.write(f"    Rollback Idx:   {desc['rollback_index_location']}\n")
        
        logger.info(f"Wrote vbmeta info to: {info_path}")
    
    def _extract_sections(self, f: BinaryIO):
        """Extract raw sections (signature, public key) from vbmeta."""
        # Extract signature if present
        if self.header['signature_size'] > 0:
            sig_path = self.output_dir / "signature.bin"
            f.seek(256 + self.header['signature_offset'])
            sig_data = f.read(self.header['signature_size'])
            with open(sig_path, 'wb') as out:
                out.write(sig_data)
            logger.info(f"  Extracted: signature.bin ({self.header['signature_size']} bytes)")
        
        # Extract public key if present
        if self.header['public_key_size'] > 0:
            key_path = self.output_dir / "public_key.bin"
            f.seek(256 + self.header['auth_block_size'] + self.header['public_key_offset'])
            key_data = f.read(self.header['public_key_size'])
            with open(key_path, 'wb') as out:
                out.write(key_data)
            logger.info(f"  Extracted: public_key.bin ({self.header['public_key_size']} bytes)")
        
        if self.progress_callback:
            self.progress_callback(100)
    
    def get_partition_info(self) -> list[dict]:
        """Get list of partitions referenced in vbmeta."""
        partitions = []
        for desc in self.descriptors:
            if 'partition_name' in desc:
                partitions.append({
                    'name': desc['partition_name'],
                    'type': desc['tag_name'],
                    'size': desc.get('image_size', 0),
                })
        return partitions


class BootloaderImageAnalyzer:
    """Analyze and extract information from bootloader images.
    
    Supports:
    - Qualcomm: XBL, ABL, TZ, HYP, AOP, DEVCFG, etc. (ELF and MBN formats)
    - MediaTek: LK (Little Kernel), preloader
    - Generic: ELF-based bootloaders
    
    This class parses bootloader images to extract metadata like:
    - Format type and version
    - Signing information
    - Build timestamp
    - Code/data segments
    """
    
    # Qualcomm MBN header structure (v5/v6)
    MBN_HDR_VERSION_3 = 3
    MBN_HDR_VERSION_5 = 5
    MBN_HDR_VERSION_6 = 6
    MBN_HDR_VERSION_7 = 7
    
    # Known Qualcomm image IDs
    QCOM_IMAGE_IDS = {
        0x00: "NONE",
        0x01: "OEM_SBL",
        0x02: "AMSS",
        0x03: "QCSBL",
        0x04: "HASH",
        0x05: "APPSBL",  # ABL
        0x06: "APPS",
        0x07: "HOSTDL",
        0x08: "DSP1",
        0x09: "FSBL",
        0x0A: "DBL",
        0x0B: "OSBL",
        0x0C: "DSP2",
        0x0D: "EHOSTDL",
        0x0E: "NANDPRG",
        0x0F: "NORPRG",
        0x10: "RAMFS1",
        0x11: "RAMFS2",
        0x12: "ADSP_Q5",
        0x13: "APPS_KERNEL",
        0x14: "BACKUP_RAMFS",
        0x15: "SBL1",
        0x16: "SBL2",
        0x17: "RPM",
        0x18: "SBL3",
        0x19: "TZ",      # TrustZone
        0x1A: "PSI",
        0x1B: "MBA",     # Modem Boot Authenticator
        0x1C: "MODEM_SW",
        0x1D: "SDI",
        0x1E: "QDSP6_SW",
        0x1F: "XBL_SEC",
        0x20: "SMSS_PIL",
        0x21: "ABL",      # Android Bootloader
        0x22: "DEVCFG",
        0x23: "AOP",      # Always-On Processor
        0x24: "APDP",
        0x25: "MULTIIMGOEM",
        0x26: "QTI",
        0x27: "HYP",      # Hypervisor
        0x28: "SEC",
        0x29: "UEFI",
        0x2A: "XBL_CFG",
        0x2B: "STORSEC",
        0x2C: "SHRM",
        0x2D: "UEFI_SEC",
        0x2E: "CPUCP",
        0x2F: "QUPFW",
    }
    
    def __init__(self, input_path: str, output_dir: str,
                 progress_callback: Optional[Callable[[int], None]] = None):
        self.input_path = Path(input_path)
        self.output_dir = Path(output_dir)
        self.progress_callback = progress_callback
        self.info = {}
        self.segments = []
        
    def analyze(self) -> dict:
        """Analyze the bootloader image and return detailed information."""
        try:
            with open(self.input_path, 'rb') as f:
                header = f.read(64)
                
                # Detect format
                if header[:4] == ELF_MAGIC:
                    self._analyze_elf_bootloader(f, header)
                elif header[:8] == LK_MAGIC:
                    self._analyze_lk_bootloader(f, header)
                else:
                    # Try MBN format
                    self._analyze_mbn_bootloader(f, header)
                    
            return self.info
        except Exception as e:
            logger.error(f"Failed to analyze bootloader: {e}")
            return {'error': str(e)}
    
    def _analyze_elf_bootloader(self, f: BinaryIO, header: bytes):
        """Analyze ELF-format bootloader (Qualcomm XBL, ABL, etc.)."""
        self.info['format'] = 'ELF'
        
        # Parse ELF header
        ei_class = header[4]
        ei_data = header[5]
        self.info['elf_class'] = '64-bit' if ei_class == 2 else '32-bit'
        self.info['endian'] = 'Little' if ei_data == 1 else 'Big'
        endian = '<' if ei_data == 1 else '>'
        
        if ei_class == 2:  # 64-bit
            e_type, e_machine = struct.unpack(f'{endian}HH', header[16:20])
            e_entry = struct.unpack(f'{endian}Q', header[24:32])[0]
            e_phoff = struct.unpack(f'{endian}Q', header[32:40])[0]
            e_phentsize, e_phnum = struct.unpack(f'{endian}HH', header[54:58])
        else:  # 32-bit
            e_type, e_machine = struct.unpack(f'{endian}HH', header[16:20])
            e_entry = struct.unpack(f'{endian}I', header[24:28])[0]
            e_phoff = struct.unpack(f'{endian}I', header[28:32])[0]
            e_phentsize, e_phnum = struct.unpack(f'{endian}HH', header[42:46])
        
        machine_names = {
            0: "None", 3: "Intel 386", 8: "MIPS", 40: "ARM",
            62: "x86-64", 164: "Qualcomm Hexagon", 183: "AArch64",
        }
        
        self.info['machine'] = machine_names.get(e_machine, f"Unknown (0x{e_machine:X})")
        self.info['entry_point'] = f"0x{e_entry:X}"
        self.info['segments'] = e_phnum
        
        # Try to identify image type from filename
        filename = self.input_path.stem.lower()
        if 'xbl' in filename:
            self.info['type'] = 'XBL (eXtensible Boot Loader)'
            self.info['description'] = 'Primary bootloader, UEFI-based, handles secure boot'
        elif 'abl' in filename:
            self.info['type'] = 'ABL (Android Boot Loader)'
            self.info['description'] = 'Secondary bootloader, handles fastboot mode'
        elif 'tz' in filename or 'tzsq' in filename:
            self.info['type'] = 'TZ (TrustZone)'
            self.info['description'] = 'Secure world OS for TrustZone TEE'
        elif 'hyp' in filename:
            self.info['type'] = 'HYP (Hypervisor)'
            self.info['description'] = 'Hypervisor for hardware virtualization'
        elif 'aop' in filename:
            self.info['type'] = 'AOP (Always-On Processor)'
            self.info['description'] = 'Low-power processor firmware'
        elif 'devcfg' in filename:
            self.info['type'] = 'DEVCFG (Device Config)'
            self.info['description'] = 'Device configuration data'
        elif 'keymaster' in filename or 'km' in filename:
            self.info['type'] = 'Keymaster'
            self.info['description'] = 'Hardware-backed key storage trustlet'
        elif 'cmnlib' in filename:
            self.info['type'] = 'CMNLIB (Common Library)'
            self.info['description'] = 'Shared TrustZone library'
        elif 'storsec' in filename:
            self.info['type'] = 'STORSEC (Storage Security)'
            self.info['description'] = 'Secure storage firmware'
        elif 'qupfw' in filename:
            self.info['type'] = 'QUPFW (QUP Firmware)'
            self.info['description'] = 'Qualcomm Universal Peripheral firmware'
        elif 'uefi' in filename:
            self.info['type'] = 'UEFI'
            self.info['description'] = 'UEFI firmware component'
        else:
            self.info['type'] = 'Qualcomm Signed ELF'
            self.info['description'] = 'Qualcomm bootloader/firmware component'
        
        # Parse program headers to find hash segment (Qualcomm signing info)
        self._parse_elf_segments(f, e_phoff, e_phentsize, e_phnum, ei_class, endian)
        
        # Look for build info strings
        self._find_build_info(f)
    
    def _parse_elf_segments(self, f: BinaryIO, phoff: int, phentsize: int, 
                           phnum: int, ei_class: int, endian: str):
        """Parse ELF program headers."""
        f.seek(phoff)
        
        for i in range(phnum):
            ph_data = f.read(phentsize)
            
            if ei_class == 2:  # 64-bit
                p_type, p_flags = struct.unpack(f'{endian}II', ph_data[0:8])
                p_offset = struct.unpack(f'{endian}Q', ph_data[8:16])[0]
                p_vaddr = struct.unpack(f'{endian}Q', ph_data[16:24])[0]
                p_filesz = struct.unpack(f'{endian}Q', ph_data[32:40])[0]
            else:  # 32-bit
                p_type = struct.unpack(f'{endian}I', ph_data[0:4])[0]
                p_offset = struct.unpack(f'{endian}I', ph_data[4:8])[0]
                p_vaddr = struct.unpack(f'{endian}I', ph_data[8:12])[0]
                p_filesz = struct.unpack(f'{endian}I', ph_data[16:20])[0]
                p_flags = struct.unpack(f'{endian}I', ph_data[24:28])[0]
            
            segment_types = {
                0: "NULL", 1: "LOAD", 2: "DYNAMIC", 3: "INTERP",
                4: "NOTE", 5: "SHLIB", 6: "PHDR", 7: "TLS",
                0x6474e550: "GNU_EH_FRAME", 0x6474e551: "GNU_STACK",
                0x6474e552: "GNU_RELRO", 0x6FFFFFFD: "QC_HASH",
                0x6FFFFFFA: "QC_PHDR_HASH",
            }
            
            self.segments.append({
                'index': i,
                'type': segment_types.get(p_type, f"0x{p_type:X}"),
                'offset': p_offset,
                'vaddr': p_vaddr,
                'size': p_filesz,
                'flags': p_flags,
            })
            
            # Check for Qualcomm hash segment
            if p_type == 0x6FFFFFFD:  # QC_HASH
                self.info['qcom_signed'] = True
                self._parse_qcom_hash_segment(f, p_offset, p_filesz)
    
    def _parse_qcom_hash_segment(self, f: BinaryIO, offset: int, size: int):
        """Parse Qualcomm hash segment for signing info."""
        if size < 40:
            return
        
        f.seek(offset)
        hash_data = f.read(min(size, 256))
        
        # The hash segment contains certificate chain info
        # First few bytes often contain version/type info
        self.info['hash_segment_size'] = size
    
    def _find_build_info(self, f: BinaryIO):
        """Search for build information strings in the image."""
        f.seek(0)
        data = f.read()
        
        # Common build info patterns
        patterns = [
            (b'QC_IMAGE_VERSION_STRING=', 'qc_version'),
            (b'IMAGE_VARIANT_STRING=', 'variant'),
            (b'OEM_IMAGE_VERSION_STRING=', 'oem_version'),
            (b'BUILD_', 'build_info'),
            (b'@(#)', 'sccs_version'),
        ]
        
        for pattern, key in patterns:
            idx = data.find(pattern)
            if idx != -1:
                # Extract string until null or newline
                end = idx + len(pattern)
                string_data = b''
                while end < len(data) and data[end:end+1] not in (b'\x00', b'\n', b'\r'):
                    string_data += data[end:end+1]
                    end += 1
                if string_data:
                    try:
                        self.info[key] = string_data.decode('utf-8', errors='replace')[:100]
                    except:
                        pass
        
        # Look for timestamp patterns (common in Qualcomm images)
        import re
        date_pattern = rb'[A-Z][a-z]{2}\s+\d{1,2}\s+\d{4}'
        time_pattern = rb'\d{2}:\d{2}:\d{2}'
        
        date_match = re.search(date_pattern, data)
        time_match = re.search(time_pattern, data)
        
        if date_match:
            try:
                self.info['build_date'] = date_match.group().decode('utf-8')
            except:
                pass
        if time_match:
            try:
                self.info['build_time'] = time_match.group().decode('utf-8')
            except:
                pass
    
    def _analyze_lk_bootloader(self, f: BinaryIO, header: bytes):
        """Analyze Little Kernel (MediaTek) bootloader."""
        self.info['format'] = 'Little Kernel (LK)'
        self.info['type'] = 'MediaTek Bootloader'
        self.info['description'] = 'Little Kernel based bootloader (MediaTek)'
        
        # LK header structure after magic
        if len(header) >= 40:
            # Parse LK header fields
            f.seek(8)
            lk_header = f.read(32)
            
            if len(lk_header) >= 24:
                size = struct.unpack('<I', lk_header[0:4])[0]
                self.info['image_size'] = size
    
    def _analyze_mbn_bootloader(self, f: BinaryIO, header: bytes):
        """Analyze Qualcomm MBN format bootloader."""
        mbn_type = struct.unpack('<I', header[0:4])[0]
        
        if mbn_type not in (self.MBN_HDR_VERSION_3, self.MBN_HDR_VERSION_5, 
                           self.MBN_HDR_VERSION_6, self.MBN_HDR_VERSION_7):
            self.info['format'] = 'Unknown'
            return
        
        self.info['format'] = f'Qualcomm MBN v{mbn_type}'
        self.info['mbn_version'] = mbn_type
        
        # MBN header structure (v5+)
        # 0x00: Image type (4 bytes)
        # 0x04: Flash partition version (4 bytes)
        # 0x08: Source image address (4 bytes)
        # 0x0C: Source image size (4 bytes)
        # 0x10: Code size (4 bytes)
        # 0x14: Signature address (4 bytes)
        # 0x18: Signature size (4 bytes)
        # 0x1C: Certificate chain address (4 bytes)
        # 0x20: Certificate chain size (4 bytes)
        
        f.seek(0)
        mbn_header = f.read(80)
        
        if len(mbn_header) >= 36:
            flash_parti_ver = struct.unpack('<I', mbn_header[4:8])[0]
            image_src = struct.unpack('<I', mbn_header[8:12])[0]
            image_size = struct.unpack('<I', mbn_header[12:16])[0]
            code_size = struct.unpack('<I', mbn_header[16:20])[0]
            sig_addr = struct.unpack('<I', mbn_header[20:24])[0]
            sig_size = struct.unpack('<I', mbn_header[24:28])[0]
            cert_addr = struct.unpack('<I', mbn_header[28:32])[0]
            cert_size = struct.unpack('<I', mbn_header[32:36])[0]
            
            self.info['flash_partition_version'] = flash_parti_ver
            self.info['image_size'] = image_size
            self.info['code_size'] = code_size
            self.info['signature_size'] = sig_size
            self.info['cert_chain_size'] = cert_size
            self.info['is_signed'] = sig_size > 0 or cert_size > 0
        
        # Try to identify image type from filename
        filename = self.input_path.stem.lower()
        self.info['type'] = self._identify_mbn_type(filename)
    
    def _identify_mbn_type(self, filename: str) -> str:
        """Identify MBN image type from filename."""
        type_map = {
            'sbl1': 'SBL1 (Secondary Boot Loader)',
            'rpm': 'RPM (Resource Power Manager)',
            'tz': 'TZ (TrustZone)',
            'hyp': 'HYP (Hypervisor)',
            'abl': 'ABL (Android Boot Loader)',
            'xbl': 'XBL (eXtensible Boot Loader)',
            'devcfg': 'DEVCFG (Device Configuration)',
            'aop': 'AOP (Always-On Processor)',
            'keymaster': 'Keymaster (Key Storage)',
            'cmnlib': 'CMNLIB (Common Library)',
            'storsec': 'STORSEC (Storage Security)',
            'qupfw': 'QUPFW (QUP Firmware)',
        }
        
        for key, value in type_map.items():
            if key in filename:
                return value
        return 'Qualcomm MBN Image'
    
    def extract(self) -> bool:
        """Extract bootloader information and segments."""
        try:
            # Analyze first
            self.analyze()
            
            # Create output directory
            self.output_dir.mkdir(parents=True, exist_ok=True)
            
            # Write info file
            self._write_info_file()
            
            # Extract segments if ELF
            if self.info.get('format') == 'ELF' and self.segments:
                self._extract_segments()
            
            if self.progress_callback:
                self.progress_callback(100)
            
            return True
        except Exception as e:
            logger.error(f"Failed to extract bootloader: {e}")
            return False
    
    def _write_info_file(self):
        """Write bootloader information to a text file."""
        info_path = self.output_dir / "bootloader_info.txt"
        
        with open(info_path, 'w') as f:
            f.write("Bootloader Image Analysis\n")
            f.write("=" * 60 + "\n\n")
            
            f.write(f"File: {self.input_path.name}\n")
            f.write(f"Size: {self.input_path.stat().st_size:,} bytes\n\n")
            
            f.write("Image Information:\n")
            f.write("-" * 40 + "\n")
            
            for key, value in self.info.items():
                if key not in ('error',):
                    f.write(f"  {key}: {value}\n")
            
            if self.segments:
                f.write("\nProgram Segments:\n")
                f.write("-" * 40 + "\n")
                for seg in self.segments:
                    f.write(f"\n  [{seg['index']}] {seg['type']}\n")
                    f.write(f"      Offset: 0x{seg['offset']:X}\n")
                    f.write(f"      VAddr:  0x{seg['vaddr']:X}\n")
                    f.write(f"      Size:   {seg['size']:,} bytes\n")
                    flags = []
                    if seg['flags'] & 1: flags.append('X')
                    if seg['flags'] & 2: flags.append('W')
                    if seg['flags'] & 4: flags.append('R')
                    f.write(f"      Flags:  {' '.join(flags) if flags else 'None'}\n")
            
            f.write("\n" + "=" * 60 + "\n")
            f.write("Note: This is a bootloader/firmware image.\n")
            f.write("Modifying bootloader images can brick your device.\n")
            f.write("These images are typically signed and verified by secure boot.\n")
        
        logger.info(f"Wrote bootloader info to: {info_path}")
    
    def _extract_segments(self):
        """Extract ELF segments to separate files."""
        with open(self.input_path, 'rb') as f:
            for seg in self.segments:
                if seg['size'] == 0:
                    continue
                
                f.seek(seg['offset'])
                data = f.read(seg['size'])
                
                type_name = seg['type'].replace(' ', '_').replace('/', '_')
                filename = f"segment_{seg['index']:02d}_{type_name}_0x{seg['vaddr']:08X}.bin"
                
                output_path = self.output_dir / filename
                with open(output_path, 'wb') as out:
                    out.write(data)
                
                logger.info(f"  Extracted: {filename} ({seg['size']:,} bytes)")


class AvbSigner:
    """AVB (Android Verified Boot) key management and signing.
    
    Supports:
    - Generating RSA key pairs (2048, 4096, 8192 bits)
    - Signing vbmeta images with custom keys
    - Exporting keys in AVB format
    
    Note: Re-signed vbmeta will only work on:
    - Unlocked bootloaders
    - Devices with custom AVB key enrolled
    - Custom ROM/recovery environments
    """
    
    # AVB algorithm IDs
    ALG_NONE = 0
    ALG_SHA256_RSA2048 = 1
    ALG_SHA256_RSA4096 = 2
    ALG_SHA256_RSA8192 = 3
    ALG_SHA512_RSA2048 = 4
    ALG_SHA512_RSA4096 = 5
    ALG_SHA512_RSA8192 = 6
    
    ALGORITHM_INFO = {
        ALG_SHA256_RSA2048: {'hash': 'sha256', 'key_bits': 2048, 'hash_size': 32, 'sig_size': 256},
        ALG_SHA256_RSA4096: {'hash': 'sha256', 'key_bits': 4096, 'hash_size': 32, 'sig_size': 512},
        ALG_SHA256_RSA8192: {'hash': 'sha256', 'key_bits': 8192, 'hash_size': 32, 'sig_size': 1024},
        ALG_SHA512_RSA2048: {'hash': 'sha512', 'key_bits': 2048, 'hash_size': 64, 'sig_size': 256},
        ALG_SHA512_RSA4096: {'hash': 'sha512', 'key_bits': 4096, 'hash_size': 64, 'sig_size': 512},
        ALG_SHA512_RSA8192: {'hash': 'sha512', 'key_bits': 8192, 'hash_size': 64, 'sig_size': 1024},
    }
    
    def __init__(self):
        if not CRYPTO_AVAILABLE:
            raise ImportError("cryptography library required for AVB signing. "
                            "Install with: pip install cryptography")
        self.private_key = None
        self.public_key = None
        self.key_bits = 4096
    
    @staticmethod
    def is_available() -> bool:
        """Check if cryptography library is available."""
        return CRYPTO_AVAILABLE
    
    def generate_key(self, key_bits: int = 4096) -> bool:
        """Generate a new RSA key pair.
        
        Args:
            key_bits: Key size (2048, 4096, or 8192)
            
        Returns:
            True if successful
        """
        if key_bits not in (2048, 4096, 8192):
            logger.error(f"Invalid key size: {key_bits}. Must be 2048, 4096, or 8192")
            return False
        
        try:
            logger.info(f"Generating RSA-{key_bits} key pair...")
            self.private_key = rsa.generate_private_key(
                public_exponent=65537,
                key_size=key_bits,
                backend=default_backend()
            )
            self.public_key = self.private_key.public_key()
            self.key_bits = key_bits
            logger.info("Key pair generated successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to generate key: {e}")
            return False
    
    def load_private_key(self, key_path: str, password: Optional[bytes] = None) -> bool:
        """Load private key from PEM file.
        
        Args:
            key_path: Path to PEM private key file
            password: Optional password for encrypted keys
            
        Returns:
            True if successful
        """
        try:
            with open(key_path, 'rb') as f:
                key_data = f.read()
            
            self.private_key = serialization.load_pem_private_key(
                key_data,
                password=password,
                backend=default_backend()
            )
            self.public_key = self.private_key.public_key()
            self.key_bits = self.private_key.key_size
            logger.info(f"Loaded RSA-{self.key_bits} private key from {key_path}")
            return True
        except Exception as e:
            logger.error(f"Failed to load private key: {e}")
            return False
    
    def save_private_key(self, key_path: str, password: Optional[bytes] = None) -> bool:
        """Save private key to PEM file.
        
        Args:
            key_path: Output path for PEM file
            password: Optional password to encrypt the key
            
        Returns:
            True if successful
        """
        if not self.private_key:
            logger.error("No private key to save")
            return False
        
        try:
            if password:
                encryption = serialization.BestAvailableEncryption(password)
            else:
                encryption = serialization.NoEncryption()
            
            pem_data = self.private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=encryption
            )
            
            with open(key_path, 'wb') as f:
                f.write(pem_data)
            
            logger.info(f"Saved private key to {key_path}")
            return True
        except Exception as e:
            logger.error(f"Failed to save private key: {e}")
            return False
    
    def save_public_key(self, key_path: str) -> bool:
        """Save public key to PEM file.
        
        Args:
            key_path: Output path for PEM file
            
        Returns:
            True if successful
        """
        if not self.public_key:
            logger.error("No public key to save")
            return False
        
        try:
            pem_data = self.public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
            
            with open(key_path, 'wb') as f:
                f.write(pem_data)
            
            logger.info(f"Saved public key to {key_path}")
            return True
        except Exception as e:
            logger.error(f"Failed to save public key: {e}")
            return False
    
    def get_avb_public_key_blob(self) -> bytes:
        """Get public key in AVB format for embedding in vbmeta.
        
        AVB public key format:
        - 4 bytes: key length in bits (big-endian)
        - 4 bytes: n0inv (Montgomery multiplication helper)
        - key_size/8 bytes: modulus n (big-endian)
        - key_size/8 bytes: rr = (2^(key_size*2)) mod n (big-endian)
        
        Returns:
            Public key blob in AVB format
        """
        if not self.public_key:
            return b''
        
        # Get public numbers
        pub_numbers = self.public_key.public_numbers()
        n = pub_numbers.n
        
        key_bytes = self.key_bits // 8
        
        # Calculate n0inv: -1/n[0] mod 2^32
        # This is used for Montgomery multiplication optimization
        n0inv = pow(-n, -1, 2**32) & 0xFFFFFFFF
        
        # Calculate rr = (2^(key_bits*2)) mod n
        rr = pow(2, self.key_bits * 2, n)
        
        # Build the blob
        blob = struct.pack('>I', self.key_bits)  # Key size in bits
        blob += struct.pack('>I', n0inv)          # n0inv
        blob += n.to_bytes(key_bytes, 'big')      # Modulus n
        blob += rr.to_bytes(key_bytes, 'big')     # rr
        
        return blob
    
    def sign_data(self, data: bytes, algorithm_id: int) -> bytes:
        """Sign data using the private key.
        
        Args:
            data: Data to sign
            algorithm_id: AVB algorithm ID
            
        Returns:
            Signature bytes
        """
        if not self.private_key:
            raise ValueError("No private key loaded")
        
        alg_info = self.ALGORITHM_INFO.get(algorithm_id)
        if not alg_info:
            raise ValueError(f"Unknown algorithm ID: {algorithm_id}")
        
        # Select hash algorithm
        if alg_info['hash'] == 'sha256':
            hash_alg = hashes.SHA256()
        else:
            hash_alg = hashes.SHA512()
        
        # Sign with PKCS#1 v1.5 padding (what AVB uses)
        signature = self.private_key.sign(
            data,
            padding.PKCS1v15(),
            hash_alg
        )
        
        return signature
    
    def compute_hash(self, data: bytes, algorithm_id: int) -> bytes:
        """Compute hash of data.
        
        Args:
            data: Data to hash
            algorithm_id: AVB algorithm ID
            
        Returns:
            Hash bytes
        """
        alg_info = self.ALGORITHM_INFO.get(algorithm_id)
        if not alg_info:
            raise ValueError(f"Unknown algorithm ID: {algorithm_id}")
        
        if alg_info['hash'] == 'sha256':
            return hashlib.sha256(data).digest()
        else:
            return hashlib.sha512(data).digest()
    
    def get_algorithm_for_key_size(self, use_sha512: bool = False) -> int:
        """Get appropriate AVB algorithm ID for current key size.
        
        Args:
            use_sha512: Use SHA-512 instead of SHA-256
            
        Returns:
            AVB algorithm ID
        """
        if use_sha512:
            return {2048: self.ALG_SHA512_RSA2048, 
                    4096: self.ALG_SHA512_RSA4096, 
                    8192: self.ALG_SHA512_RSA8192}.get(self.key_bits, self.ALG_SHA512_RSA4096)
        else:
            return {2048: self.ALG_SHA256_RSA2048, 
                    4096: self.ALG_SHA256_RSA4096, 
                    8192: self.ALG_SHA256_RSA8192}.get(self.key_bits, self.ALG_SHA256_RSA4096)


class VbmetaPatcher:
    """Patch vbmeta images to disable verity and/or verification.
    
    This modifies the flags field in the vbmeta header to disable:
    - dm-verity (hashtree verification)
    - AVB verification (signature checking)
    
    Note: After patching, the vbmeta signature becomes invalid.
    The device bootloader must be unlocked to boot with patched vbmeta.
    
    Optional: Re-sign with a custom key for development/custom ROM use.
    """
    
    # Flag values
    FLAG_DISABLE_VERITY = 0x01        # AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED
    FLAG_DISABLE_VERIFICATION = 0x02  # AVB_VBMETA_IMAGE_FLAGS_VERIFICATION_DISABLED
    
    # Offset of flags field in vbmeta header (after 4-byte magic)
    FLAGS_OFFSET = 120  # Absolute offset from start of file
    
    # Header offsets (all big-endian)
    OFFSET_VERSION_MAJOR = 4
    OFFSET_VERSION_MINOR = 8
    OFFSET_AUTH_BLOCK_SIZE = 12
    OFFSET_AUX_BLOCK_SIZE = 20
    OFFSET_ALGORITHM = 28
    OFFSET_HASH_OFFSET = 32
    OFFSET_HASH_SIZE = 40
    OFFSET_SIG_OFFSET = 48
    OFFSET_SIG_SIZE = 56
    OFFSET_PUBKEY_OFFSET = 64
    OFFSET_PUBKEY_SIZE = 72
    
    HEADER_SIZE = 256
    
    def __init__(self, input_path: str):
        self.input_path = Path(input_path)
        
    def patch(self, output_path: str, disable_verity: bool = False, 
              disable_verification: bool = False,
              reset_flags: bool = False,
              signer: Optional['AvbSigner'] = None,
              force_chained: bool = False) -> tuple[bool, str]:
        """Patch vbmeta and optionally re-sign with custom key.
        
        Args:
            output_path: Where to save the patched vbmeta
            disable_verity: Set the HASHTREE_DISABLED flag
            disable_verification: Set the VERIFICATION_DISABLED flag
            reset_flags: Reset ALL flags to 0 (restore stock behavior)
            signer: Optional AvbSigner for re-signing with custom key
            force_chained: Force patching even if this is a chained vbmeta (DANGEROUS)
            
        Returns:
            (success: bool, message: str)
            Message explains what happened or why it was skipped
        """
        if not disable_verity and not disable_verification and not reset_flags and not signer:
            # Nothing to do, just copy
            import shutil
            shutil.copy2(self.input_path, output_path)
            return True, ""
        
        try:
            # Check if this is a chained vbmeta (vbmeta_system, vbmeta_vendor)
            is_main, chain_parts = self.is_main_vbmeta(str(self.input_path))
            filename = self.input_path.name.lower()
            
            if not is_main and (disable_verity or disable_verification):
                # This is a chained vbmeta - DO NOT PATCH IT
                # Patching chained vbmetas causes boot loops on many devices
                if not force_chained:
                    msg = (
                        f"⏭️ SKIPPED: '{self.input_path.name}' is a chained vbmeta.\n"
                        "   Patching chained vbmetas (vbmeta_system, vbmeta_vendor) causes\n"
                        "   BOOT LOOPS on many devices. Only the main vbmeta.img needs patching.\n"
                        "   The main vbmeta controls verification for all chained images."
                    )
                    logger.info(f"Skipped chained vbmeta: {filename} (would cause boot loop)")
                    return False, msg
                else:
                    logger.warning(f"Force-patching chained vbmeta: {filename} (user override)")
            elif is_main and chain_parts:
                # This is the main vbmeta with chain partitions - good to patch
                logger.info(f"Main vbmeta detected - chains to: {', '.join(chain_parts)}")
            
            # Read original vbmeta
            with open(self.input_path, 'rb') as f:
                data = bytearray(f.read())
            
            # Verify magic
            if data[:4] != AVB_MAGIC:
                logger.error("Invalid vbmeta magic")
                return False
            
            # Read current flags (big-endian 4 bytes at offset 120)
            current_flags = struct.unpack('>I', data[self.FLAGS_OFFSET:self.FLAGS_OFFSET+4])[0]
            
            # Apply new flags
            changes = []
            if reset_flags:
                # Reset all flags to 0 (restore stock verification)
                new_flags = 0
                changes.append("flags reset to stock (0x00)")
            else:
                new_flags = current_flags
                if disable_verity:
                    new_flags |= self.FLAG_DISABLE_VERITY
                    changes.append("verity disabled")
                if disable_verification:
                    new_flags |= self.FLAG_DISABLE_VERIFICATION
                    changes.append("verification disabled")
            
            # Write new flags
            data[self.FLAGS_OFFSET:self.FLAGS_OFFSET+4] = struct.pack('>I', new_flags)
            
            # Re-sign if signer provided
            if signer:
                data = self._resign_vbmeta(data, signer)
                if data is None:
                    return False, "Failed to re-sign vbmeta"
                changes.append("re-signed with custom key")
            
            # Save patched vbmeta
            with open(output_path, 'wb') as f:
                f.write(data)
            
            logger.info(f"Patched vbmeta: {', '.join(changes)}")
            logger.info(f"Original flags: 0x{current_flags:08X} -> New flags: 0x{new_flags:08X}")
            
            return True, ""
            
        except Exception as e:
            logger.error(f"Failed to patch vbmeta: {e}")
            return False, str(e)
    
    def _resign_vbmeta(self, data: bytearray, signer: 'AvbSigner') -> Optional[bytearray]:
        """Re-sign vbmeta with custom key.
        
        This completely rebuilds the authentication block with:
        - New hash of header + auxiliary data
        - New signature using the custom key
        - New public key blob
        """
        try:
            logger.info("Re-signing vbmeta with custom key...")
            
            # Read header fields
            auth_block_size = struct.unpack('>Q', data[self.OFFSET_AUTH_BLOCK_SIZE:self.OFFSET_AUTH_BLOCK_SIZE+8])[0]
            aux_block_size = struct.unpack('>Q', data[self.OFFSET_AUX_BLOCK_SIZE:self.OFFSET_AUX_BLOCK_SIZE+8])[0]
            original_algorithm = struct.unpack('>I', data[self.OFFSET_ALGORITHM:self.OFFSET_ALGORITHM+4])[0]
            
            # Determine new algorithm based on key size
            new_algorithm = signer.get_algorithm_for_key_size(use_sha512=(original_algorithm >= 4))
            alg_info = signer.ALGORITHM_INFO[new_algorithm]
            
            # Get the auxiliary data (descriptors, etc.)
            aux_start = self.HEADER_SIZE + auth_block_size
            aux_data = bytes(data[aux_start:aux_start + aux_block_size])
            
            # Prepare new public key blob
            pubkey_blob = signer.get_avb_public_key_blob()
            pubkey_size = len(pubkey_blob)
            
            # Calculate new sizes
            hash_size = alg_info['hash_size']
            sig_size = alg_info['sig_size']
            
            # Authentication block layout:
            # [hash] [padding to 8-byte align] [signature] [padding] [public key] [padding]
            hash_offset = 0
            sig_offset = ((hash_size + 7) // 8) * 8  # Align to 8 bytes
            pubkey_offset = sig_offset + ((sig_size + 7) // 8) * 8
            new_auth_block_size = pubkey_offset + ((pubkey_size + 7) // 8) * 8
            
            # Update header with new values
            new_header = bytearray(data[:self.HEADER_SIZE])
            
            # Update algorithm
            new_header[self.OFFSET_ALGORITHM:self.OFFSET_ALGORITHM+4] = struct.pack('>I', new_algorithm)
            
            # Update hash info
            new_header[self.OFFSET_HASH_OFFSET:self.OFFSET_HASH_OFFSET+8] = struct.pack('>Q', hash_offset)
            new_header[self.OFFSET_HASH_SIZE:self.OFFSET_HASH_SIZE+8] = struct.pack('>Q', hash_size)
            
            # Update signature info
            new_header[self.OFFSET_SIG_OFFSET:self.OFFSET_SIG_OFFSET+8] = struct.pack('>Q', sig_offset)
            new_header[self.OFFSET_SIG_SIZE:self.OFFSET_SIG_SIZE+8] = struct.pack('>Q', sig_size)
            
            # Update public key info
            new_header[self.OFFSET_PUBKEY_OFFSET:self.OFFSET_PUBKEY_OFFSET+8] = struct.pack('>Q', pubkey_offset)
            new_header[self.OFFSET_PUBKEY_SIZE:self.OFFSET_PUBKEY_SIZE+8] = struct.pack('>Q', pubkey_size)
            
            # Update auth block size
            new_header[self.OFFSET_AUTH_BLOCK_SIZE:self.OFFSET_AUTH_BLOCK_SIZE+8] = struct.pack('>Q', new_auth_block_size)
            
            # Compute hash over header + auxiliary data
            data_to_hash = bytes(new_header) + aux_data
            hash_digest = signer.compute_hash(data_to_hash, new_algorithm)
            
            # Sign the hash
            signature = signer.sign_data(data_to_hash, new_algorithm)
            
            # Build new authentication block
            new_auth_block = bytearray(new_auth_block_size)
            new_auth_block[hash_offset:hash_offset+hash_size] = hash_digest
            new_auth_block[sig_offset:sig_offset+sig_size] = signature
            new_auth_block[pubkey_offset:pubkey_offset+pubkey_size] = pubkey_blob
            
            # Assemble final vbmeta
            result = bytearray()
            result.extend(new_header)
            result.extend(new_auth_block)
            result.extend(aux_data)
            
            # Pad to original size if needed (some tools expect specific sizes)
            original_size = len(data)
            if len(result) < original_size:
                result.extend(b'\x00' * (original_size - len(result)))
            
            logger.info(f"  Algorithm: {new_algorithm} (RSA-{signer.key_bits})")
            logger.info(f"  Hash size: {hash_size} bytes")
            logger.info(f"  Signature size: {sig_size} bytes")
            logger.info(f"  Public key size: {pubkey_size} bytes")
            logger.info(f"  New auth block size: {new_auth_block_size} bytes")
            
            return result
            
        except Exception as e:
            logger.exception(f"Failed to re-sign vbmeta: {e}")
            return None
    
    @staticmethod
    def get_current_flags(input_path: str) -> dict:
        """Read current flag status from a vbmeta file."""
        try:
            with open(input_path, 'rb') as f:
                magic = f.read(4)
                if magic != AVB_MAGIC:
                    return {'error': 'Not a valid vbmeta file'}
                
                f.seek(VbmetaPatcher.FLAGS_OFFSET)
                flags = struct.unpack('>I', f.read(4))[0]
                
                return {
                    'raw_flags': flags,
                    'verity_disabled': bool(flags & VbmetaPatcher.FLAG_DISABLE_VERITY),
                    'verification_disabled': bool(flags & VbmetaPatcher.FLAG_DISABLE_VERIFICATION),
                }
        except Exception as e:
            return {'error': str(e)}
    
    @staticmethod
    def is_main_vbmeta(input_path: str) -> tuple[bool, list[str]]:
        """Check if this is the main vbmeta (has CHAIN descriptors) vs a chained vbmeta.
        
        The main vbmeta.img contains CHAIN_PARTITION descriptors pointing to
        vbmeta_system, vbmeta_vendor, boot, etc.
        
        Chained vbmetas (vbmeta_system.img, vbmeta_vendor.img) only have 
        PROPERTY and HASHTREE descriptors.
        
        Returns:
            (is_main: bool, chain_partitions: list[str])
            
        Note: Only the main vbmeta.img should be patched with VERIFICATION_DISABLED.
        Patching chained vbmetas invalidates their signatures but the bootloader
        may still verify them, causing boot loops on some devices.
        """
        try:
            with open(input_path, 'rb') as f:
                data = f.read(8192)  # Read enough for header + descriptors
            
            if data[:4] != AVB_MAGIC:
                return False, []
            
            auth_size = struct.unpack('>Q', data[12:20])[0]
            aux_size = struct.unpack('>Q', data[20:28])[0]
            aux_start = 256 + auth_size
            
            chain_partitions = []
            pos = aux_start
            
            while pos < aux_start + aux_size and pos + 16 <= len(data):
                tag = struct.unpack('>Q', data[pos:pos+8])[0]
                size = struct.unpack('>Q', data[pos+8:pos+16])[0]
                
                if size == 0 or size > 50000:
                    break
                
                if tag == 4:  # CHAIN_PARTITION descriptor
                    desc_data = data[pos+16:pos+16+min(size, 200)]
                    if len(desc_data) >= 80:
                        name_len = struct.unpack('>I', desc_data[4:8])[0]
                        # Partition name at offset 76 (12 bytes header + 64 bytes reserved)
                        if name_len > 0 and len(desc_data) >= 76 + name_len:
                            name = desc_data[76:76+name_len].decode('utf-8', errors='replace').rstrip('\x00')
                            if name:
                                chain_partitions.append(name)
                
                pos += 16 + ((size + 7) & ~7)
            
            return len(chain_partitions) > 0, chain_partitions
            
        except Exception as e:
            logger.debug(f"Error checking vbmeta type: {e}")
            return False, []


# =============================================================================
# IMAGE REPACKAGING CLASSES
# =============================================================================

class BootImagePacker:
    """Pack boot.img / recovery.img / vendor_boot.img from components.
    
    Supports:
    - Boot image v0-v4 formats (same format for recovery.img)
    - vendor_boot image v3-v4 formats
    - Custom kernel, ramdisk, DTB
    - Cmdline modification
    
    Note: boot.img and recovery.img use identical formats.
    The difference is the ramdisk contents (boot vs recovery init).
    """
    
    BOOT_MAGIC = b'ANDROID!'
    VENDOR_BOOT_MAGIC = b'VNDRBOOT'
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
        self.header_version = 2  # Default to v2
    
    def pack_boot_image(self, output_path: str, 
                        kernel: Optional[str] = None,
                        ramdisk: Optional[str] = None,
                        second: Optional[str] = None,
                        dtb: Optional[str] = None,
                        recovery_dtbo: Optional[str] = None,
                        cmdline: str = "",
                        extra_cmdline: str = "",
                        base_addr: int = 0x10000000,
                        kernel_offset: int = 0x00008000,
                        ramdisk_offset: int = 0x01000000,
                        second_offset: int = 0x00F00000,
                        tags_offset: int = 0x00000100,
                        dtb_offset: int = 0x01F00000,
                        page_size: int = 4096,
                        os_version: int = 0,
                        header_version: int = 2,
                        board_name: str = "") -> bool:
        """Pack a boot image from components.
        
        Args:
            output_path: Output boot.img path
            kernel: Path to kernel (zImage/Image.gz)
            ramdisk: Path to ramdisk.cpio or ramdisk.img
            second: Path to second stage bootloader (optional)
            dtb: Path to DTB (device tree blob)
            recovery_dtbo: Path to recovery DTBO (v1-v2)
            cmdline: Kernel command line
            extra_cmdline: Extra cmdline (for v3+)
            base_addr: Base address
            kernel_offset: Kernel load offset from base
            ramdisk_offset: Ramdisk load offset from base
            second_offset: Second bootloader offset
            tags_offset: Kernel tags offset
            dtb_offset: DTB offset (v2+)
            page_size: Page size (2048/4096)
            os_version: OS version packed value
            header_version: Boot image header version (0-4)
            board_name: Board/product name
            
        Returns:
            True if successful
        """
        self.header_version = header_version
        
        try:
            logger.info(f"Packing boot image v{header_version}...")
            
            # Read component files
            kernel_data = self._read_file(kernel) if kernel else b''
            ramdisk_data = self._read_file(ramdisk) if ramdisk else b''
            second_data = self._read_file(second) if second else b''
            dtb_data = self._read_file(dtb) if dtb else b''
            recovery_dtbo_data = self._read_file(recovery_dtbo) if recovery_dtbo else b''
            
            if header_version >= 3:
                # v3/v4 format - simplified header
                return self._pack_v3_v4(output_path, kernel_data, ramdisk_data,
                                        cmdline, os_version, header_version, page_size)
            else:
                # v0-v2 format - traditional header
                return self._pack_v0_v2(output_path, kernel_data, ramdisk_data,
                                        second_data, dtb_data, recovery_dtbo_data,
                                        cmdline, base_addr, kernel_offset,
                                        ramdisk_offset, second_offset, tags_offset,
                                        dtb_offset, page_size, os_version,
                                        header_version, board_name)
        except Exception as e:
            logger.error(f"Failed to pack boot image: {e}")
            return False
    
    def _read_file(self, path: str) -> bytes:
        """Read file contents."""
        with open(path, 'rb') as f:
            return f.read()
    
    def _pad_to_page(self, data: bytes, page_size: int) -> bytes:
        """Pad data to page boundary."""
        if len(data) % page_size == 0:
            return data
        padding = page_size - (len(data) % page_size)
        return data + b'\x00' * padding
    
    def _pack_v0_v2(self, output_path: str, kernel: bytes, ramdisk: bytes,
                    second: bytes, dtb: bytes, recovery_dtbo: bytes,
                    cmdline: str, base_addr: int, kernel_offset: int,
                    ramdisk_offset: int, second_offset: int, tags_offset: int,
                    dtb_offset: int, page_size: int, os_version: int,
                    header_version: int, board_name: str) -> bool:
        """Pack v0-v2 boot image."""
        
        # Build header (1648 bytes for v2, padded to page_size)
        header = bytearray(1648)
        
        # Magic
        header[0:8] = self.BOOT_MAGIC
        
        # Kernel info
        struct.pack_into('<I', header, 8, len(kernel))  # kernel_size
        struct.pack_into('<I', header, 12, base_addr + kernel_offset)  # kernel_addr
        
        # Ramdisk info
        struct.pack_into('<I', header, 16, len(ramdisk))  # ramdisk_size
        struct.pack_into('<I', header, 20, base_addr + ramdisk_offset)  # ramdisk_addr
        
        # Second bootloader
        struct.pack_into('<I', header, 24, len(second))  # second_size
        struct.pack_into('<I', header, 28, base_addr + second_offset)  # second_addr
        
        # Tags
        struct.pack_into('<I', header, 32, base_addr + tags_offset)  # tags_addr
        
        # Page size
        struct.pack_into('<I', header, 36, page_size)
        
        # Header version
        struct.pack_into('<I', header, 40, header_version)
        
        # OS version
        struct.pack_into('<I', header, 44, os_version)
        
        # Board name (16 bytes)
        board_bytes = board_name.encode('utf-8')[:16]
        header[48:48+len(board_bytes)] = board_bytes
        
        # Cmdline (512 bytes)
        cmdline_bytes = cmdline.encode('utf-8')[:512]
        header[64:64+len(cmdline_bytes)] = cmdline_bytes
        
        # ID/hash placeholder (32 bytes at offset 576)
        
        # Extra cmdline (1024 bytes at offset 608)
        
        if header_version >= 1:
            # Recovery DTBO (v1+)
            struct.pack_into('<I', header, 1632, len(recovery_dtbo))
            # recovery_dtbo_offset calculated later
            struct.pack_into('<I', header, 1640, 1648)  # header_size
        
        if header_version >= 2:
            # DTB (v2)
            struct.pack_into('<I', header, 1644, len(dtb))
            # dtb_addr
            struct.pack_into('<Q', header, 1648 - 8, base_addr + dtb_offset) if len(header) > 1648 else None
        
        # Calculate offsets
        header_pages = (len(header) + page_size - 1) // page_size
        kernel_pages = (len(kernel) + page_size - 1) // page_size if kernel else 0
        ramdisk_pages = (len(ramdisk) + page_size - 1) // page_size if ramdisk else 0
        second_pages = (len(second) + page_size - 1) // page_size if second else 0
        
        # Recovery DTBO offset (after second)
        if header_version >= 1 and recovery_dtbo:
            recovery_offset = (header_pages + kernel_pages + ramdisk_pages + second_pages) * page_size
            struct.pack_into('<Q', header, 1636, recovery_offset)
        
        # Write output
        with open(output_path, 'wb') as f:
            # Header (padded)
            f.write(self._pad_to_page(bytes(header[:1648]), page_size))
            
            # Kernel
            if kernel:
                f.write(self._pad_to_page(kernel, page_size))
            
            # Ramdisk
            if ramdisk:
                f.write(self._pad_to_page(ramdisk, page_size))
            
            # Second
            if second:
                f.write(self._pad_to_page(second, page_size))
            
            # Recovery DTBO (v1+)
            if header_version >= 1 and recovery_dtbo:
                f.write(self._pad_to_page(recovery_dtbo, page_size))
            
            # DTB (v2)
            if header_version >= 2 and dtb:
                f.write(self._pad_to_page(dtb, page_size))
        
        logger.info(f"Packed boot image v{header_version}: {output_path}")
        logger.info(f"  Kernel: {len(kernel)} bytes")
        logger.info(f"  Ramdisk: {len(ramdisk)} bytes")
        if dtb:
            logger.info(f"  DTB: {len(dtb)} bytes")
        
        return True
    
    def _pack_v3_v4(self, output_path: str, kernel: bytes, ramdisk: bytes,
                    cmdline: str, os_version: int, header_version: int,
                    page_size: int) -> bool:
        """Pack v3/v4 boot image."""
        
        # v3/v4 header is always 4096 bytes, page_size is always 4096
        page_size = 4096
        header = bytearray(4096)
        
        # Magic
        header[0:8] = self.BOOT_MAGIC
        
        # Kernel size
        struct.pack_into('<I', header, 8, len(kernel))
        
        # Ramdisk size
        struct.pack_into('<I', header, 12, len(ramdisk))
        
        # OS version
        struct.pack_into('<I', header, 16, os_version)
        
        # Header size
        struct.pack_into('<I', header, 20, 4096)
        
        # Reserved (4 words)
        
        # Header version
        struct.pack_into('<I', header, 40, header_version)
        
        # Cmdline (1536 bytes at offset 44)
        cmdline_bytes = cmdline.encode('utf-8')[:1536]
        header[44:44+len(cmdline_bytes)] = cmdline_bytes
        
        if header_version == 4:
            # v4 adds signature size at offset 1580
            struct.pack_into('<I', header, 1580, 0)  # No signature for now
        
        # Write output
        with open(output_path, 'wb') as f:
            # Header
            f.write(bytes(header))
            
            # Kernel
            f.write(self._pad_to_page(kernel, page_size))
            
            # Ramdisk
            if ramdisk:
                f.write(self._pad_to_page(ramdisk, page_size))
        
        logger.info(f"Packed boot image v{header_version}: {output_path}")
        logger.info(f"  Kernel: {len(kernel)} bytes")
        logger.info(f"  Ramdisk: {len(ramdisk)} bytes")
        
        return True
    
    def pack_vendor_boot(self, output_path: str,
                         ramdisk: Optional[str] = None,
                         dtb: Optional[str] = None,
                         vendor_cmdline: str = "",
                         base_addr: int = 0x00000000,
                         page_size: int = 4096,
                         kernel_addr: int = 0x00008000,
                         ramdisk_addr: int = 0x01000000,
                         dtb_addr: int = 0x01F00000,
                         tags_addr: int = 0x00000100,
                         board_name: str = "",
                         header_version: int = 3,
                         ramdisk_fragments: Optional[list[str]] = None) -> bool:
        """Pack a vendor_boot image.
        
        Args:
            output_path: Output vendor_boot.img path
            ramdisk: Path to vendor ramdisk
            dtb: Path to DTB
            vendor_cmdline: Vendor kernel cmdline
            header_version: 3 or 4
            ramdisk_fragments: List of ramdisk fragment paths (v4)
            
        Returns:
            True if successful
        """
        try:
            logger.info(f"Packing vendor_boot image v{header_version}...")
            
            ramdisk_data = self._read_file(ramdisk) if ramdisk else b''
            dtb_data = self._read_file(dtb) if dtb else b''
            
            # Read ramdisk fragments (v4)
            fragments_data = []
            if header_version == 4 and ramdisk_fragments:
                for frag_path in ramdisk_fragments:
                    fragments_data.append(self._read_file(frag_path))
            
            # Build header
            header_size = 2112 if header_version == 3 else 2128
            header = bytearray(header_size)
            
            # Magic
            header[0:8] = self.VENDOR_BOOT_MAGIC
            
            # Header version
            struct.pack_into('<I', header, 8, header_version)
            
            # Page size
            struct.pack_into('<I', header, 12, page_size)
            
            # Addresses
            struct.pack_into('<I', header, 16, kernel_addr)
            struct.pack_into('<I', header, 20, ramdisk_addr)
            
            # Ramdisk size
            struct.pack_into('<I', header, 24, len(ramdisk_data))
            
            # Cmdline (2048 bytes at offset 28)
            cmdline_bytes = vendor_cmdline.encode('utf-8')[:2048]
            header[28:28+len(cmdline_bytes)] = cmdline_bytes
            
            # Tags addr
            struct.pack_into('<I', header, 2076, tags_addr)
            
            # Board name (16 bytes at offset 2080)
            board_bytes = board_name.encode('utf-8')[:16]
            header[2080:2080+len(board_bytes)] = board_bytes
            
            # Header size
            struct.pack_into('<I', header, 2096, header_size)
            
            # DTB size
            struct.pack_into('<I', header, 2100, len(dtb_data))
            
            # DTB addr
            struct.pack_into('<Q', header, 2104, dtb_addr)
            
            if header_version == 4:
                # v4: vendor ramdisk table
                total_frag_size = sum(len(f) for f in fragments_data)
                struct.pack_into('<I', header, 2112, total_frag_size)
                struct.pack_into('<I', header, 2116, len(fragments_data))  # entry count
                struct.pack_into('<I', header, 2120, 16)  # entry size
                # bootconfig size at 2124
            
            # Write output
            with open(output_path, 'wb') as f:
                # Header (padded)
                f.write(self._pad_to_page(bytes(header), page_size))
                
                # Ramdisk
                if ramdisk_data:
                    f.write(self._pad_to_page(ramdisk_data, page_size))
                
                # DTB
                if dtb_data:
                    f.write(self._pad_to_page(dtb_data, page_size))
                
                # Ramdisk fragments (v4)
                for frag in fragments_data:
                    f.write(self._pad_to_page(frag, page_size))
            
            logger.info(f"Packed vendor_boot v{header_version}: {output_path}")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to pack vendor_boot: {e}")
            return False


class SparseImageCreator:
    """Create Android sparse images from raw images.
    
    Sparse format is used for faster flashing by skipping zero blocks.
    """
    
    SPARSE_MAGIC = 0xED26FF3A
    CHUNK_TYPE_RAW = 0xCAC1
    CHUNK_TYPE_FILL = 0xCAC2
    CHUNK_TYPE_DONT_CARE = 0xCAC3
    CHUNK_TYPE_CRC32 = 0xCAC4
    
    SPARSE_HEADER_SIZE = 28
    CHUNK_HEADER_SIZE = 12
    
    def __init__(self, block_size: int = 4096, progress_callback: Optional[Callable] = None):
        self.block_size = block_size
        self.progress_callback = progress_callback
    
    def convert(self, input_path: str, output_path: str, 
                max_chunk_size: int = 256 * 1024 * 1024) -> bool:
        """Convert a raw image to sparse format.
        
        Args:
            input_path: Path to raw image
            output_path: Path for sparse output
            max_chunk_size: Maximum size of data chunks
            
        Returns:
            True if successful
        """
        try:
            input_size = os.path.getsize(input_path)
            total_blocks = (input_size + self.block_size - 1) // self.block_size
            
            logger.info(f"Converting to sparse: {input_path}")
            logger.info(f"  Input size: {input_size / (1024*1024):.2f} MB")
            logger.info(f"  Block size: {self.block_size}")
            logger.info(f"  Total blocks: {total_blocks}")
            
            # First pass: analyze blocks
            chunks = self._analyze_blocks(input_path, total_blocks)
            
            logger.info(f"  Chunks identified: {len(chunks)}")
            
            # Second pass: write sparse image
            self._write_sparse(input_path, output_path, chunks, total_blocks)
            
            output_size = os.path.getsize(output_path)
            ratio = (1 - output_size / input_size) * 100 if input_size > 0 else 0
            logger.info(f"  Output size: {output_size / (1024*1024):.2f} MB ({ratio:.1f}% reduction)")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to create sparse image: {e}")
            return False
    
    def _analyze_blocks(self, input_path: str, total_blocks: int) -> list[dict]:
        """Analyze blocks and identify chunk boundaries."""
        chunks = []
        zero_block = b'\x00' * self.block_size
        
        with open(input_path, 'rb') as f:
            current_chunk = None
            processed = 0
            
            for block_num in range(total_blocks):
                block = f.read(self.block_size)
                if len(block) < self.block_size:
                    block = block + b'\x00' * (self.block_size - len(block))
                
                # Check if block is all zeros
                is_zero = (block == zero_block)
                
                # Check if block is a fill pattern (all same 4-byte value)
                is_fill = False
                fill_value = 0
                if not is_zero and len(set(block[i:i+4] for i in range(0, len(block), 4))) == 1:
                    is_fill = True
                    fill_value = struct.unpack('<I', block[:4])[0]
                
                if is_zero:
                    chunk_type = 'dont_care'
                elif is_fill:
                    chunk_type = 'fill'
                else:
                    chunk_type = 'raw'
                
                # Continue or start new chunk
                if current_chunk is None:
                    current_chunk = {
                        'type': chunk_type,
                        'start_block': block_num,
                        'block_count': 1,
                        'fill_value': fill_value if is_fill else 0
                    }
                elif (current_chunk['type'] == chunk_type and 
                      (chunk_type != 'fill' or current_chunk['fill_value'] == fill_value)):
                    current_chunk['block_count'] += 1
                else:
                    chunks.append(current_chunk)
                    current_chunk = {
                        'type': chunk_type,
                        'start_block': block_num,
                        'block_count': 1,
                        'fill_value': fill_value if is_fill else 0
                    }
                
                processed += 1
                if self.progress_callback and processed % 1000 == 0:
                    self.progress_callback(processed, total_blocks, "Analyzing blocks...")
            
            if current_chunk:
                chunks.append(current_chunk)
        
        return chunks
    
    def _write_sparse(self, input_path: str, output_path: str, 
                      chunks: list[dict], total_blocks: int):
        """Write sparse image from chunk analysis."""
        
        with open(output_path, 'wb') as out_f:
            # Write sparse header
            header = struct.pack('<IHHHHIIII',
                self.SPARSE_MAGIC,  # magic
                1, 0,  # version major, minor
                self.SPARSE_HEADER_SIZE,  # file_hdr_sz
                self.CHUNK_HEADER_SIZE,  # chunk_hdr_sz
                self.block_size,  # blk_sz
                total_blocks,  # total_blks
                len(chunks),  # total_chunks
                0  # image_checksum (not calculated)
            )
            out_f.write(header)
            
            # Write chunks
            with open(input_path, 'rb') as in_f:
                for i, chunk in enumerate(chunks):
                    if chunk['type'] == 'raw':
                        self._write_raw_chunk(in_f, out_f, chunk)
                    elif chunk['type'] == 'fill':
                        self._write_fill_chunk(out_f, chunk)
                    elif chunk['type'] == 'dont_care':
                        self._write_dont_care_chunk(out_f, chunk)
                    
                    if self.progress_callback and i % 100 == 0:
                        self.progress_callback(i, len(chunks), "Writing sparse image...")
    
    def _write_raw_chunk(self, in_f: BinaryIO, out_f: BinaryIO, chunk: dict):
        """Write a raw data chunk."""
        data_size = chunk['block_count'] * self.block_size
        
        # Chunk header
        header = struct.pack('<HHII',
            self.CHUNK_TYPE_RAW,
            0,  # reserved
            chunk['block_count'],
            self.CHUNK_HEADER_SIZE + data_size
        )
        out_f.write(header)
        
        # Data
        in_f.seek(chunk['start_block'] * self.block_size)
        remaining = data_size
        while remaining > 0:
            read_size = min(remaining, 1024 * 1024)  # 1MB chunks
            data = in_f.read(read_size)
            out_f.write(data)
            remaining -= len(data)
    
    def _write_fill_chunk(self, out_f: BinaryIO, chunk: dict):
        """Write a fill chunk."""
        # Chunk header
        header = struct.pack('<HHII',
            self.CHUNK_TYPE_FILL,
            0,  # reserved
            chunk['block_count'],
            self.CHUNK_HEADER_SIZE + 4
        )
        out_f.write(header)
        
        # Fill value (4 bytes)
        out_f.write(struct.pack('<I', chunk['fill_value']))
    
    def _write_dont_care_chunk(self, out_f: BinaryIO, chunk: dict):
        """Write a don't care (skip) chunk."""
        # Chunk header
        header = struct.pack('<HHII',
            self.CHUNK_TYPE_DONT_CARE,
            0,  # reserved
            chunk['block_count'],
            self.CHUNK_HEADER_SIZE
        )
        out_f.write(header)


class VbmetaCreator:
    """Create vbmeta images from scratch or from descriptor configuration.
    
    Useful for:
    - Creating custom vbmeta for modified partitions
    - Building vbmeta for custom ROMs
    """
    
    def __init__(self, signer: Optional['AvbSigner'] = None):
        self.signer = signer
    
    def create_empty_vbmeta(self, output_path: str, 
                            disable_verity: bool = True,
                            disable_verification: bool = True,
                            rollback_index: int = 0,
                            release_string: str = "avbtool 1.2.0") -> bool:
        """Create an empty/disabled vbmeta image.
        
        This creates a minimal vbmeta that effectively disables AVB.
        Useful for custom ROMs that don't need verification.
        
        Args:
            output_path: Output vbmeta.img path
            disable_verity: Set HASHTREE_DISABLED flag
            disable_verification: Set VERIFICATION_DISABLED flag
            rollback_index: Rollback index value
            release_string: Release string embedded in header
            
        Returns:
            True if successful
        """
        try:
            logger.info("Creating empty vbmeta image...")
            
            # Calculate flags
            flags = 0
            if disable_verity:
                flags |= 0x01  # AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED
            if disable_verification:
                flags |= 0x02  # AVB_VBMETA_IMAGE_FLAGS_VERIFICATION_DISABLED
            
            # Determine algorithm
            if self.signer and self.signer.private_key:
                algorithm_id = self.signer.get_algorithm_for_key_size()
                pubkey_blob = self.signer.get_avb_public_key_blob()
            else:
                algorithm_id = 0  # ALG_NONE
                pubkey_blob = b''
            
            # Header is 256 bytes
            header = bytearray(256)
            
            # Magic
            header[0:4] = AVB_MAGIC
            
            # Version (1.2)
            struct.pack_into('>I', header, 4, 1)  # major
            struct.pack_into('>I', header, 8, 2)  # minor
            
            # For unsigned/disabled vbmeta, we have no auth block or aux block
            auth_block_size = 0
            aux_block_size = 0
            
            if algorithm_id != 0:
                # Calculate sizes for signed vbmeta
                alg_info = AvbSigner.ALGORITHM_INFO[algorithm_id]
                hash_size = alg_info['hash_size']
                sig_size = alg_info['sig_size']
                
                # Authentication block layout
                hash_offset = 0
                sig_offset = ((hash_size + 7) // 8) * 8
                pubkey_offset = sig_offset + ((sig_size + 7) // 8) * 8
                auth_block_size = pubkey_offset + ((len(pubkey_blob) + 7) // 8) * 8
            
            struct.pack_into('>Q', header, 12, auth_block_size)  # auth_block_size
            struct.pack_into('>Q', header, 20, aux_block_size)   # aux_block_size
            
            # Algorithm
            struct.pack_into('>I', header, 28, algorithm_id)
            
            if algorithm_id != 0:
                # Hash/sig/pubkey offsets
                struct.pack_into('>Q', header, 32, hash_offset)
                struct.pack_into('>Q', header, 40, hash_size)
                struct.pack_into('>Q', header, 48, sig_offset)
                struct.pack_into('>Q', header, 56, sig_size)
                struct.pack_into('>Q', header, 64, pubkey_offset)
                struct.pack_into('>Q', header, 72, len(pubkey_blob))
            
            # Rollback index
            struct.pack_into('>Q', header, 112, rollback_index)
            
            # Flags
            struct.pack_into('>I', header, 120, flags)
            
            # Rollback index location
            struct.pack_into('>I', header, 124, 0)
            
            # Release string (47 bytes + null at offset 128)
            release_bytes = release_string.encode('utf-8')[:47]
            header[128:128+len(release_bytes)] = release_bytes
            
            # Build authentication block if signing
            auth_block = b''
            if algorithm_id != 0 and self.signer:
                # Compute hash over header (+ aux block, but it's empty)
                data_to_hash = bytes(header)
                hash_digest = self.signer.compute_hash(data_to_hash, algorithm_id)
                signature = self.signer.sign_data(data_to_hash, algorithm_id)
                
                auth_block = bytearray(auth_block_size)
                auth_block[hash_offset:hash_offset+hash_size] = hash_digest
                auth_block[sig_offset:sig_offset+sig_size] = signature
                auth_block[pubkey_offset:pubkey_offset+len(pubkey_blob)] = pubkey_blob
            
            # Write output (pad to 4KB or 64KB for flashing)
            min_size = 4096
            total_size = 256 + auth_block_size + aux_block_size
            if total_size < min_size:
                padding = min_size - total_size
            else:
                padding = (4096 - (total_size % 4096)) % 4096
            
            with open(output_path, 'wb') as f:
                f.write(bytes(header))
                if auth_block:
                    f.write(bytes(auth_block))
                f.write(b'\x00' * padding)
            
            output_size = os.path.getsize(output_path)
            logger.info(f"Created vbmeta: {output_path}")
            logger.info(f"  Size: {output_size} bytes")
            logger.info(f"  Flags: 0x{flags:08X}")
            logger.info(f"  Algorithm: {algorithm_id} ({'signed' if algorithm_id else 'unsigned'})")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to create vbmeta: {e}")
            return False


class RamdiskPacker:
    """Create ramdisk images from directories.
    
    Supports:
    - cpio newc format (standard Android ramdisk)
    - gzip, lz4 compression
    """
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
    
    def pack(self, input_dir: str, output_path: str, 
             compression: str = 'gzip') -> bool:
        """Pack a directory into a ramdisk image.
        
        Args:
            input_dir: Directory containing ramdisk contents
            output_path: Output ramdisk path
            compression: 'gzip', 'lz4', or 'none'
            
        Returns:
            True if successful
        """
        try:
            logger.info(f"Packing ramdisk from: {input_dir}")
            
            # Create cpio archive
            cpio_data = self._create_cpio(input_dir)
            
            if not cpio_data:
                logger.error("Failed to create cpio archive")
                return False
            
            logger.info(f"  CPIO size: {len(cpio_data)} bytes")
            
            # Compress
            if compression == 'gzip':
                compressed = gzip.compress(cpio_data)
            elif compression == 'lz4':
                try:
                    import lz4.frame  # type: ignore
                    compressed = lz4.frame.compress(cpio_data)
                except ImportError:
                    logger.warning("lz4 not available, using gzip")
                    compressed = gzip.compress(cpio_data)
            else:
                compressed = cpio_data
            
            # Write output
            with open(output_path, 'wb') as f:
                f.write(compressed)
            
            logger.info(f"  Compressed size: {len(compressed)} bytes")
            logger.info(f"  Output: {output_path}")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to pack ramdisk: {e}")
            return False
    
    def _create_cpio(self, input_dir: str) -> bytes:
        """Create a cpio newc format archive."""
        output = io.BytesIO()
        ino = 0
        input_path = Path(input_dir)
        
        # Collect all files and directories
        entries = []
        for path in sorted(input_path.rglob('*')):
            rel_path = path.relative_to(input_path)
            entries.append((str(rel_path), path))
        
        # Also add directories
        for path in sorted(input_path.rglob('*')):
            if path.is_dir():
                rel_path = path.relative_to(input_path)
                # Already added in rglob
        
        # Add root directory entries
        dirs_added = set()
        full_entries = []
        for rel_str, path in entries:
            # Add parent directories first
            parts = Path(rel_str).parts
            for i in range(len(parts) - 1):
                dir_path = '/'.join(parts[:i+1])
                if dir_path not in dirs_added:
                    dirs_added.add(dir_path)
                    dir_full = input_path / dir_path
                    if dir_full.is_dir():
                        full_entries.append((dir_path, dir_full))
            full_entries.append((rel_str, path))
        
        # Remove duplicates while preserving order
        seen = set()
        unique_entries = []
        for rel_str, path in full_entries:
            if rel_str not in seen:
                seen.add(rel_str)
                unique_entries.append((rel_str, path))
        
        for rel_str, path in unique_entries:
            ino += 1
            self._write_cpio_entry(output, rel_str, path, ino)
            
            if self.progress_callback:
                self.progress_callback(ino, len(unique_entries), f"Packing: {rel_str}")
        
        # Write trailer
        self._write_cpio_trailer(output)
        
        return output.getvalue()
    
    def _write_cpio_entry(self, output: io.BytesIO, name: str, path: Path, ino: int):
        """Write a single cpio newc entry."""
        try:
            stat = path.stat()
            mode = stat.st_mode
            uid = 0  # root
            gid = 0  # root
            nlink = 1
            mtime = int(stat.st_mtime)
            
            if path.is_file():
                with open(path, 'rb') as f:
                    data = f.read()
                filesize = len(data)
            elif path.is_symlink():
                target = os.readlink(path)
                data = target.encode('utf-8')
                filesize = len(data)
                mode = (mode & ~0o170000) | 0o120000  # Set symlink mode
            elif path.is_dir():
                data = b''
                filesize = 0
                mode = (mode & ~0o170000) | 0o040000  # Set directory mode
            else:
                data = b''
                filesize = 0
        except Exception:
            data = b''
            filesize = 0
            mode = 0o100644
            uid = gid = 0
            nlink = 1
            mtime = 0
        
        # newc format header
        name_bytes = name.encode('utf-8') + b'\x00'
        namesize = len(name_bytes)
        
        header = f"070701{ino:08X}{mode:08X}{uid:08X}{gid:08X}{nlink:08X}{mtime:08X}{filesize:08X}00000000000000000000000000000000{namesize:08X}00000000"
        output.write(header.encode('ascii'))
        output.write(name_bytes)
        
        # Pad to 4-byte boundary
        pad = (4 - ((110 + namesize) % 4)) % 4
        output.write(b'\x00' * pad)
        
        # Write data
        if data:
            output.write(data)
            # Pad data to 4-byte boundary
            pad = (4 - (filesize % 4)) % 4
            output.write(b'\x00' * pad)
    
    def _write_cpio_trailer(self, output: io.BytesIO):
        """Write cpio trailer entry."""
        name = b'TRAILER!!!\x00'
        namesize = len(name)
        header = f"070701{'0'*8}{'0'*8}{'0'*8}{'0'*8}{'0'*8}{'0'*8}{'0'*8}00000000000000000000000000000000{namesize:08X}00000000"
        output.write(header.encode('ascii'))
        output.write(name)
        # Pad to 512-byte boundary for some tools
        current = output.tell()
        pad = (512 - (current % 512)) % 512
        output.write(b'\x00' * pad)


# =============================================================================
# RECOVERY PORTER / MODIFIER
# =============================================================================
#
# EDUCATIONAL NOTES: Understanding Android Recovery Partitions
# ============================================================
#
# Recovery is a minimal Linux environment for system maintenance:
# - Flashing OTA updates
# - Factory reset (wipe data)
# - Wipe cache
# - ADB sideload
# - Custom recoveries add: root, backups, custom ROMs
#
# RECOVERY IMAGE STRUCTURE (same as boot.img):
# ┌──────────────────────────────────────┐
# │ Header (v0-v4)                       │
# │   - magic: "ANDROID!"                │
# │   - kernel_size, kernel_addr         │
# │   - ramdisk_size, ramdisk_addr       │
# │   - cmdline, page_size, etc          │
# ├──────────────────────────────────────┤
# │ Kernel (zImage/Image.gz)             │
# │   - Linux kernel for recovery mode   │
# │   - Often same as boot kernel        │
# ├──────────────────────────────────────┤
# │ Ramdisk (cpio.gz)                    │
# │   - Root filesystem                  │
# │   - Contains recovery binary         │
# │   - init scripts, fstab              │
# ├──────────────────────────────────────┤
# │ DTB (optional, v2+)                  │
# │   - Device Tree Blob                 │
# │   - Hardware description             │
# └──────────────────────────────────────┘
#
# RAMDISK STRUCTURE (what's inside the cpio archive):
# /
# ├── init                    # First process (PID 1)
# ├── init.rc                 # Init script - starts services
# ├── default.prop            # System properties
# ├── fstab.*                 # Partition mount table (CRITICAL!)
# ├── sbin/
# │   ├── recovery            # Main recovery binary (TWRP/OrangeFox)
# │   ├── adbd                # ADB daemon
# │   └── ...                 # Other tools
# ├── res/                    # Resources (fonts, images)
# ├── etc/                    # Config files
# │   └── recovery.fstab      # Recovery-specific fstab
# └── system/                 # Minimal system files
#
# FSTAB FORMAT (Critical for porting):
# <mount_point> <type> <device> <device2> <flags>
# Example:
# /system      ext4  /dev/block/bootdevice/by-name/system  flags=...
# /data        ext4  /dev/block/bootdevice/by-name/userdata flags=...
# /boot        emmc  /dev/block/bootdevice/by-name/boot
#
# COMMON RECOVERY FRAMEWORKS:
# - AOSP Recovery: Basic, stock Android
# - TWRP: Touch-based, most popular custom recovery
# - OrangeFox: TWRP fork with extra features
# - SHRP: Skyhawk Recovery Project
# - PBRP: PitchBlack Recovery
# - LineageOS Recovery: Clean, simple
#
# PORTING RECOVERY TO A NEW DEVICE:
# 1. Find recovery from similar device (same SoC, similar hardware)
# 2. Extract kernel and DTB from TARGET device's boot.img
# 3. Modify fstab to match TARGET device's partition layout
# 4. Update init scripts if needed
# 5. Repack with target's kernel + modified ramdisk
#
# =============================================================================

class RecoveryPorter:
    """Port and modify Android recovery images.
    
    This class helps with:
    - Extracting recovery components
    - Analyzing ramdisk contents
    - Modifying fstab for device porting
    - Swapping kernels between devices
    - Repacking modified recovery
    
    Common use cases:
    - Port TWRP from similar device
    - Update kernel in existing recovery
    - Modify partition mappings
    - Add tools/scripts to recovery
    """
    
    # Known recovery signatures
    RECOVERY_SIGNATURES = {
        b'TWRP': 'Team Win Recovery Project',
        b'OrangeFox': 'OrangeFox Recovery',
        b'SHRP': 'Skyhawk Recovery Project',
        b'PBRP': 'PitchBlack Recovery',
        b'LineageOS': 'LineageOS Recovery',
    }
    
    # Critical fstab mount points
    CRITICAL_MOUNTS = [
        '/system', '/system_root', '/vendor', '/product',
        '/data', '/cache', '/boot', '/recovery',
        '/misc', '/persist', '/metadata'
    ]
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
        self.recovery_type = None
        self.ramdisk_contents = {}
        self.fstab_entries = []
        self.kernel_info = {}
        self.header_version = 0
    
    def analyze(self, recovery_path: str) -> dict:
        """Analyze a recovery image and return detailed information.
        
        Args:
            recovery_path: Path to recovery.img
            
        Returns:
            Dict with recovery analysis
        """
        info = {
            'path': recovery_path,
            'size': os.path.getsize(recovery_path),
            'format': None,
            'recovery_type': 'Unknown',
            'header_version': 0,
            'kernel_size': 0,
            'ramdisk_size': 0,
            'dtb_size': 0,
            'cmdline': '',
            'fstab': [],
            'ramdisk_files': [],
            'warnings': [],
            'can_port': True,
        }
        
        try:
            with open(recovery_path, 'rb') as f:
                magic = f.read(8)
                
                if magic == b'ANDROID!':
                    info['format'] = 'boot'
                    self._analyze_boot_format(f, info)
                elif magic == b'VNDRBOOT':
                    info['format'] = 'vendor_boot'
                    info['warnings'].append('vendor_boot format - unusual for recovery')
                else:
                    info['format'] = 'unknown'
                    info['can_port'] = False
                    info['warnings'].append(f'Unknown format: {magic[:8]}')
                    return info
            
            # Extract and analyze ramdisk
            self._analyze_ramdisk(recovery_path, info)
            
        except Exception as e:
            info['warnings'].append(f'Analysis error: {e}')
            info['can_port'] = False
        
        return info
    
    def _analyze_boot_format(self, f: BinaryIO, info: dict):
        """Parse boot image header."""
        f.seek(0)
        header = f.read(1648)
        
        # Parse header
        kernel_size = struct.unpack('<I', header[8:12])[0]
        ramdisk_size = struct.unpack('<I', header[16:20])[0]
        second_size = struct.unpack('<I', header[24:28])[0]
        page_size = struct.unpack('<I', header[36:40])[0]
        header_version = struct.unpack('<I', header[40:44])[0]
        
        # Cmdline
        cmdline_end = header[64:64+512].find(b'\x00')
        cmdline = header[64:64+cmdline_end].decode('utf-8', errors='ignore') if cmdline_end > 0 else ''
        
        info['header_version'] = header_version
        info['kernel_size'] = kernel_size
        info['ramdisk_size'] = ramdisk_size
        info['page_size'] = page_size
        info['cmdline'] = cmdline
        self.header_version = header_version
        
        # DTB size (v2+)
        if header_version >= 2 and len(header) >= 1648:
            dtb_size = struct.unpack('<I', header[1644:1648])[0]
            info['dtb_size'] = dtb_size
        
        # Board name
        board_name = header[48:64].rstrip(b'\x00').decode('utf-8', errors='ignore')
        if board_name:
            info['board_name'] = board_name
    
    def _analyze_ramdisk(self, recovery_path: str, info: dict):
        """Extract and analyze ramdisk contents."""
        import tempfile
        import subprocess
        
        # Use BootImageExtractor to get ramdisk
        extractor = BootImageExtractor()
        
        with tempfile.TemporaryDirectory() as tmpdir:
            try:
                extracted = extractor.extract(recovery_path, tmpdir)
                
                ramdisk_path = extracted.get('ramdisk')
                if not ramdisk_path:
                    info['warnings'].append('No ramdisk found in image')
                    return
                
                # Detect compression and get raw cpio
                ramdisk_dir = Path(tmpdir) / 'ramdisk_contents'
                ramdisk_dir.mkdir()
                
                cpio_data = self._decompress_ramdisk(ramdisk_path)
                if cpio_data:
                    self._parse_cpio(cpio_data, ramdisk_dir, info)
                    self._detect_recovery_type(ramdisk_dir, info)
                    self._parse_fstab(ramdisk_dir, info)
                
            except Exception as e:
                info['warnings'].append(f'Ramdisk analysis error: {e}')
    
    def _decompress_ramdisk(self, ramdisk_path: str) -> Optional[bytes]:
        """Decompress ramdisk and return raw cpio data."""
        with open(ramdisk_path, 'rb') as f:
            data = f.read()
        
        # Detect compression
        if data[:2] == b'\x1f\x8b':  # gzip
            return gzip.decompress(data)
        elif data[:4] == b'\x04\x22\x4d\x18':  # lz4
            try:
                import lz4.frame  # type: ignore
                return lz4.frame.decompress(data)
            except ImportError:
                # Try legacy lz4
                try:
                    import lz4.block  # type: ignore
                    return lz4.block.decompress(data)
                except:
                    return None
        elif data[:6] == b'\xfd7zXZ\x00':  # xz
            return lzma.decompress(data)
        elif data[:2] == b'\x5d\x00':  # lzma
            return lzma.decompress(data)
        elif data[:6] == b'070701' or data[:6] == b'070702':  # uncompressed cpio
            return data
        else:
            return data  # Try as-is
    
    def _parse_cpio(self, cpio_data: bytes, output_dir: Path, info: dict):
        """Parse cpio archive and list contents."""
        offset = 0
        files = []
        
        while offset < len(cpio_data) - 110:
            # Check for newc format
            if cpio_data[offset:offset+6] != b'070701':
                break
            
            # Parse header
            header = cpio_data[offset:offset+110].decode('ascii')
            namesize = int(header[94:102], 16)
            filesize = int(header[54:62], 16)
            mode = int(header[14:22], 16)
            
            # Get filename
            name_start = offset + 110
            name_end = name_start + namesize - 1  # Exclude null terminator
            name = cpio_data[name_start:name_end].decode('utf-8', errors='ignore')
            
            if name == 'TRAILER!!!':
                break
            
            # Determine type
            file_type = 'file'
            if (mode & 0o170000) == 0o040000:
                file_type = 'dir'
            elif (mode & 0o170000) == 0o120000:
                file_type = 'symlink'
            
            files.append({
                'name': name,
                'size': filesize,
                'mode': mode,
                'type': file_type
            })
            
            # Calculate next entry offset
            header_pad = (4 - ((110 + namesize) % 4)) % 4
            data_pad = (4 - (filesize % 4)) % 4 if filesize > 0 else 0
            offset = name_start + namesize + header_pad + filesize + data_pad
        
        info['ramdisk_files'] = files
        self.ramdisk_contents = {f['name']: f for f in files}
    
    def _detect_recovery_type(self, ramdisk_dir: Path, info: dict):
        """Detect which recovery framework this is."""
        # Check for known binaries and signatures
        recovery_type = 'AOSP/Stock'
        
        # Common locations to check
        checks = [
            ('sbin/recovery', None),
            ('system/bin/recovery', None),
            ('res/images', 'Custom Recovery'),
        ]
        
        # Check ramdisk file list for clues
        files_str = ' '.join(f['name'] for f in info.get('ramdisk_files', []))
        
        if 'twres' in files_str or 'TWRP' in files_str:
            recovery_type = 'TWRP'
        elif 'Fox' in files_str or 'orangefox' in files_str.lower():
            recovery_type = 'OrangeFox'
        elif 'shrp' in files_str.lower():
            recovery_type = 'SHRP'
        elif 'pbrp' in files_str.lower():
            recovery_type = 'PitchBlack'
        elif 'lineage' in files_str.lower():
            recovery_type = 'LineageOS'
        
        info['recovery_type'] = recovery_type
        self.recovery_type = recovery_type
    
    def _parse_fstab(self, ramdisk_dir: Path, info: dict):
        """Find and parse fstab files."""
        fstab_entries = []
        
        # Look for fstab in ramdisk file list
        fstab_files = [f['name'] for f in info.get('ramdisk_files', []) 
                       if 'fstab' in f['name'].lower() or f['name'].endswith('.fstab')]
        
        info['fstab_files'] = fstab_files
        
        # Note: Full fstab parsing would require extracting the actual files
        # For now, we just identify which fstab files exist
        if not fstab_files:
            info['warnings'].append('No fstab found - may need manual configuration')
    
    def extract_components(self, recovery_path: str, output_dir: str) -> dict:
        """Extract all recovery components for modification.
        
        Args:
            recovery_path: Path to recovery.img
            output_dir: Where to extract components
            
        Returns:
            Dict with paths to extracted components
        """
        output = Path(output_dir)
        output.mkdir(parents=True, exist_ok=True)
        
        result = {
            'kernel': None,
            'ramdisk': None,
            'ramdisk_dir': None,
            'dtb': None,
            'cmdline': '',
            'header_version': 0,
        }
        
        # Extract using BootImageExtractor
        extractor = BootImageExtractor()
        extracted = extractor.extract(recovery_path, str(output))
        
        result['kernel'] = extracted.get('kernel')
        result['ramdisk'] = extracted.get('ramdisk')
        result['dtb'] = extracted.get('dtb')
        result['header_version'] = extracted.get('header_version', 0)
        result['cmdline'] = extracted.get('cmdline', '')
        
        # Extract ramdisk contents
        if result['ramdisk']:
            ramdisk_dir = output / 'ramdisk'
            ramdisk_dir.mkdir(exist_ok=True)
            
            cpio_data = self._decompress_ramdisk(result['ramdisk'])
            if cpio_data:
                self._extract_cpio(cpio_data, ramdisk_dir)
                result['ramdisk_dir'] = str(ramdisk_dir)
        
        return result
    
    def _extract_cpio(self, cpio_data: bytes, output_dir: Path):
        """Extract cpio archive to directory."""
        offset = 0
        
        while offset < len(cpio_data) - 110:
            if cpio_data[offset:offset+6] != b'070701':
                break
            
            # Parse header
            header = cpio_data[offset:offset+110].decode('ascii')
            namesize = int(header[94:102], 16)
            filesize = int(header[54:62], 16)
            mode = int(header[14:22], 16)
            
            # Get filename
            name_start = offset + 110
            name_end = name_start + namesize - 1
            name = cpio_data[name_start:name_end].decode('utf-8', errors='ignore')
            
            if name == 'TRAILER!!!':
                break
            
            # Calculate data position
            header_pad = (4 - ((110 + namesize) % 4)) % 4
            data_start = name_start + namesize + header_pad
            data_end = data_start + filesize
            
            # Create file/directory
            out_path = output_dir / name
            
            if (mode & 0o170000) == 0o040000:  # Directory
                out_path.mkdir(parents=True, exist_ok=True)
            elif (mode & 0o170000) == 0o120000:  # Symlink
                out_path.parent.mkdir(parents=True, exist_ok=True)
                link_target = cpio_data[data_start:data_end].decode('utf-8', errors='ignore')
                # On Windows, just save as text file
                if sys.platform == 'win32':
                    out_path.write_text(f'SYMLINK -> {link_target}')
                else:
                    try:
                        out_path.symlink_to(link_target)
                    except:
                        out_path.write_text(f'SYMLINK -> {link_target}')
            else:  # Regular file
                out_path.parent.mkdir(parents=True, exist_ok=True)
                out_path.write_bytes(cpio_data[data_start:data_end])
                try:
                    out_path.chmod(mode & 0o777)
                except:
                    pass
            
            # Next entry
            data_pad = (4 - (filesize % 4)) % 4 if filesize > 0 else 0
            offset = data_end + data_pad
    
    def repack(self, components: dict, output_path: str, 
               header_version: Optional[int] = None) -> bool:
        """Repack modified components into recovery image.
        
        Args:
            components: Dict with kernel, ramdisk_dir, dtb, cmdline
            output_path: Where to save new recovery.img
            header_version: Override header version
            
        Returns:
            True if successful
        """
        try:
            kernel = components.get('kernel')
            ramdisk_dir = components.get('ramdisk_dir')
            dtb = components.get('dtb')
            cmdline = components.get('cmdline', '')
            version = header_version or components.get('header_version', 2)
            
            if not kernel:
                logger.error("Kernel is required")
                return False
            
            # Pack ramdisk if directory provided
            ramdisk_path = components.get('ramdisk')
            if ramdisk_dir and Path(ramdisk_dir).is_dir():
                import tempfile
                with tempfile.NamedTemporaryFile(suffix='.cpio.gz', delete=False) as tmp:
                    ramdisk_path = tmp.name
                
                packer = RamdiskPacker()
                if not packer.pack(ramdisk_dir, ramdisk_path, 'gzip'):
                    logger.error("Failed to pack ramdisk")
                    return False
            
            # Use BootImagePacker
            packer = BootImagePacker()
            success = packer.pack_boot_image(
                output_path,
                kernel=kernel,
                ramdisk=ramdisk_path,
                dtb=dtb if dtb and Path(dtb).exists() else None,
                cmdline=cmdline,
                header_version=version
            )
            
            if success:
                logger.info(f"Recovery image created: {output_path}")
            
            return success
            
        except Exception as e:
            logger.error(f"Failed to repack recovery: {e}")
            return False
    
    @staticmethod
    def parse_fstab_file(fstab_path: str) -> list[dict]:
        """Parse a fstab file and return entries.
        
        Args:
            fstab_path: Path to fstab file
            
        Returns:
            List of fstab entries
        """
        entries = []
        
        try:
            with open(fstab_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    
                    parts = line.split()
                    if len(parts) >= 2:
                        entry = {
                            'mount_point': parts[0] if parts[0].startswith('/') else parts[1],
                            'type': parts[1] if parts[0].startswith('/') else parts[0],
                            'device': parts[2] if len(parts) > 2 else '',
                            'flags': ' '.join(parts[3:]) if len(parts) > 3 else '',
                            'raw': line
                        }
                        entries.append(entry)
        except Exception as e:
            logger.error(f"Failed to parse fstab: {e}")
        
        return entries
    
    @staticmethod
    def generate_fstab(entries: list[dict], output_path: str) -> bool:
        """Generate a fstab file from entries.
        
        Args:
            entries: List of fstab entry dicts
            output_path: Where to save fstab
            
        Returns:
            True if successful
        """
        try:
            with open(output_path, 'w') as f:
                f.write("# Recovery fstab - Generated by Image Anarchy\n")
                f.write("# Format: <mount_point> <type> <device> [<device2>] <flags>\n\n")
                
                for entry in entries:
                    if 'raw' in entry:
                        f.write(entry['raw'] + '\n')
                    else:
                        line = f"{entry['mount_point']}\t{entry['type']}\t{entry['device']}"
                        if entry.get('flags'):
                            line += f"\t{entry['flags']}"
                        f.write(line + '\n')
            
            return True
        except Exception as e:
            logger.error(f"Failed to write fstab: {e}")
            return False


class Ext4ImageExtractor:
    """Extract files from ext4 filesystem images."""
    
    # ext4 constants
    EXT4_SUPER_MAGIC = 0xEF53
    EXT4_S_IFMT = 0xF000
    EXT4_S_IFREG = 0x8000  # Regular file
    EXT4_S_IFDIR = 0x4000  # Directory
    EXT4_S_IFLNK = 0xA000  # Symbolic link
    
    # Extent magic
    EXT4_EXT_MAGIC = 0xF30A
    
    # Feature flags
    EXT4_FEATURE_INCOMPAT_EXTENTS = 0x0040
    EXT4_FEATURE_INCOMPAT_64BIT = 0x0080
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
        self.superblock = None
        self.block_size = 4096
        self.inode_size = 256
        self.inodes_per_group = 0
        self.blocks_per_group = 0
        self.desc_size = 32
        self.has_extents = False
        self.is_64bit = False
    
    def list_files(self, input_path: str) -> list[dict]:
        """List all files in an ext4 image."""
        files = []
        
        with open(input_path, 'rb') as f:
            self._read_superblock(f)
            self._list_directory(f, 2, '', files)  # Root inode is 2
        
        return files
    
    def extract(self, input_path: str, output_dir: str,
                file_list: Optional[list[str]] = None) -> dict:
        """Extract files from ext4 image."""
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        extracted = {}
        
        with open(input_path, 'rb') as f:
            self._read_superblock(f)
            self._extract_directory(f, 2, '', output_dir, file_list, extracted)
        
        return extracted
    
    def _read_superblock(self, f: BinaryIO):
        """Read and parse ext4 superblock."""
        f.seek(0x400)  # Superblock at offset 1024
        sb = f.read(256)
        
        # Check magic
        magic = struct.unpack('<H', sb[0x38:0x3A])[0]
        if magic != self.EXT4_SUPER_MAGIC:
            raise PayloadError(f"Invalid ext4 magic: {hex(magic)}")
        
        # Parse superblock fields
        self.inodes_count = struct.unpack('<I', sb[0x00:0x04])[0]
        self.blocks_count_lo = struct.unpack('<I', sb[0x04:0x08])[0]
        self.blocks_per_group = struct.unpack('<I', sb[0x20:0x24])[0]
        self.inodes_per_group = struct.unpack('<I', sb[0x28:0x2C])[0]
        
        log_block_size = struct.unpack('<I', sb[0x18:0x1C])[0]
        self.block_size = 1024 << log_block_size
        
        self.inode_size = struct.unpack('<H', sb[0x58:0x5A])[0]
        if self.inode_size == 0:
            self.inode_size = 128
        
        # Feature flags
        feature_incompat = struct.unpack('<I', sb[0x60:0x64])[0]
        self.has_extents = bool(feature_incompat & self.EXT4_FEATURE_INCOMPAT_EXTENTS)
        self.is_64bit = bool(feature_incompat & self.EXT4_FEATURE_INCOMPAT_64BIT)
        
        # Descriptor size for 64-bit
        if self.is_64bit:
            self.desc_size = struct.unpack('<H', sb[0xFE:0x100])[0]
            if self.desc_size == 0:
                self.desc_size = 32
        else:
            self.desc_size = 32
        
        # Group count
        self.group_count = (self.blocks_count_lo + self.blocks_per_group - 1) // self.blocks_per_group
        
        self.superblock = sb
    
    def _get_block_group_desc(self, f: BinaryIO, group: int) -> dict:
        """Get block group descriptor."""
        # Group descriptors start at block 1 (or 0 if block_size > 1024)
        if self.block_size == 1024:
            desc_block = 2
        else:
            desc_block = 1
        
        desc_offset = desc_block * self.block_size + group * self.desc_size
        f.seek(desc_offset)
        desc = f.read(self.desc_size)
        
        inode_table_lo = struct.unpack('<I', desc[0x08:0x0C])[0]
        
        if self.is_64bit and self.desc_size >= 64:
            inode_table_hi = struct.unpack('<I', desc[0x28:0x2C])[0]
            inode_table = inode_table_lo | (inode_table_hi << 32)
        else:
            inode_table = inode_table_lo
        
        return {'inode_table': inode_table}
    
    def _read_inode(self, f: BinaryIO, inode_num: int) -> dict:
        """Read an inode by number."""
        if inode_num == 0:
            return None
        
        # Calculate location
        group = (inode_num - 1) // self.inodes_per_group
        index = (inode_num - 1) % self.inodes_per_group
        
        desc = self._get_block_group_desc(f, group)
        inode_offset = desc['inode_table'] * self.block_size + index * self.inode_size
        
        f.seek(inode_offset)
        inode_data = f.read(self.inode_size)
        
        mode = struct.unpack('<H', inode_data[0x00:0x02])[0]
        size_lo = struct.unpack('<I', inode_data[0x04:0x08])[0]
        size_hi = struct.unpack('<I', inode_data[0x6C:0x70])[0] if len(inode_data) >= 0x70 else 0
        size = size_lo | (size_hi << 32)
        
        flags = struct.unpack('<I', inode_data[0x20:0x24])[0]
        
        # Block pointers or extent tree
        block_data = inode_data[0x28:0x64]  # 60 bytes for i_block
        
        return {
            'mode': mode,
            'size': size,
            'flags': flags,
            'block_data': block_data,
            'uses_extents': bool(flags & 0x80000),  # EXT4_EXTENTS_FL
        }
    
    def _read_extent_tree(self, f: BinaryIO, block_data: bytes, file_size: int) -> bytes:
        """Read file data using extent tree."""
        data = bytearray()
        
        # Parse extent header
        magic = struct.unpack('<H', block_data[0:2])[0]
        entries = struct.unpack('<H', block_data[2:4])[0]
        depth = struct.unpack('<H', block_data[6:8])[0]
        
        if magic != self.EXT4_EXT_MAGIC:
            # Fall back to reading as direct blocks
            return self._read_block_pointers(f, block_data, file_size)
        
        if depth == 0:
            # Leaf node - contains actual extents
            for i in range(entries):
                ext_offset = 12 + i * 12
                ext = block_data[ext_offset:ext_offset + 12]
                
                ee_block = struct.unpack('<I', ext[0:4])[0]  # Logical block
                ee_len = struct.unpack('<H', ext[4:6])[0]    # Length
                ee_start_hi = struct.unpack('<H', ext[6:8])[0]
                ee_start_lo = struct.unpack('<I', ext[8:12])[0]
                ee_start = ee_start_lo | (ee_start_hi << 32)
                
                # Handle uninitialized extents (high bit set in length)
                if ee_len > 32768:
                    ee_len -= 32768
                
                for blk in range(ee_len):
                    f.seek((ee_start + blk) * self.block_size)
                    data.extend(f.read(self.block_size))
        else:
            # Index node - contains pointers to lower levels
            for i in range(entries):
                idx_offset = 12 + i * 12
                idx = block_data[idx_offset:idx_offset + 12]
                
                ei_leaf_lo = struct.unpack('<I', idx[4:8])[0]
                ei_leaf_hi = struct.unpack('<H', idx[8:10])[0]
                ei_leaf = ei_leaf_lo | (ei_leaf_hi << 32)
                
                # Read the next level
                f.seek(ei_leaf * self.block_size)
                next_block = f.read(self.block_size)
                data.extend(self._read_extent_tree(f, next_block, file_size - len(data)))
        
        return bytes(data[:file_size])
    
    def _read_block_pointers(self, f: BinaryIO, block_data: bytes, file_size: int) -> bytes:
        """Read file data using traditional block pointers."""
        data = bytearray()
        blocks_needed = (file_size + self.block_size - 1) // self.block_size
        
        # Direct blocks (0-11)
        for i in range(min(12, blocks_needed)):
            block_num = struct.unpack('<I', block_data[i*4:(i+1)*4])[0]
            if block_num == 0:
                data.extend(b'\x00' * self.block_size)
            else:
                f.seek(block_num * self.block_size)
                data.extend(f.read(self.block_size))
        
        if blocks_needed <= 12:
            return bytes(data[:file_size])
        
        # Indirect block (12)
        indirect_block = struct.unpack('<I', block_data[48:52])[0]
        if indirect_block:
            data.extend(self._read_indirect(f, indirect_block, blocks_needed - 12))
        
        return bytes(data[:file_size])
    
    def _read_indirect(self, f: BinaryIO, block_num: int, max_blocks: int) -> bytes:
        """Read blocks through indirect block."""
        data = bytearray()
        ptrs_per_block = self.block_size // 4
        
        f.seek(block_num * self.block_size)
        indirect_data = f.read(self.block_size)
        
        for i in range(min(ptrs_per_block, max_blocks)):
            block = struct.unpack('<I', indirect_data[i*4:(i+1)*4])[0]
            if block == 0:
                data.extend(b'\x00' * self.block_size)
            else:
                f.seek(block * self.block_size)
                data.extend(f.read(self.block_size))
        
        return bytes(data)
    
    def _read_file_data(self, f: BinaryIO, inode: dict) -> bytes:
        """Read all data from a file inode."""
        if inode['size'] == 0:
            return b''
        
        if inode['uses_extents'] or self.has_extents:
            return self._read_extent_tree(f, inode['block_data'], inode['size'])
        else:
            return self._read_block_pointers(f, inode['block_data'], inode['size'])
    
    def _parse_directory(self, f: BinaryIO, inode: dict) -> list[dict]:
        """Parse directory entries from inode."""
        entries = []
        dir_data = self._read_file_data(f, inode)
        
        offset = 0
        while offset < len(dir_data):
            if offset + 8 > len(dir_data):
                break
            
            inode_num = struct.unpack('<I', dir_data[offset:offset+4])[0]
            rec_len = struct.unpack('<H', dir_data[offset+4:offset+6])[0]
            name_len = dir_data[offset + 6]
            file_type = dir_data[offset + 7]
            
            if rec_len == 0 or offset + rec_len > len(dir_data):
                break
            
            if inode_num != 0 and name_len > 0:
                name = dir_data[offset+8:offset+8+name_len].decode('utf-8', errors='ignore')
                entries.append({
                    'inode': inode_num,
                    'name': name,
                    'file_type': file_type,
                })
            
            offset += rec_len
        
        return entries
    
    def _list_directory(self, f: BinaryIO, inode_num: int, path: str, files: list):
        """Recursively list files in a directory."""
        inode = self._read_inode(f, inode_num)
        if not inode:
            return
        
        entries = self._parse_directory(f, inode)
        
        for entry in entries:
            if entry['name'] in ('.', '..'):
                continue
            
            full_path = f"{path}/{entry['name']}" if path else entry['name']
            
            child_inode = self._read_inode(f, entry['inode'])
            if not child_inode:
                continue
            
            mode = child_inode['mode'] & self.EXT4_S_IFMT
            
            if mode == self.EXT4_S_IFDIR:
                self._list_directory(f, entry['inode'], full_path, files)
            elif mode == self.EXT4_S_IFREG:
                files.append({
                    'name': full_path,
                    'size': child_inode['size'],
                    'type': 'file',
                    'inode': entry['inode'],
                })
            elif mode == self.EXT4_S_IFLNK:
                files.append({
                    'name': full_path,
                    'size': child_inode['size'],
                    'type': 'symlink',
                    'inode': entry['inode'],
                })
    
    def _extract_directory(self, f: BinaryIO, inode_num: int, path: str,
                           output_dir: str, file_list: Optional[list[str]], extracted: dict):
        """Recursively extract files from a directory."""
        inode = self._read_inode(f, inode_num)
        if not inode:
            return
        
        entries = self._parse_directory(f, inode)
        
        for entry in entries:
            if entry['name'] in ('.', '..'):
                continue
            
            full_path = f"{path}/{entry['name']}" if path else entry['name']
            
            child_inode = self._read_inode(f, entry['inode'])
            if not child_inode:
                continue
            
            mode = child_inode['mode'] & self.EXT4_S_IFMT
            
            if mode == self.EXT4_S_IFDIR:
                dir_path = Path(output_dir) / full_path
                dir_path.mkdir(parents=True, exist_ok=True)
                self._extract_directory(f, entry['inode'], full_path, output_dir, file_list, extracted)
            
            elif mode == self.EXT4_S_IFREG:
                if file_list is None or full_path in file_list:
                    self._extract_file(f, child_inode, full_path, output_dir, extracted)
            
            elif mode == self.EXT4_S_IFLNK:
                if file_list is None or full_path in file_list:
                    self._extract_symlink(f, child_inode, full_path, output_dir, extracted)
    
    def _extract_file(self, f: BinaryIO, inode: dict, full_path: str,
                      output_dir: str, extracted: dict):
        """Extract a regular file."""
        output_path = Path(output_dir) / full_path
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        data = self._read_file_data(f, inode)
        output_path.write_bytes(data)
        
        extracted[full_path] = str(output_path)
        logger.info(f"  Extracted: {full_path} ({inode['size']} bytes)")
    
    def _extract_symlink(self, f: BinaryIO, inode: dict, full_path: str,
                         output_dir: str, extracted: dict):
        """Extract a symbolic link."""
        output_path = Path(output_dir) / full_path
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # For small symlinks, target is stored inline in block pointers
        if inode['size'] <= 60:
            target = inode['block_data'][:inode['size']].decode('utf-8', errors='ignore')
        else:
            target = self._read_file_data(f, inode).decode('utf-8', errors='ignore')
        
        # Write symlink info to a text file (can't create real symlinks cross-platform)
        link_file = output_path.with_suffix(output_path.suffix + '.symlink')
        link_file.write_text(f"SYMLINK -> {target}")
        
        extracted[full_path] = str(link_file)
        logger.info(f"  Extracted symlink: {full_path} -> {target}")


class ErofsImageExtractor:
    """Extract files from EROFS (Enhanced Read-Only File System) images.
    
    EROFS is a read-only filesystem used in modern Android devices (Android 13+).
    It supports LZ4 and LZMA compression for better compression ratios.
    
    Superblock layout (at offset 1024):
    - 0x00: magic (4 bytes) = 0xE0F5E1E2
    - 0x04: checksum (4 bytes)
    - 0x08: feature_compat (4 bytes)
    - 0x0C: blkszbits (1 byte) - log2(block_size)
    - 0x0D: sb_extslots (1 byte)
    - 0x0E: root_nid (2 bytes) - root inode number
    - 0x10: inos (8 bytes) - total inodes
    - 0x18: build_time (8 bytes)
    - 0x20: build_time_nsec (4 bytes)
    - 0x24: blocks (4 bytes) - total blocks
    - 0x28: meta_blkaddr (4 bytes)
    - 0x2C: xattr_blkaddr (4 bytes)
    - 0x30: uuid (16 bytes)
    - 0x40: volume_name (16 bytes)
    - 0x50: feature_incompat (4 bytes)
    - 0x54: union (2 bytes)
    - 0x56: extra_devices (2 bytes)
    - 0x58: devt_slotoff (2 bytes)
    - 0x5A: dirblkbits (1 byte)
    - 0x5B: xattr_prefix_count (1 byte)
    - 0x5C: xattr_prefix_start (4 bytes)
    - 0x60: packed_nid (8 bytes)
    - 0x68: reserved (24 bytes)
    """
    
    # EROFS constants
    EROFS_SUPER_OFFSET = 1024
    EROFS_SUPER_MAGIC = 0xE0F5E1E2
    
    # Inode formats
    EROFS_INODE_FLAT_PLAIN = 0      # No compression, data follows inode
    EROFS_INODE_FLAT_COMPRESSION_LEGACY = 1  # Deprecated
    EROFS_INODE_FLAT_INLINE = 2     # Data inline in inode (small files)
    EROFS_INODE_FLAT_COMPRESSION = 3  # Compressed data
    EROFS_INODE_CHUNK_BASED = 4     # Chunk-based (newer format)
    
    # File types
    EROFS_FT_UNKNOWN = 0
    EROFS_FT_REG_FILE = 1
    EROFS_FT_DIR = 2
    EROFS_FT_CHRDEV = 3
    EROFS_FT_BLKDEV = 4
    EROFS_FT_FIFO = 5
    EROFS_FT_SOCK = 6
    EROFS_FT_SYMLINK = 7
    
    # Mode flags
    S_IFMT = 0o170000
    S_IFREG = 0o100000
    S_IFDIR = 0o040000
    S_IFLNK = 0o120000
    
    # Feature flags
    EROFS_FEATURE_INCOMPAT_LZ4_0PADDING = 0x0001
    EROFS_FEATURE_INCOMPAT_COMPR_CFGS = 0x0002
    EROFS_FEATURE_INCOMPAT_BIG_PCLUSTER = 0x0004
    EROFS_FEATURE_INCOMPAT_CHUNKED_FILE = 0x0008
    EROFS_FEATURE_INCOMPAT_DEVICE_TABLE = 0x0010
    EROFS_FEATURE_INCOMPAT_ZTAILPACKING = 0x0020
    EROFS_FEATURE_INCOMPAT_FRAGMENTS = 0x0040
    EROFS_FEATURE_INCOMPAT_DEDUPE = 0x0080
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
        self.superblock = {}
        self.block_size = 4096
        self.meta_blkaddr = 0
        self.root_nid = 0
        self.has_lz4 = False
        self._lz4_available = False
        self._check_lz4()
    
    @staticmethod
    def is_erofs(file_path: str) -> bool:
        """Check if a file is an EROFS image.
        
        Args:
            file_path: Path to the file to check
            
        Returns:
            True if the file is an EROFS image
        """
        try:
            with open(file_path, 'rb') as f:
                f.seek(1024)  # EROFS superblock offset
                magic = f.read(4)
                return magic == b'\xe2\xe1\xf5\xe0'  # Little-endian 0xE0F5E1E2
        except (IOError, OSError):
            return False
    
    def _check_lz4(self):
        """Check if LZ4 decompression is available."""
        try:
            import lz4.block
            self._lz4_available = True
        except ImportError:
            self._lz4_available = False
            logger.warning("LZ4 not available - compressed EROFS files cannot be extracted")
    
    def analyze(self, input_path: str) -> dict:
        """Analyze an EROFS image and return metadata."""
        info = {
            'type': 'erofs',
            'valid': False,
        }
        
        try:
            with open(input_path, 'rb') as f:
                self._read_superblock(f)
                info['valid'] = True
                info['block_size'] = self.block_size
                info['total_blocks'] = self.superblock.get('blocks', 0)
                info['total_inodes'] = self.superblock.get('inos', 0)
                info['volume_name'] = self.superblock.get('volume_name', '')
                info['uuid'] = self.superblock.get('uuid', '')
                info['build_time'] = self.superblock.get('build_time', 0)
                info['feature_incompat'] = self.superblock.get('feature_incompat', 0)
                
                # Decode feature flags
                features = []
                feat = info['feature_incompat']
                if feat & self.EROFS_FEATURE_INCOMPAT_LZ4_0PADDING:
                    features.append('LZ4_0PADDING')
                    self.has_lz4 = True
                if feat & self.EROFS_FEATURE_INCOMPAT_COMPR_CFGS:
                    features.append('COMPR_CFGS')
                if feat & self.EROFS_FEATURE_INCOMPAT_BIG_PCLUSTER:
                    features.append('BIG_PCLUSTER')
                if feat & self.EROFS_FEATURE_INCOMPAT_CHUNKED_FILE:
                    features.append('CHUNKED_FILE')
                if feat & self.EROFS_FEATURE_INCOMPAT_DEVICE_TABLE:
                    features.append('DEVICE_TABLE')
                if feat & self.EROFS_FEATURE_INCOMPAT_ZTAILPACKING:
                    features.append('ZTAILPACKING')
                if feat & self.EROFS_FEATURE_INCOMPAT_FRAGMENTS:
                    features.append('FRAGMENTS')
                if feat & self.EROFS_FEATURE_INCOMPAT_DEDUPE:
                    features.append('DEDUPE')
                info['features'] = features
                
                # Count root directory entries
                root_inode = self._read_inode(f, self.root_nid)
                if root_inode:
                    info['root_inode_size'] = root_inode.get('size', 0)
                    
        except Exception as e:
            info['error'] = str(e)
            logger.error(f"Failed to analyze EROFS: {e}")
        
        return info
    
    def list_files(self, input_path: str, max_depth: int = -1) -> list[dict]:
        """List all files in an EROFS image."""
        files = []
        
        with open(input_path, 'rb') as f:
            self._read_superblock(f)
            self._list_directory(f, self.root_nid, '', files, 0, max_depth)
        
        return files
    
    def extract(self, input_path: str, output_dir: str,
                file_list: Optional[list[str]] = None,
                use_native: bool = False) -> dict:
        """Extract files from EROFS image.
        
        Args:
            input_path: Path to EROFS image
            output_dir: Output directory for extracted files
            file_list: Optional list of specific files to extract
            use_native: Force pure Python extraction (skip fsck.erofs)
            
        Returns:
            Dict with 'files', 'errors', 'skipped' keys
        """
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        extracted = {'files': {}, 'errors': [], 'skipped': [], 'method': 'unknown'}
        
        # Try fsck.erofs first (more reliable for complex images)
        if not use_native and file_list is None:
            fsck_info = self._find_fsck_erofs()
            if fsck_info:
                logger.info(f"Using fsck.erofs for extraction (WSL: {fsck_info.get('use_wsl', False)})")
                result = self._extract_via_fsck(input_path, output_dir, fsck_info)
                if result['success']:
                    extracted['method'] = 'fsck.erofs'
                    extracted['files'] = result.get('files', {})
                    # Write EROFS info file
                    self._write_erofs_info(input_path, output_dir)
                    return extracted
                else:
                    logger.warning(f"fsck.erofs extraction failed: {result.get('error', 'unknown')}, falling back to native")
        
        # Fall back to pure Python extraction
        logger.info("Using native Python extraction")
        extracted['method'] = 'native'
        
        with open(input_path, 'rb') as f:
            self._read_superblock(f)
            
            # Write EROFS info file
            self._write_erofs_info(input_path, output_dir)
            
            self._extract_directory(f, self.root_nid, '', output_dir, file_list, extracted)
        
        return extracted
    
    def _write_erofs_info(self, input_path: str, output_dir: str):
        """Write EROFS image info to a text file."""
        info_path = Path(output_dir) / 'erofs_info.txt'
        info = self.analyze(input_path)
        with open(info_path, 'w') as info_f:
            info_f.write("EROFS Image Information\n")
            info_f.write("=" * 40 + "\n")
            info_f.write(f"Block size: {self.block_size}\n")
            info_f.write(f"Total blocks: {info.get('total_blocks', 'N/A')}\n")
            info_f.write(f"Total inodes: {info.get('total_inodes', 'N/A')}\n")
            info_f.write(f"Volume name: {info.get('volume_name', 'N/A')}\n")
            info_f.write(f"UUID: {info.get('uuid', 'N/A')}\n")
            info_f.write(f"Features: {', '.join(info.get('features', []))}\n")
            info_f.write(f"Extraction method: {info.get('extraction_method', 'N/A')}\n")
    
    def _find_fsck_erofs(self) -> Optional[dict]:
        """Find EROFS extraction tool (extract.erofs or fsck.erofs).
        
        Checks:
        1. Bundled tools directory (extract.erofs.exe, fsck.erofs.exe)
        2. System PATH (native Windows/Linux)
        3. WSL (if on Windows)
        
        Returns:
            Dict with 'path', 'use_wsl', and 'tool' keys, or None if not found
        """
        import shutil
        
        # Check Tools directory first (prefer extract.erofs for extraction)
        tools_dir = Path(get_app_dir()) / 'tools'
        if tools_dir.exists():
            # Prefer extract.erofs.exe (dedicated extraction tool)
            for candidate in ['extract.erofs.exe', 'extract.erofs']:
                tool_path = tools_dir / candidate
                if tool_path.exists():
                    return {'path': str(tool_path), 'use_wsl': False, 'tool': 'extract.erofs'}
            # Fall back to fsck.erofs
            for candidate in ['fsck.erofs.exe', 'fsck.erofs']:
                tool_path = tools_dir / candidate
                if tool_path.exists():
                    return {'path': str(tool_path), 'use_wsl': False, 'tool': 'fsck.erofs'}
        
        # Check native PATH
        extract = shutil.which('extract.erofs')
        if extract:
            return {'path': extract, 'use_wsl': False, 'tool': 'extract.erofs'}
        
        fsck = shutil.which('fsck.erofs')
        if fsck:
            return {'path': fsck, 'use_wsl': False, 'tool': 'fsck.erofs'}
        
        # On Windows, try WSL (quietly - don't spam errors)
        if sys.platform == 'win32':
            try:
                # Check if WSL is available
                result = subprocess.run(
                    ['wsl', '--list'],
                    capture_output=True,
                    timeout=5,
                    creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0
                )
                if result.returncode == 0:
                    # Check if fsck.erofs exists in WSL
                    result = subprocess.run(
                        ['wsl', 'which', 'fsck.erofs'],
                        capture_output=True,
                        text=True,
                        timeout=10,
                        creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0
                    )
                    if result.returncode == 0 and result.stdout.strip():
                        return {'path': 'fsck.erofs', 'use_wsl': True, 'tool': 'fsck.erofs'}
            except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
                # WSL not available - silently continue
                pass
        
        return None
    
    def _extract_via_fsck(self, input_path: str, output_dir: str, fsck_info: dict) -> dict:
        """Extract EROFS image using extract.erofs or fsck.erofs.
        
        Args:
            input_path: Path to EROFS image
            output_dir: Output directory
            fsck_info: Dict with 'path', 'use_wsl', and 'tool' keys
            
        Returns:
            Dict with 'success', 'files', 'error' keys
        """
        result = {'success': False, 'files': {}, 'error': None}
        
        try:
            input_file = Path(input_path).resolve()
            output_path = Path(output_dir).resolve()
            use_wsl = fsck_info.get('use_wsl', False)
            tool_path = fsck_info['path']
            tool_type = fsck_info.get('tool', 'fsck.erofs')
            
            if use_wsl:
                # Convert Windows paths to WSL paths
                wsl_input = self._windows_to_wsl_path(str(input_file))
                wsl_output = self._windows_to_wsl_path(str(output_path))
                
                # WSL always uses fsck.erofs
                cmd = [
                    'wsl', tool_path,
                    f'--extract={wsl_output}',
                    '--overwrite',
                    wsl_input
                ]
            elif tool_type == 'extract.erofs':
                # extract.erofs.exe has different CLI: -i IMAGE -o OUTDIR -x
                cmd = [
                    tool_path,
                    '-i', str(input_file),
                    '-o', str(output_path),
                    '-x',  # Extract all
                    '-f',  # Overwrite existing
                    '-s',  # Silent (no progress spam)
                ]
            else:
                # fsck.erofs CLI
                cmd = [
                    tool_path,
                    f'--extract={output_path}',
                    '--overwrite',
                    str(input_file)
                ]
            
            logger.debug(f"Running: {' '.join(cmd)}")
            
            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=600,  # 10 minute timeout for large images
                creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0
            )
            
            if proc.returncode == 0:
                result['success'] = True
                # Count extracted files
                for root, dirs, files in os.walk(output_dir):
                    for f in files:
                        rel_path = os.path.relpath(os.path.join(root, f), output_dir)
                        result['files'][rel_path] = {'size': os.path.getsize(os.path.join(root, f))}
                logger.info(f"{tool_type} extracted {len(result['files'])} files")
            else:
                result['error'] = proc.stderr or f"{tool_type} exited with code {proc.returncode}"
                logger.debug(f"{tool_type} stderr: {proc.stderr}")
                
        except subprocess.TimeoutExpired:
            result['error'] = "Extraction timed out (>10 minutes)"
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def can_extract_advanced(self) -> bool:
        """Check if advanced extraction via fsck.erofs is available.
        
        Returns:
            True if fsck.erofs is available (native or WSL)
        """
        return self._find_fsck_erofs() is not None
    
    def get_fsck_info(self) -> Optional[dict]:
        """Get information about fsck.erofs availability.
        
        Returns:
            Dict with 'path' and 'use_wsl' keys, or None if not available
        """
        return self._find_fsck_erofs()
    
    def _read_superblock(self, f: BinaryIO):
        """Read and parse EROFS superblock."""
        f.seek(self.EROFS_SUPER_OFFSET)
        sb = f.read(128)
        
        # Check magic
        magic = struct.unpack('<I', sb[0x00:0x04])[0]
        if magic != self.EROFS_SUPER_MAGIC:
            raise PayloadError(f"Invalid EROFS magic: {hex(magic)}, expected {hex(self.EROFS_SUPER_MAGIC)}")
        
        # Parse superblock fields
        self.superblock = {
            'magic': magic,
            'checksum': struct.unpack('<I', sb[0x04:0x08])[0],
            'feature_compat': struct.unpack('<I', sb[0x08:0x0C])[0],
            'blkszbits': sb[0x0C],
            'sb_extslots': sb[0x0D],
            'root_nid': struct.unpack('<H', sb[0x0E:0x10])[0],
            'inos': struct.unpack('<Q', sb[0x10:0x18])[0],
            'build_time': struct.unpack('<Q', sb[0x18:0x20])[0],
            'build_time_nsec': struct.unpack('<I', sb[0x20:0x24])[0],
            'blocks': struct.unpack('<I', sb[0x24:0x28])[0],
            'meta_blkaddr': struct.unpack('<I', sb[0x28:0x2C])[0],
            'xattr_blkaddr': struct.unpack('<I', sb[0x2C:0x30])[0],
            'uuid': sb[0x30:0x40].hex(),
            'volume_name': sb[0x40:0x50].rstrip(b'\x00').decode('utf-8', errors='ignore'),
            'feature_incompat': struct.unpack('<I', sb[0x50:0x54])[0],
        }
        
        self.block_size = 1 << self.superblock['blkszbits']
        self.meta_blkaddr = self.superblock['meta_blkaddr']
        self.root_nid = self.superblock['root_nid']
        
        logger.info(f"EROFS: block_size={self.block_size}, blocks={self.superblock['blocks']}, "
                   f"inodes={self.superblock['inos']}, root_nid={self.root_nid}")
    
    def _nid_to_offset(self, nid: int) -> int:
        """Convert node ID to file offset."""
        return self.meta_blkaddr * self.block_size + nid * 32
    
    def _read_inode(self, f: BinaryIO, nid: int) -> Optional[dict]:
        """Read an inode by node ID."""
        if nid == 0:
            return None
        
        offset = self._nid_to_offset(nid)
        f.seek(offset)
        
        # Read compact inode first (32 bytes minimum)
        inode_data = f.read(64)  # Read extra for extended inode
        
        if len(inode_data) < 32:
            return None
        
        # Parse inode format and version
        i_format = struct.unpack('<H', inode_data[0:2])[0]
        layout = (i_format >> 1) & 0x7  # bits 1-3 are layout
        version = i_format & 0x1  # bit 0 is version (0=compact, 1=extended)
        
        inode = {
            'format': i_format,
            'layout': layout,
            'version': version,
            'nid': nid,
        }
        
        if version == 0:
            # Compact inode (32 bytes)
            inode['xattr_icount'] = struct.unpack('<H', inode_data[2:4])[0]
            inode['mode'] = struct.unpack('<H', inode_data[4:6])[0]
            inode['nlink'] = struct.unpack('<H', inode_data[6:8])[0]
            inode['size'] = struct.unpack('<I', inode_data[8:12])[0]
            inode['reserved'] = struct.unpack('<I', inode_data[12:16])[0]
            # Union field depends on layout
            inode['raw_blkaddr'] = struct.unpack('<I', inode_data[16:20])[0]
            inode['ino'] = struct.unpack('<I', inode_data[20:24])[0]
            inode['uid'] = struct.unpack('<H', inode_data[24:26])[0]
            inode['gid'] = struct.unpack('<H', inode_data[26:28])[0]
            inode['reserved2'] = struct.unpack('<I', inode_data[28:32])[0]
            inode['inode_size'] = 32
        else:
            # Extended inode (64 bytes)
            inode['xattr_icount'] = struct.unpack('<H', inode_data[2:4])[0]
            inode['mode'] = struct.unpack('<H', inode_data[4:6])[0]
            inode['reserved'] = struct.unpack('<H', inode_data[6:8])[0]
            inode['size'] = struct.unpack('<Q', inode_data[8:16])[0]
            inode['raw_blkaddr'] = struct.unpack('<I', inode_data[16:20])[0]
            inode['ino'] = struct.unpack('<I', inode_data[20:24])[0]
            inode['uid'] = struct.unpack('<I', inode_data[24:28])[0]
            inode['gid'] = struct.unpack('<I', inode_data[28:32])[0]
            inode['mtime'] = struct.unpack('<Q', inode_data[32:40])[0]
            inode['mtime_nsec'] = struct.unpack('<I', inode_data[40:44])[0]
            inode['nlink'] = struct.unpack('<I', inode_data[44:48])[0]
            inode['reserved2'] = inode_data[48:64]
            inode['inode_size'] = 64
        
        # Determine file type from mode
        mode = inode['mode']
        if (mode & self.S_IFMT) == self.S_IFDIR:
            inode['type'] = 'dir'
        elif (mode & self.S_IFMT) == self.S_IFREG:
            inode['type'] = 'file'
        elif (mode & self.S_IFMT) == self.S_IFLNK:
            inode['type'] = 'symlink'
        else:
            inode['type'] = 'other'
        
        return inode
    
    def _list_directory(self, f: BinaryIO, dir_nid: int, path: str, 
                        files: list, depth: int, max_depth: int):
        """Recursively list directory contents."""
        if max_depth >= 0 and depth > max_depth:
            return
        
        inode = self._read_inode(f, dir_nid)
        if not inode or inode['type'] != 'dir':
            return
        
        # Read directory entries
        entries = self._read_directory_entries(f, inode)
        
        for entry in entries:
            name = entry['name']
            if name in ('.', '..'):
                continue
            
            full_path = f"{path}/{name}" if path else name
            entry_inode = self._read_inode(f, entry['nid'])
            
            if entry_inode:
                file_info = {
                    'path': full_path,
                    'name': name,
                    'type': entry_inode['type'],
                    'size': entry_inode['size'],
                    'mode': entry_inode['mode'],
                    'nid': entry['nid'],
                }
                files.append(file_info)
                
                # Recurse into subdirectories
                if entry_inode['type'] == 'dir':
                    self._list_directory(f, entry['nid'], full_path, files, depth + 1, max_depth)
    
    def _read_directory_entries(self, f: BinaryIO, inode: dict) -> list[dict]:
        """Read directory entries from an inode following EROFS on-disk format.
        
        EROFS directory format:
        - Directory entries are 12 bytes each: nid(8) + nameoff(2) + file_type(1) + reserved(1)
        - Entries are stored at the start of the block
        - Names are stored after all entries (at nameoff position from block start)
        - nameoff[0] indicates where names start (= entry_count * 12)
        - Names are NOT null-terminated; use offsets to determine length
        """
        entries = []
        layout = inode['layout']
        
        # Calculate data offset based on layout
        inode_offset = self._nid_to_offset(inode['nid'])
        
        if layout == self.EROFS_INODE_FLAT_INLINE:
            # Data is inline after inode
            data_offset = inode_offset + inode['inode_size']
            # Account for xattr if present
            if inode.get('xattr_icount', 0) > 0:
                xattr_size = (inode['xattr_icount'] - 1) * 4 + 12
                data_offset += xattr_size
        elif layout == self.EROFS_INODE_FLAT_PLAIN:
            # Data in separate blocks
            data_offset = inode['raw_blkaddr'] * self.block_size
        else:
            # Other layouts - try plain block reference
            data_offset = inode['raw_blkaddr'] * self.block_size
        
        f.seek(data_offset)
        dir_data = f.read(min(inode['size'], 65536))  # Read directory data
        
        if len(dir_data) < 12:
            return entries
        
        # Read first entry to get nameoff[0] which tells us entry count
        first_nameoff = struct.unpack('<H', dir_data[8:10])[0]
        
        # Number of entries = nameoff[0] / 12
        if first_nameoff < 12:
            return entries
        
        entry_count = first_nameoff // 12
        
        # Parse all entries
        raw_entries = []
        for i in range(entry_count):
            offset = i * 12
            if offset + 12 > len(dir_data):
                break
            
            nid = struct.unpack('<Q', dir_data[offset:offset+8])[0]
            nameoff = struct.unpack('<H', dir_data[offset+8:offset+10])[0]
            file_type = dir_data[offset+10]
            
            raw_entries.append({
                'nid': nid,
                'nameoff': nameoff,
                'file_type': file_type,
            })
        
        # Now extract names using offsets
        for i, entry in enumerate(raw_entries):
            nameoff = entry['nameoff']
            
            # Name ends at next entry's nameoff, or at end of dir_data
            if i + 1 < len(raw_entries):
                name_end = raw_entries[i + 1]['nameoff']
            else:
                # Last entry - name goes to end of directory data
                name_end = len(dir_data)
            
            # Handle names that might be padded with zeros
            name_bytes = dir_data[nameoff:name_end]
            # Strip trailing nulls and decode
            name_bytes = name_bytes.rstrip(b'\x00')
            
            if name_bytes:
                name = name_bytes.decode('utf-8', errors='ignore')
                entries.append({
                    'nid': entry['nid'],
                    'name': name,
                    'file_type': entry['file_type'],
                })
        
        return entries
    
    def _extract_directory(self, f: BinaryIO, dir_nid: int, path: str,
                           output_dir: str, file_list: Optional[list[str]], 
                           extracted: dict):
        """Recursively extract directory contents."""
        inode = self._read_inode(f, dir_nid)
        if not inode or inode['type'] != 'dir':
            return
        
        entries = self._read_directory_entries(f, inode)
        total = len(entries)
        
        for idx, entry in enumerate(entries):
            name = entry['name']
            if name in ('.', '..'):
                continue
            
            full_path = f"{path}/{name}" if path else name
            
            # Skip if file_list specified and this file not in it
            if file_list and full_path not in file_list:
                # But still recurse into directories
                entry_inode = self._read_inode(f, entry['nid'])
                if entry_inode and entry_inode['type'] == 'dir':
                    self._extract_directory(f, entry['nid'], full_path, output_dir, 
                                           file_list, extracted)
                continue
            
            if self.progress_callback and total > 0:
                self.progress_callback(idx, total, f"Extracting: {full_path}")
            
            entry_inode = self._read_inode(f, entry['nid'])
            if not entry_inode:
                continue
            
            if entry_inode['type'] == 'dir':
                # Create directory and recurse
                dir_path = Path(output_dir) / full_path
                dir_path.mkdir(parents=True, exist_ok=True)
                self._extract_directory(f, entry['nid'], full_path, output_dir,
                                       file_list, extracted)
                
            elif entry_inode['type'] == 'file':
                self._extract_file(f, entry_inode, full_path, output_dir, extracted)
                
            elif entry_inode['type'] == 'symlink':
                self._extract_symlink(f, entry_inode, full_path, output_dir, extracted)
    
    def _extract_file(self, f: BinaryIO, inode: dict, full_path: str,
                      output_dir: str, extracted: dict):
        """Extract a regular file."""
        output_path = Path(output_dir) / full_path
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            data = self._read_file_data(f, inode)
            output_path.write_bytes(data)
            extracted['files'][full_path] = {
                'path': str(output_path),
                'size': len(data),
            }
            logger.debug(f"  Extracted: {full_path} ({len(data)} bytes)")
        except Exception as e:
            extracted['errors'].append({'path': full_path, 'error': str(e)})
            logger.warning(f"  Failed to extract {full_path}: {e}")
    
    def _extract_symlink(self, f: BinaryIO, inode: dict, full_path: str,
                         output_dir: str, extracted: dict):
        """Extract a symbolic link."""
        output_path = Path(output_dir) / full_path
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            target = self._read_file_data(f, inode).decode('utf-8', errors='ignore')
            
            # Write symlink info to a text file
            link_file = output_path.with_suffix(output_path.suffix + '.symlink')
            link_file.write_text(f"SYMLINK -> {target}")
            
            extracted['files'][full_path] = {
                'path': str(link_file),
                'target': target,
                'type': 'symlink',
            }
            logger.debug(f"  Extracted symlink: {full_path} -> {target}")
        except Exception as e:
            extracted['errors'].append({'path': full_path, 'error': str(e)})
    
    def _read_file_data(self, f: BinaryIO, inode: dict) -> bytes:
        """Read file data based on inode layout."""
        layout = inode['layout']
        size = inode['size']
        
        if size == 0:
            return b''
        
        inode_offset = self._nid_to_offset(inode['nid'])
        
        if layout == self.EROFS_INODE_FLAT_INLINE:
            # Data is inline after inode header
            data_offset = inode_offset + inode['inode_size']
            # Account for xattr if present
            if inode.get('xattr_icount', 0) > 0:
                xattr_size = (inode['xattr_icount'] - 1) * 4 + 12
                data_offset += xattr_size
            
            f.seek(data_offset)
            return f.read(size)
        
        elif layout == self.EROFS_INODE_FLAT_PLAIN:
            # Data in separate blocks, uncompressed
            data_offset = inode['raw_blkaddr'] * self.block_size
            f.seek(data_offset)
            return f.read(size)
        
        elif layout == self.EROFS_INODE_FLAT_COMPRESSION or layout == self.EROFS_INODE_FLAT_COMPRESSION_LEGACY:
            # Compressed data
            if not self._lz4_available:
                raise PayloadError(f"LZ4 not available - cannot extract compressed file (layout={layout})")
            
            return self._read_compressed_data(f, inode)
        
        elif layout == self.EROFS_INODE_CHUNK_BASED:
            # Chunk-based - read chunk index
            return self._read_chunked_data(f, inode)
        
        else:
            # Unknown layout - try plain read
            logger.warning(f"Unknown EROFS layout {layout}, attempting plain read")
            data_offset = inode['raw_blkaddr'] * self.block_size
            f.seek(data_offset)
            return f.read(size)
    
    def _read_compressed_data(self, f: BinaryIO, inode: dict) -> bytes:
        """Read and decompress LZ4-compressed data."""
        import lz4.block
        
        size = inode['size']
        raw_blkaddr = inode['raw_blkaddr']
        
        # For compressed files, raw_blkaddr points to compressed data
        # The compression uses LZ4 block format
        
        result = bytearray()
        data_offset = raw_blkaddr * self.block_size
        
        f.seek(data_offset)
        
        # Read compressed blocks and decompress
        # This is simplified - actual EROFS compression is more complex
        remaining = size
        
        while remaining > 0:
            # Read block header (4 bytes for compressed size in simple case)
            f.seek(data_offset)
            compressed_data = f.read(self.block_size * 2)  # Read enough for one pcluster
            
            try:
                # Try to decompress
                decompressed = lz4.block.decompress(compressed_data, uncompressed_size=min(remaining, self.block_size * 4))
                result.extend(decompressed[:remaining])
                remaining -= len(decompressed)
                data_offset += len(compressed_data)
            except:
                # If decompression fails, assume uncompressed
                result.extend(compressed_data[:remaining])
                remaining = 0
        
        return bytes(result[:size])
    
    def _read_chunked_data(self, f: BinaryIO, inode: dict) -> bytes:
        """Read chunk-based file data."""
        # Chunk-based format stores chunk index after inode
        # Each chunk can be stored separately
        
        size = inode['size']
        inode_offset = self._nid_to_offset(inode['nid'])
        
        # For now, try simple sequential read
        data_offset = inode['raw_blkaddr'] * self.block_size
        f.seek(data_offset)
        return f.read(size)

    def repack(self, source_dir: str, output_path: str,
               compression: str = 'lz4',
               block_size: int = 4096,
               uuid: Optional[str] = None,
               volume_name: Optional[str] = None,
               extra_args: Optional[list[str]] = None) -> bool:
        """Repack a directory into an EROFS image using mkfs.erofs.
        
        Args:
            source_dir: Directory containing files to pack
            output_path: Output EROFS image path
            compression: Compression algorithm ('none', 'lz4', 'lzma', 'lz4hc')
            block_size: Block size (default 4096)
            uuid: Optional UUID for the filesystem
            volume_name: Optional volume label
            extra_args: Additional mkfs.erofs arguments
            
        Returns:
            True if successful, False otherwise
        """
        source_path = Path(source_dir).resolve()
        output_file = Path(output_path).resolve()
        
        if not source_path.is_dir():
            logger.error(f"Source directory does not exist: {source_dir}")
            return False
        
        # Find mkfs.erofs
        mkfs_info = self._find_mkfs_erofs()
        if not mkfs_info:
            logger.error("mkfs.erofs not found. Install erofs-utils or use WSL.")
            return False
        
        use_wsl = mkfs_info.get('use_wsl', False)
        mkfs_path = mkfs_info['path']
        
        try:
            # Build arguments
            args = []
            
            # Compression option
            if compression and compression.lower() != 'none':
                args.extend(['-z', compression.lower()])
            
            # Block size
            args.extend(['-b', str(block_size)])
            
            # UUID
            if uuid:
                args.extend(['-U', uuid])
            
            # Volume name/label  
            if volume_name:
                # Truncate to 16 chars (EROFS limit)
                args.extend(['-L', volume_name[:16]])
            
            # Extra arguments
            if extra_args:
                args.extend(extra_args)
            
            if use_wsl:
                # Convert Windows paths to WSL paths
                wsl_output = self._windows_to_wsl_path(str(output_file))
                wsl_source = self._windows_to_wsl_path(str(source_path))
                
                args.append(wsl_output)
                args.append(wsl_source)
                
                cmd = ['wsl', mkfs_path] + args
            else:
                args.append(str(output_file))
                args.append(str(source_path))
                cmd = [mkfs_path] + args
            
            logger.info(f"Creating EROFS image: {' '.join(cmd)}")
            
            if self.progress_callback:
                self.progress_callback(0, 100, "Creating EROFS image...")
            
            # Run mkfs.erofs
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=3600  # 1 hour timeout for large images
            )
            
            if result.returncode != 0:
                logger.error(f"mkfs.erofs failed: {result.stderr}")
                return False
            
            # Parse output for stats
            if result.stderr:
                logger.info(result.stderr)
            
            if self.progress_callback:
                self.progress_callback(100, 100, "EROFS image created")
            
            if output_file.exists():
                size_mb = output_file.stat().st_size / (1024 * 1024)
                logger.info(f"Created EROFS image: {output_path} ({size_mb:.2f} MB)")
                return True
            else:
                logger.error("mkfs.erofs did not create output file")
                return False
                
        except subprocess.TimeoutExpired:
            logger.error("mkfs.erofs timed out")
            return False
        except Exception as e:
            logger.error(f"Failed to create EROFS image: {e}")
            return False
    
    def _windows_to_wsl_path(self, win_path: str) -> str:
        """Convert Windows path to WSL path.
        
        C:\\Users\\name\\file -> /mnt/c/Users/name/file
        """
        path = Path(win_path)
        
        if len(path.parts) > 0 and len(path.parts[0]) == 3 and path.parts[0][1] == ':':
            # Has drive letter like C:\\
            drive = path.parts[0][0].lower()
            rest = '/'.join(path.parts[1:])
            return f"/mnt/{drive}/{rest}"
        
        # Already a Unix-style path or relative
        return str(path).replace('\\', '/')
    
    def _find_mkfs_erofs(self) -> Optional[dict]:
        """Find mkfs.erofs executable.
        
        Checks:
        1. Bundled tools directory (mkfs.erofs.exe)
        2. System PATH (native Windows/Linux)
        3. WSL (if on Windows)
        
        Returns:
            Dict with 'path' and 'use_wsl' keys, or None if not found
        """
        import shutil
        
        # Check Tools directory first (prefer bundled native tools)
        tools_dir = Path(get_app_dir()) / 'tools'
        if tools_dir.exists():
            for candidate in ['mkfs.erofs.exe', 'mkfs.erofs']:
                tool_path = tools_dir / candidate
                if tool_path.exists():
                    return {'path': str(tool_path), 'use_wsl': False}
        
        # Check native PATH
        mkfs = shutil.which('mkfs.erofs')
        if mkfs:
            return {'path': mkfs, 'use_wsl': False}
        
        # On Windows, try WSL
        if sys.platform == 'win32':
            try:
                # Check if WSL is available
                result = subprocess.run(
                    ['wsl', '--list'],
                    capture_output=True,
                    timeout=5,
                    creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0
                )
                if result.returncode == 0:
                    # Check if mkfs.erofs exists in WSL
                    result = subprocess.run(
                        ['wsl', 'which', 'mkfs.erofs'],
                        capture_output=True,
                        text=True,
                        timeout=10
                    )
                    if result.returncode == 0 and result.stdout.strip():
                        return {'path': 'mkfs.erofs', 'use_wsl': True}
            except (subprocess.TimeoutExpired, FileNotFoundError):
                pass
        
        return None
    
    @staticmethod
    def get_repack_options() -> dict:
        """Get available repack options and their descriptions.
        
        Returns:
            Dict of option names to descriptions
        """
        return {
            'compression': {
                'description': 'Compression algorithm',
                'choices': ['none', 'lz4', 'lz4hc', 'lzma'],
                'default': 'lz4',
            },
            'block_size': {
                'description': 'Filesystem block size',
                'choices': [512, 1024, 2048, 4096],
                'default': 4096,
            },
            'uuid': {
                'description': 'Filesystem UUID (auto-generated if not specified)',
                'type': 'string',
                'default': None,
            },
            'volume_name': {
                'description': 'Volume label (max 16 characters)',
                'type': 'string',
                'default': None,
            },
            'dedupe': {
                'description': 'Enable data deduplication',
                'type': 'bool',
                'default': False,
                'extra_arg': '-Ededupe',
            },
            'fragments': {
                'description': 'Enable fragment packing for small files',
                'type': 'bool',
                'default': False,
                'extra_arg': '-Efragments',
            },
            'ztailpacking': {
                'description': 'Inline tail data of compressed files',
                'type': 'bool',
                'default': False,
                'extra_arg': '-Eztailpacking',
            },
        }
    
    def can_repack(self) -> bool:
        """Check if EROFS repacking is available.
        
        Returns:
            True if mkfs.erofs is available (native or via WSL)
        """
        return self._find_mkfs_erofs() is not None
    
    def get_mkfs_info(self) -> Optional[dict]:
        """Get information about the mkfs.erofs installation.
        
        Returns:
            Dict with 'path', 'use_wsl', and 'version' if available
        """
        info = self._find_mkfs_erofs()
        if not info:
            return None
        
        # Try to get version
        try:
            if info['use_wsl']:
                cmd = ['wsl', 'mkfs.erofs', '--version']
            else:
                cmd = [info['path'], '--version']
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                # Parse version from output like "mkfs.erofs 1.7.1"
                for line in (result.stdout + result.stderr).splitlines():
                    if 'mkfs.erofs' in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            info['version'] = parts[-1]
                            break
        except:
            pass
        
        return info


class SuperImageExtractor:
    """Extract partitions from Android super (dynamic partitions) image.
    
    Supports both raw and sparse super images. Sparse images are automatically
    converted to raw format before processing.
    """
    
    LP_METADATA_GEOMETRY_MAGIC = 0x616c4467  # "gDla"
    LP_METADATA_HEADER_MAGIC = 0x414c5030   # "0PLA"
    LP_PARTITION_ATTR_READONLY = (1 << 0)
    LP_PARTITION_ATTR_SLOT_SUFFIXED = (1 << 1)
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
        self._temp_file = None
    
    def _is_sparse(self, input_path: str) -> bool:
        """Check if the file is a sparse image."""
        with open(input_path, 'rb') as f:
            magic = f.read(4)
            if len(magic) >= 4:
                return struct.unpack('<I', magic)[0] == SPARSE_HEADER_MAGIC
        return False
    
    def _get_raw_file(self, input_path: str) -> str:
        """Get path to raw file, converting from sparse if needed."""
        if not self._is_sparse(input_path):
            return input_path
        
        # Convert sparse to raw in temp file
        import tempfile
        
        if self.progress_callback:
            self.progress_callback(0, 100, "Converting sparse super image...")
        
        # Create temp file for raw image
        self._temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.raw')
        temp_path = self._temp_file.name
        self._temp_file.close()
        
        # Convert sparse to raw
        converter = SparseImageConverter(self.progress_callback)
        converter.convert(input_path, temp_path)
        
        return temp_path
    
    def _cleanup_temp(self):
        """Clean up temporary file if created."""
        if self._temp_file:
            try:
                import os
                os.unlink(self._temp_file.name)
            except:
                pass
            self._temp_file = None
    
    def list_partitions(self, input_path: str) -> list[LpMetadataPartition]:
        """List all partitions in a super image."""
        try:
            raw_path = self._get_raw_file(input_path)
            with open(raw_path, 'rb') as f:
                return self._read_metadata(f)
        finally:
            self._cleanup_temp()
    
    def extract(self, input_path: str, output_dir: str, 
                partition_names: Optional[list[str]] = None) -> dict:
        """Extract partitions from super image.
        
        Handles non-contiguous extents properly by reading each extent
        and concatenating them in order. Automatically handles sparse images.
        """
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        
        try:
            raw_path = self._get_raw_file(input_path)
            
            with open(raw_path, 'rb') as f:
                # Read geometry and metadata to get extent info
                f.seek(4096)
                geometry = self._read_geometry(f)
            
                f.seek(geometry['metadata_offset'])
                header = self._read_metadata_header(f)
                
                tables_start = geometry['metadata_offset'] + header['header_size']
                
                # Read all partition entries
                partition_entries = []
                f.seek(tables_start + header['partitions_offset'])
                for _ in range(header['partitions_count']):
                    part_data = f.read(header['partitions_entry_size'])
                    if len(part_data) < 52:
                        break
                    name = part_data[:36].rstrip(b'\x00').decode('utf-8', errors='ignore')
                    attrs, first_extent_idx, num_extents, group_idx = struct.unpack(
                        '<IIII', part_data[36:52]
                    )
                    partition_entries.append({
                        'name': name,
                        'attrs': attrs,
                        'first_extent_idx': first_extent_idx,
                        'num_extents': num_extents
                    })
                
                # Read all extents
                extents = []
                f.seek(tables_start + header['extents_offset'])
                for _ in range(header['extents_count']):
                    extent_data = f.read(header['extents_entry_size'])
                    if len(extent_data) >= 24:
                        num_sectors, target_type, target_data, target_source = struct.unpack(
                            '<QIIQ', extent_data[:24]
                        )
                        extents.append({
                            'num_sectors': num_sectors,
                            'target_type': target_type,
                            'target_data': target_data,
                            'target_source': target_source
                        })
                
                # Filter partitions if specific names requested
                if partition_names:
                    partition_entries = [p for p in partition_entries if p['name'] in partition_names]
                
                extracted = {}
                total = len(partition_entries)
                
                for idx, part in enumerate(partition_entries):
                    if part['num_extents'] == 0:
                        logger.info(f"  Skipping empty partition: {part['name']}")
                        continue
                    
                    # Calculate total size
                    total_size = 0
                    for i in range(part['num_extents']):
                        ext_idx = part['first_extent_idx'] + i
                        if ext_idx < len(extents):
                            total_size += extents[ext_idx]['num_sectors'] * 512
                    
                    logger.info(f"  Extracting {part['name']}: {total_size / (1024*1024):.2f} MB ({part['num_extents']} extents)")
                    
                    output_path = Path(output_dir) / f"{part['name']}.img"
                    
                    with open(output_path, 'wb') as f_out:
                        # Process each extent
                        for i in range(part['num_extents']):
                            ext_idx = part['first_extent_idx'] + i
                            if ext_idx >= len(extents):
                                break
                            
                            ext = extents[ext_idx]
                            
                            if ext['target_type'] == 0:  # Linear extent
                                # Read from physical sector
                                offset = ext['target_data'] * 512
                                size = ext['num_sectors'] * 512
                                
                                f.seek(offset)
                                remaining = size
                                chunk_size = 64 * 1024 * 1024  # 64MB chunks
                                
                                while remaining > 0:
                                    to_read = min(chunk_size, remaining)
                                    data = f.read(to_read)
                                    if not data:
                                        break
                                    f_out.write(data)
                                    remaining -= len(data)
                            
                            elif ext['target_type'] == 1:  # Zero extent
                                # Write zeros
                                size = ext['num_sectors'] * 512
                                zero_chunk = b'\x00' * min(64 * 1024 * 1024, size)
                                remaining = size
                                while remaining > 0:
                                    to_write = min(len(zero_chunk), remaining)
                                    f_out.write(zero_chunk[:to_write])
                                    remaining -= to_write
                    
                    extracted[part['name']] = str(output_path)
                    
                    if self.progress_callback:
                        self.progress_callback(idx + 1, total, f"Extracted {part['name']}")
                
                return extracted
        finally:
            self._cleanup_temp()
    
    def _read_metadata(self, f: BinaryIO) -> list[LpMetadataPartition]:
        """Read LP metadata and return partition list.
        
        Super partition layout:
        - Metadata starts at offset 12288 (0x3000)
        - First comes the header (usually 128 bytes)
        - Then comes the tables (partitions, extents, groups, block_devices)
        - The offsets in table_descriptors are relative to the start of tables
        """
        # Read geometry at offset 4096
        f.seek(4096)
        geometry = self._read_geometry(f)
        
        # Read metadata header
        f.seek(geometry['metadata_offset'])
        header = self._read_metadata_header(f)
        
        # Tables start right after the header
        tables_start = geometry['metadata_offset'] + header['header_size']
        
        # Read all partitions first
        partitions = []
        partition_entries = []
        
        f.seek(tables_start + header['partitions_offset'])
        for _ in range(header['partitions_count']):
            part_data = f.read(header['partitions_entry_size'])
            if len(part_data) < 52:
                break
            
            name = part_data[:36].rstrip(b'\x00').decode('utf-8', errors='ignore')
            attrs, first_extent_idx, num_extents, group_idx = struct.unpack(
                '<IIII', part_data[36:52]
            )
            partition_entries.append({
                'name': name,
                'attrs': attrs,
                'first_extent_idx': first_extent_idx,
                'num_extents': num_extents,
                'group_idx': group_idx
            })
        
        # Read all extents
        extents = []
        f.seek(tables_start + header['extents_offset'])
        for _ in range(header['extents_count']):
            extent_data = f.read(header['extents_entry_size'])
            if len(extent_data) >= 24:
                num_sectors, target_type, target_data, target_source = struct.unpack(
                    '<QIIQ', extent_data[:24]
                )
                extents.append({
                    'num_sectors': num_sectors,
                    'target_type': target_type,  # 0 = linear, 1 = zero
                    'target_data': target_data,  # physical sector for linear, unused for zero
                    'target_source': target_source  # device index
                })
        
        # Build partition list with total size from all extents
        for part in partition_entries:
            if part['num_extents'] > 0:
                total_size = 0
                first_sector = None
                
                for i in range(part['num_extents']):
                    ext_idx = part['first_extent_idx'] + i
                    if ext_idx < len(extents):
                        ext = extents[ext_idx]
                        total_size += ext['num_sectors'] * 512
                        # Use the first linear extent's sector as the start
                        if first_sector is None and ext['target_type'] == 0:
                            first_sector = ext['target_data']
                
                if first_sector is not None:
                    partitions.append(LpMetadataPartition(
                        name=part['name'],
                        group_name="",
                        first_sector=first_sector,
                        size=total_size,
                        attributes=part['attrs']
                    ))
        
        return partitions
        
        return partitions
    
    def _read_geometry(self, f: BinaryIO) -> dict:
        """Read LP metadata geometry.
        
        Super partition layout:
        - Offset 0x0000-0x0FFF (0-4095): Reserved/empty
        - Offset 0x1000-0x1FFF (4096-8191): Primary geometry (LP_METADATA_GEOMETRY_SIZE = 4096)
        - Offset 0x2000-0x2FFF (8192-12287): Backup geometry (LP_METADATA_GEOMETRY_SIZE = 4096)
        - Offset 0x3000+ (12288+): Metadata slots
        
        LpMetadataGeometry structure:
        - 0-3: magic (4 bytes) - 0x616c4467 "gDla"
        - 4-7: struct_size (4 bytes)
        - 8-39: checksum (32 bytes SHA-256)
        - 40-43: metadata_max_size (4 bytes)
        - 44-47: metadata_slot_count (4 bytes)
        - 48-51: logical_block_size (4 bytes)
        """
        data = f.read(4096)
        
        magic = struct.unpack('<I', data[:4])[0]
        if magic != self.LP_METADATA_GEOMETRY_MAGIC:
            raise PayloadError(f"Invalid LP geometry magic: {hex(magic)}")
        
        struct_size = struct.unpack('<I', data[4:8])[0]
        # checksum is 32 bytes at offset 8-39
        metadata_max_size = struct.unpack('<I', data[40:44])[0]
        metadata_slot_count = struct.unpack('<I', data[44:48])[0]
        logical_block_size = struct.unpack('<I', data[48:52])[0]
        
        # Metadata starts after: primary geometry (4096) + backup geometry (4096) = offset 12288
        # But we're already at offset 8192 after reading primary geometry
        # So metadata is at: 4096 (start of geo) + 4096 (primary geo) + 4096 (backup geo) = 12288
        return {
            'metadata_max_size': metadata_max_size,
            'metadata_slot_count': metadata_slot_count,
            'logical_block_size': logical_block_size,
            'metadata_offset': 4096 + 4096 + 4096  # 12288 - after primary + backup geometry
        }
    
    def _read_metadata_header(self, f: BinaryIO) -> dict:
        """Read LP metadata header.
        
        LpMetadataHeader structure:
        - 0-3: magic (4 bytes) - 0x414C5030 "0PLA"
        - 4-5: major_version (2 bytes)
        - 6-7: minor_version (2 bytes)  
        - 8-11: header_size (4 bytes)
        - 12-43: header_checksum (32 bytes SHA-256)
        - 44-47: tables_size (4 bytes)
        - 48-79: tables_checksum (32 bytes SHA-256)
        - 80-83: partitions.offset (4 bytes)
        - 84-87: partitions.num_entries (4 bytes)
        - 88-91: partitions.entry_size (4 bytes)
        - 92-95: extents.offset (4 bytes)
        - 96-99: extents.num_entries (4 bytes)
        - 100-103: extents.entry_size (4 bytes)
        - 104-107: groups.offset (4 bytes)
        - 108-111: groups.num_entries (4 bytes)
        - 112-115: groups.entry_size (4 bytes)
        - 116-119: block_devices.offset (4 bytes)
        - 120-123: block_devices.num_entries (4 bytes)
        - 124-127: block_devices.entry_size (4 bytes)
        """
        data = f.read(256)
        
        magic = struct.unpack('<I', data[:4])[0]
        if magic != self.LP_METADATA_HEADER_MAGIC:
            raise PayloadError(f"Invalid LP metadata magic: {hex(magic)}")
        
        major, minor = struct.unpack('<HH', data[4:8])
        header_size = struct.unpack('<I', data[8:12])[0]
        # header_checksum is 32 bytes at offset 12-43
        tables_size = struct.unpack('<I', data[44:48])[0]
        # tables_checksum is 32 bytes at offset 48-79
        
        # Table descriptors start at offset 80
        partitions_offset, partitions_count, partitions_entry_size = struct.unpack(
            '<III', data[80:92]
        )
        extents_offset, extents_count, extents_entry_size = struct.unpack(
            '<III', data[92:104]
        )
        groups_offset, groups_count, groups_entry_size = struct.unpack(
            '<III', data[104:116]
        )
        
        return {
            'major': major,
            'minor': minor,
            'header_size': header_size,
            'tables_size': tables_size,
            'partitions_offset': partitions_offset,
            'partitions_count': partitions_count,
            'partitions_entry_size': partitions_entry_size,
            'extents_offset': extents_offset,
            'extents_count': extents_count,
            'extents_entry_size': extents_entry_size,
            'groups_offset': groups_offset,
            'groups_count': groups_count,
            'groups_entry_size': groups_entry_size,
        }


class SuperImageCreator:
    """Create Android super (dynamic partition) images.
    
    This is a pure Python implementation of lpmake functionality.
    Creates a super.img with LP metadata and partition data.
    """
    
    LP_METADATA_GEOMETRY_MAGIC = 0x616c4467  # "gDla"
    LP_METADATA_HEADER_MAGIC = 0x414c5030   # "0PLA"
    LP_SECTOR_SIZE = 512
    LP_METADATA_GEOMETRY_SIZE = 4096
    LP_METADATA_HEADER_SIZE = 256
    LP_PARTITION_ENTRY_SIZE = 52
    LP_EXTENT_ENTRY_SIZE = 24
    LP_GROUP_ENTRY_SIZE = 48
    
    # Partition attributes
    LP_PARTITION_ATTR_READONLY = (1 << 0)
    LP_PARTITION_ATTR_SLOT_SUFFIXED = (1 << 1)
    LP_PARTITION_ATTR_UPDATED = (1 << 2)
    LP_PARTITION_ATTR_DISABLED = (1 << 3)
    
    def __init__(self, progress_callback: Optional[Callable] = None):
        self.progress_callback = progress_callback
        self.partitions = []  # List of (name, image_path, group_name, readonly)
        self.groups = {}  # group_name -> max_size
        self.metadata_size = 65536  # 64KB default
        self.metadata_slots = 2  # A/B slots
        self.block_size = 4096
        self.super_size = 0  # Will be calculated or set
        self.sparse_output = False
    
    def add_partition(self, name: str, image_path: str, group_name: str = "default", 
                      readonly: bool = True) -> 'SuperImageCreator':
        """Add a partition to the super image.
        
        Args:
            name: Partition name (e.g., 'system', 'vendor')
            image_path: Path to the partition image file
            group_name: Partition group name
            readonly: Whether partition should be read-only
        """
        self.partitions.append({
            'name': name,
            'image_path': image_path,
            'group_name': group_name,
            'readonly': readonly,
            'size': os.path.getsize(image_path) if os.path.exists(image_path) else 0
        })
        return self
    
    def add_group(self, name: str, max_size: int) -> 'SuperImageCreator':
        """Add a partition group with maximum size.
        
        Args:
            name: Group name (e.g., 'qti_dynamic_partitions')
            max_size: Maximum size for all partitions in group
        """
        self.groups[name] = max_size
        return self
    
    def set_metadata_size(self, size: int) -> 'SuperImageCreator':
        """Set metadata region size (default 65536)."""
        self.metadata_size = size
        return self
    
    def set_super_size(self, size: int) -> 'SuperImageCreator':
        """Set total super partition size."""
        self.super_size = size
        return self
    
    def set_block_size(self, size: int) -> 'SuperImageCreator':
        """Set logical block size (default 4096)."""
        self.block_size = size
        return self
    
    def set_sparse(self, sparse: bool) -> 'SuperImageCreator':
        """Output as sparse image."""
        self.sparse_output = sparse
        return self
    
    def create(self, output_path: str) -> bool:
        """Create the super.img file.
        
        Args:
            output_path: Path for output super.img
            
        Returns:
            True if successful
        """
        try:
            # Validate inputs
            if not self.partitions:
                raise PayloadError("No partitions added")
            
            # Ensure all partitions have a group
            for part in self.partitions:
                if part['group_name'] not in self.groups:
                    # Auto-create group with enough space
                    total_size = sum(p['size'] for p in self.partitions 
                                    if p['group_name'] == part['group_name'])
                    self.groups[part['group_name']] = total_size + 1024 * 1024  # Add 1MB buffer
            
            # Calculate required size
            total_partition_size = sum(p['size'] for p in self.partitions)
            metadata_region_size = self.metadata_size * self.metadata_slots * 2  # Primary + backup
            
            # Align to block size
            data_start = self._align_up(4096 + metadata_region_size, self.block_size)
            required_size = data_start + self._align_up(total_partition_size, self.block_size)
            
            if self.super_size == 0:
                # Auto-calculate with 5% buffer
                self.super_size = self._align_up(int(required_size * 1.05), self.block_size)
            elif self.super_size < required_size:
                raise PayloadError(f"Super size {self.super_size} too small for partitions ({required_size} needed)")
            
            logger.info(f"Creating super.img: {output_path}")
            logger.info(f"  Total size: {self.super_size / (1024*1024):.2f} MB")
            logger.info(f"  Partitions: {len(self.partitions)}")
            logger.info(f"  Groups: {len(self.groups)}")
            logger.info(f"  Metadata size: {self.metadata_size}")
            logger.info(f"  Data starts at: {data_start}")
            
            # Create the image
            with open(output_path, 'wb') as f:
                # Write primary geometry at offset 4096
                f.seek(4096)
                self._write_geometry(f)
                
                # Write primary metadata
                f.seek(4096 + self.LP_METADATA_GEOMETRY_SIZE)
                partition_offsets = self._write_metadata(f, data_start)
                
                # Write backup geometry
                backup_geometry_offset = 4096 + self.metadata_size
                f.seek(backup_geometry_offset)
                self._write_geometry(f)
                
                # Write backup metadata
                f.seek(backup_geometry_offset + self.LP_METADATA_GEOMETRY_SIZE)
                self._write_metadata(f, data_start)
                
                # Write partition data
                self._write_partition_data(f, partition_offsets)
                
                # Pad to super_size
                f.seek(self.super_size - 1)
                f.write(b'\x00')
            
            # Convert to sparse if requested
            if self.sparse_output:
                logger.info("Converting to sparse format...")
                sparse_path = output_path + '.sparse'
                converter = SparseImageCreator(self.block_size, self.progress_callback)
                if converter.convert(output_path, sparse_path):
                    os.replace(sparse_path, output_path)
            
            logger.info(f"Super image created: {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to create super image: {e}")
            if os.path.exists(output_path):
                os.remove(output_path)
            raise
    
    def _align_up(self, value: int, alignment: int) -> int:
        """Align value up to alignment boundary."""
        return ((value + alignment - 1) // alignment) * alignment
    
    def _write_geometry(self, f: BinaryIO):
        """Write LP metadata geometry."""
        # Geometry structure:
        # magic (4) + struct_size (4) + checksum (4) + 
        # metadata_max_size (4) + metadata_slot_count (4) + logical_block_size (4)
        
        geometry = struct.pack('<III',
            self.LP_METADATA_GEOMETRY_MAGIC,
            40,  # struct_size
            0    # checksum (will be calculated)
        )
        geometry += struct.pack('<III',
            self.metadata_size,
            self.metadata_slots,
            self.block_size
        )
        
        # Pad to 4096 bytes
        geometry = geometry.ljust(self.LP_METADATA_GEOMETRY_SIZE, b'\x00')
        f.write(geometry)
    
    def _write_metadata(self, f: BinaryIO, data_start: int) -> dict:
        """Write LP metadata header and tables. Returns partition offsets."""
        
        # Calculate table sizes
        partitions_count = len(self.partitions)
        extents_count = len(self.partitions)  # One extent per partition
        groups_count = len(self.groups)
        
        partitions_size = partitions_count * self.LP_PARTITION_ENTRY_SIZE
        extents_size = extents_count * self.LP_EXTENT_ENTRY_SIZE
        groups_size = groups_count * self.LP_GROUP_ENTRY_SIZE
        
        tables_size = partitions_size + extents_size + groups_size
        
        # Build partition offsets
        partition_offsets = {}
        current_offset = data_start
        
        for i, part in enumerate(self.partitions):
            aligned_size = self._align_up(part['size'], self.block_size)
            partition_offsets[part['name']] = {
                'offset': current_offset,
                'size': part['size'],
                'aligned_size': aligned_size,
                'extent_index': i
            }
            current_offset += aligned_size
        
        # Write header
        header = struct.pack('<I', self.LP_METADATA_HEADER_MAGIC)  # magic
        header += struct.pack('<HH', 10, 2)  # major, minor version
        header += struct.pack('<II', self.LP_METADATA_HEADER_SIZE, 0)  # header_size, checksum
        header += struct.pack('<II', tables_size, 0)  # tables_size, tables_checksum
        
        # Partition table info
        header += struct.pack('<III', 0, partitions_count, self.LP_PARTITION_ENTRY_SIZE)
        # Extent table info  
        header += struct.pack('<III', partitions_size, extents_count, self.LP_EXTENT_ENTRY_SIZE)
        # Group table info
        header += struct.pack('<III', partitions_size + extents_size, groups_count, self.LP_GROUP_ENTRY_SIZE)
        
        # Pad header
        header = header.ljust(self.LP_METADATA_HEADER_SIZE, b'\x00')
        f.write(header)
        
        # Write partition entries
        group_names = list(self.groups.keys())
        for i, part in enumerate(self.partitions):
            attrs = 0
            if part['readonly']:
                attrs |= self.LP_PARTITION_ATTR_READONLY
            
            group_idx = group_names.index(part['group_name']) if part['group_name'] in group_names else 0
            
            # Partition entry: name[36] + attrs(4) + first_extent_index(4) + num_extents(4) + group_index(4)
            name_bytes = part['name'].encode('utf-8')[:36].ljust(36, b'\x00')
            entry = name_bytes + struct.pack('<IIII', attrs, i, 1, group_idx)
            f.write(entry)
        
        # Write extent entries
        for part in self.partitions:
            pinfo = partition_offsets[part['name']]
            # Extent: num_sectors(8) + target_type(4) + target_data(8) + target_source(4)
            num_sectors = pinfo['aligned_size'] // self.LP_SECTOR_SIZE
            target_data = pinfo['offset'] // self.LP_SECTOR_SIZE
            extent = struct.pack('<QIQI', num_sectors, 0, target_data, 0)
            f.write(extent)
        
        # Write group entries
        for group_name, max_size in self.groups.items():
            # Group: name[36] + flags(4) + max_size(8)
            name_bytes = group_name.encode('utf-8')[:36].ljust(36, b'\x00')
            entry = name_bytes + struct.pack('<IQ', 0, max_size)
            entry = entry.ljust(self.LP_GROUP_ENTRY_SIZE, b'\x00')
            f.write(entry)
        
        return partition_offsets
    
    def _write_partition_data(self, f: BinaryIO, partition_offsets: dict):
        """Write actual partition data."""
        total = len(self.partitions)
        
        for idx, part in enumerate(self.partitions):
            pinfo = partition_offsets[part['name']]
            
            logger.info(f"  Writing {part['name']}: {part['size'] / (1024*1024):.2f} MB at offset {pinfo['offset']}")
            
            if self.progress_callback:
                self.progress_callback(idx, total, f"Writing {part['name']}...")
            
            f.seek(pinfo['offset'])
            
            # Copy partition data
            with open(part['image_path'], 'rb') as src:
                remaining = part['size']
                chunk_size = 64 * 1024 * 1024  # 64MB chunks
                
                while remaining > 0:
                    to_read = min(chunk_size, remaining)
                    data = src.read(to_read)
                    if not data:
                        break
                    f.write(data)
                    remaining -= len(data)
            
            # Pad to aligned size
            padding = pinfo['aligned_size'] - part['size']
            if padding > 0:
                f.write(b'\x00' * padding)
        
        if self.progress_callback:
            self.progress_callback(total, total, "Complete")


class AndroidImageExtractor:
    """Main class for extracting various Android image formats."""
    
    def __init__(self, input_path: Optional[str] = None, progress_callback: Optional[Callable] = None):
        self.input_path = input_path
        self.progress_callback = progress_callback
    
    def analyze(self, input_path: Optional[str] = None) -> dict:
        """Analyze an image file and return information about it."""
        path = input_path or self.input_path
        if not path:
            raise ValueError("No input path provided")
        
        img_type = detect_image_type(path)
        file_size = os.path.getsize(path)
        
        info = {
            'path': path,
            'type': img_type,
            'size': file_size,
            'size_human': f"{file_size / (1024*1024):.2f} MB"
        }
        
        if img_type == 'sparse':
            with open(path, 'rb') as f:
                header = SparseImageConverter()._read_header(f)
                info['sparse_blocks'] = header.total_blocks
                info['sparse_block_size'] = header.block_size
                info['raw_size'] = header.total_blocks * header.block_size
                info['raw_size_human'] = f"{info['raw_size'] / (1024*1024):.2f} MB"
        
        elif img_type == 'boot':
            with open(path, 'rb') as f:
                extractor = BootImageExtractor()
                boot_info = extractor._parse_header(f)
                info['header_version'] = boot_info.header_version
                info['page_size'] = boot_info.page_size
                info['kernel_size'] = boot_info.kernel_size
                info['ramdisk_size'] = boot_info.ramdisk_size
                info['cmdline'] = boot_info.cmdline[:100] + '...' if len(boot_info.cmdline) > 100 else boot_info.cmdline
        
        elif img_type == 'vendor_boot':
            with open(path, 'rb') as f:
                extractor = BootImageExtractor()
                boot_info = extractor._parse_header(f)
                info['header_version'] = boot_info.header_version
                info['page_size'] = boot_info.page_size
                info['vendor_ramdisk_size'] = boot_info.ramdisk_size
                info['dtb_size'] = boot_info.dtb_size
                info['cmdline'] = boot_info.cmdline[:100] + '...' if len(boot_info.cmdline) > 100 else boot_info.cmdline
                # Build contents list for extraction
                contents = []
                if boot_info.ramdisk_size > 0:
                    contents.append({'name': 'vendor_ramdisk', 'size': boot_info.ramdisk_size, 'type': 'ramdisk'})
                if boot_info.dtb_size > 0:
                    contents.append({'name': 'dtb', 'size': boot_info.dtb_size, 'type': 'dtb'})
                if contents:
                    info['contents'] = contents
        
        elif img_type == 'super':
            extractor = SuperImageExtractor()
            partitions = extractor.list_partitions(path)
            info['partitions'] = [
                {'name': p.name, 'size': p.size, 'size_human': f"{p.size / (1024*1024):.2f} MB"}
                for p in partitions if p.size > 0
            ]
        
        elif img_type == 'fat':
            extractor = FatImageExtractor()
            try:
                files = extractor.list_files(path)
                with open(path, 'rb') as f:
                    boot_sector = extractor._read_boot_sector(f)
                info['fat_type'] = boot_sector['fat_type']
                info['cluster_size'] = boot_sector['cluster_size']
                info['file_count'] = len(files)
                # Build contents list for extraction
                info['contents'] = [
                    {'name': f['name'], 'size': f['size'], 'type': 'file'}
                    for f in files
                ]
            except Exception as e:
                info['error'] = str(e)
        
        elif img_type == 'ext4':
            extractor = Ext4ImageExtractor()
            try:
                files = extractor.list_files(path)
                info['filesystem'] = 'ext4'
                info['file_count'] = len(files)
                # Build contents list for extraction
                info['contents'] = [
                    {'name': f['name'], 'size': f['size'], 'type': f.get('type', 'file')}
                    for f in files
                ]
            except Exception as e:
                info['error'] = str(e)
        
        elif img_type == 'erofs':
            info['filesystem'] = 'erofs'
            try:
                extractor = ErofsImageExtractor(self.progress_callback)
                erofs_info = extractor.analyze(path)
                info['block_size'] = erofs_info.get('block_size', 0)
                info['total_blocks'] = erofs_info.get('total_blocks', 0)
                info['total_inodes'] = erofs_info.get('total_inodes', 0)
                info['volume_name'] = erofs_info.get('volume_name', '')
                info['features'] = erofs_info.get('features', [])
                
                # List files for contents
                files = extractor.list_files(path, max_depth=2)  # Limit depth for quick scan
                info['file_count'] = len(files)
                info['contents'] = [
                    {'name': f['path'], 'size': f['size'], 'type': f.get('type', 'file')}
                    for f in files[:100]  # Limit shown contents
                ]
            except Exception as e:
                info['error'] = str(e)
        
        elif img_type == 'elf':
            # Parse ELF header for info
            with open(path, 'rb') as f:
                e_ident = f.read(16)
                is_64bit = e_ident[4] == 2
                is_le = e_ident[5] == 1
                endian = '<' if is_le else '>'
                
                if is_64bit:
                    f.seek(16)
                    header_data = f.read(48)
                    e_type, e_machine, _, e_entry, e_phoff, e_shoff, _, _, e_phentsize, e_phnum = struct.unpack(
                        f'{endian}HHIQQQIHH', header_data[:40])
                else:
                    f.seek(16)
                    header_data = f.read(36)
                    e_type, e_machine, _, e_entry, e_phoff, e_shoff, _, _, e_phentsize, e_phnum = struct.unpack(
                        f'{endian}HHIIIIIHH', header_data[:28])
                
                machine_names = {
                    0: "None", 3: "Intel 386", 8: "MIPS", 40: "ARM",
                    62: "x86-64", 164: "Qualcomm Hexagon", 183: "AArch64",
                }
                type_names = {0: "NONE", 1: "REL", 2: "EXEC", 3: "DYN", 4: "CORE"}
                
                info['elf_class'] = '64-bit' if is_64bit else '32-bit'
                info['elf_type'] = type_names.get(e_type, f"0x{e_type:X}")
                info['elf_machine'] = machine_names.get(e_machine, f"0x{e_machine:X}")
                info['elf_entry'] = f"0x{e_entry:X}"
                info['elf_segments'] = e_phnum
                info['note'] = 'ELF firmware/executable - can extract program segments'
        
        elif img_type == 'vbmeta':
            # Parse vbmeta header for info
            extractor = VbmetaExtractor(path, '')
            with open(path, 'rb') as f:
                extractor._parse_header(f)
                extractor._parse_descriptors(f)
            
            info['avb_version'] = f"{extractor.header['version_major']}.{extractor.header['version_minor']}"
            info['algorithm'] = extractor.header['algorithm_name']
            info['rollback_index'] = extractor.header['rollback_index']
            info['flags'] = ', '.join(extractor.header['flags_decoded'])
            info['release'] = extractor.header['release_string']
            info['descriptors'] = len(extractor.descriptors)
            
            # Get referenced partitions
            partitions = extractor.get_partition_info()
            if partitions:
                info['contents'] = [
                    {'name': p['name'], 'size': p['size'], 'type': p['type']}
                    for p in partitions
                ]
            info['note'] = 'AVB vbmeta - contains verification data for partitions'
        
        elif img_type == 'dtbo':
            # Parse DTBO (Device Tree Blob Overlay) image
            extractor = DtboExtractor()
            analysis = extractor.analyze(path)
            
            if analysis['valid']:
                info['dtbo_version'] = analysis['version']
                info['entry_count'] = analysis['entry_count']
                info['page_size'] = analysis['page_size']
                info['total_size'] = analysis['total_size']
                info['contents'] = [
                    {
                        'name': f"dtbo_{e['index']:02d}",
                        'size': e['size'],
                        'id': f"0x{e['id']:08X}",
                        'info': e['info'][:40] if e['info'] else ''
                    }
                    for e in analysis['entries']
                ]
                info['note'] = f"DTBO v{analysis['version']} - {analysis['entry_count']} device tree overlays"
            else:
                info['note'] = 'DTBO - invalid or unsupported format'
        
        elif img_type == 'abl':
            # Analyze ABL (Android Bootloader) - critical for LG, Pixel, and other devices
            analyzer = AblAnalyzer(path)
            abl_info = analyzer.analyze()
            
            info['abl_format'] = abl_info.get('format', 'Unknown')
            info['abl_size'] = abl_info.get('size', 0)
            info['is_elf'] = abl_info.get('is_elf', False)
            info['is_64bit'] = abl_info.get('is_64bit', False)
            info['unlock_checks'] = len(abl_info.get('unlock_checks', []))
            info['secure_boot_refs'] = len(abl_info.get('secure_boot', []))
            info['avb_references'] = len(abl_info.get('avb_references', []))
            info['anti_rollback_refs'] = len(abl_info.get('anti_rollback', []))
            info['lg_specific'] = len(abl_info.get('lg_specific', []))
            info['pixel_specific'] = len(abl_info.get('pixel_specific', []))
            info['fastboot_commands'] = len(abl_info.get('fastboot_commands', []))
            info['is_lg_device'] = analyzer.is_lg_device()
            info['is_pixel_device'] = analyzer.is_pixel_device()
            info['note'] = f"ABL ({abl_info.get('format', 'Unknown')}) - unlock checks, AVB, fastboot"
            if info['is_lg_device']:
                info['note'] += ' - LG device (LAF mode)'
            if info['is_pixel_device']:
                info['note'] += ' - Google Pixel/Tensor device'
        
        elif img_type == 'bootloader':
            # Analyze bootloader image
            analyzer = BootloaderImageAnalyzer(path, '')
            bl_info = analyzer.analyze()
            
            info['bl_format'] = bl_info.get('format', 'Unknown')
            info['bl_type'] = bl_info.get('type', 'Unknown')
            if 'description' in bl_info:
                info['description'] = bl_info['description']
            if 'machine' in bl_info:
                info['machine'] = bl_info['machine']
            if 'elf_class' in bl_info:
                info['elf_class'] = bl_info['elf_class']
            if 'entry_point' in bl_info:
                info['entry_point'] = bl_info['entry_point']
            if 'segments' in bl_info:
                info['segments'] = bl_info['segments']
            if 'is_signed' in bl_info:
                info['is_signed'] = bl_info['is_signed']
            if 'qcom_signed' in bl_info:
                info['qcom_signed'] = bl_info['qcom_signed']
            if 'qc_version' in bl_info:
                info['qc_version'] = bl_info['qc_version']
            if 'build_date' in bl_info:
                info['build_date'] = bl_info['build_date']
            if 'build_time' in bl_info:
                info['build_time'] = bl_info['build_time']
            info['note'] = 'Bootloader/firmware image - can extract segments and info'
        
        return info
    
    def extract(self, input_path: Optional[str] = None, output_dir: str = '', 
                partition_names: Optional[list[str]] = None) -> dict:
        """Extract contents from an Android image."""
        path = input_path or self.input_path
        if not path:
            raise ValueError("No input path provided")
        img_type = detect_image_type(path)
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        
        logger.info(f"Image type: {img_type}")
        
        if img_type == 'sparse':
            logger.info("Converting sparse image to raw...")
            output_path = Path(output_dir) / (Path(path).stem + '_raw.img')
            converter = SparseImageConverter(self.progress_callback)
            converter.convert(path, str(output_path))
            return {'type': 'sparse', 'output': str(output_path)}
        
        elif img_type == 'boot' or img_type == 'vendor_boot':
            logger.info("Extracting boot image components...")
            extractor = BootImageExtractor(self.progress_callback)
            extracted = extractor.extract(path, output_dir)
            return {'type': img_type, 'components': extracted}
        
        elif img_type == 'super':
            logger.info("Extracting dynamic partitions from super image...")
            extractor = SuperImageExtractor(self.progress_callback)
            extracted = extractor.extract(path, output_dir, partition_names)
            return {'type': 'super', 'partitions': extracted}
        
        elif img_type == 'fat':
            logger.info("Extracting files from FAT filesystem image...")
            extractor = FatImageExtractor(self.progress_callback)
            extracted = extractor.extract(path, output_dir, partition_names)
            return {'type': 'fat', 'files': extracted}
        
        elif img_type == 'ext4':
            logger.info("Extracting files from ext4 filesystem image...")
            extractor = Ext4ImageExtractor(self.progress_callback)
            extracted = extractor.extract(path, output_dir, partition_names)
            return {'type': 'ext4', 'files': extracted}
        
        elif img_type == 'erofs':
            logger.info("Extracting files from EROFS filesystem image...")
            extractor = ErofsImageExtractor(self.progress_callback)
            extracted = extractor.extract(path, output_dir, partition_names)
            return {'type': 'erofs', 'files': extracted.get('files', {}),
                    'errors': extracted.get('errors', [])}
        
        elif img_type == 'elf':
            logger.info("Extracting segments from ELF file...")
            extractor = ElfImageExtractor(path, output_dir, self.progress_callback)
            success = extractor.extract()
            if success:
                return {'type': 'elf', 'segments': len(extractor.segments), 
                        'info': extractor.header}
            else:
                return {'type': 'elf', 'error': 'Failed to extract ELF segments'}
        
        elif img_type == 'abl':
            logger.info("Analyzing ABL (Android Bootloader)...")
            analyzer = AblAnalyzer(path, output_dir, self.progress_callback)
            analysis = analyzer.analyze()
            report_path = analyzer.write_report()
            
            # Also extract ELF segments if it's an ELF file
            segments_count = 0
            if analysis.get('is_elf', False):
                elf_extractor = ElfImageExtractor(path, output_dir, self.progress_callback)
                elf_extractor.extract()
                segments_count = len(elf_extractor.segments)
            
            return {
                'type': 'abl',
                'analysis': analysis,
                'report': report_path,
                'summary': analyzer.get_summary(),
                'is_lg': analyzer.is_lg_device(),
                'unlock_checks': len(analysis.get('unlock_checks', [])),
                'segments': segments_count,
            }
        
        elif img_type == 'vbmeta':
            logger.info("Parsing AVB vbmeta image...")
            extractor = VbmetaExtractor(path, output_dir, self.progress_callback)
            success = extractor.extract()
            if success:
                return {'type': 'vbmeta', 'descriptors': len(extractor.descriptors),
                        'partitions': extractor.get_partition_info(),
                        'header': extractor.header}
            else:
                return {'type': 'vbmeta', 'error': 'Failed to parse vbmeta'}
        
        elif img_type == 'dtbo':
            logger.info("Extracting DTBO overlays...")
            extractor = DtboExtractor(self.progress_callback)
            analysis = extractor.analyze(path)
            if analysis['valid']:
                extracted = extractor.extract(path, output_dir)
                return {
                    'type': 'dtbo',
                    'version': analysis['version'],
                    'entry_count': analysis['entry_count'],
                    'extracted': extracted,
                    'entries': analysis['entries']
                }
            else:
                return {'type': 'dtbo', 'error': 'Invalid DTBO format'}
        
        elif img_type == 'bootloader':
            logger.info("Analyzing bootloader image...")
            analyzer = BootloaderImageAnalyzer(path, output_dir, self.progress_callback)
            success = analyzer.extract()
            if success:
                return {'type': 'bootloader', 'info': analyzer.info,
                        'segments': len(analyzer.segments)}
            else:
                return {'type': 'bootloader', 'error': 'Failed to analyze bootloader'}
        
        elif img_type == 'raw':
            logger.info(f"Raw/unknown format - cannot extract")
            return {'type': 'raw', 'note': 'Unknown format, cannot extract'}
        
        else:
            return {'type': 'unknown', 'error': 'Unknown image format'}


def run_image_extract(args) -> None:
    """Run image extraction from command line."""
    input_path = args.image_path
    
    if not os.path.exists(input_path):
        raise PayloadError(f"Image file not found: {input_path}")
    
    extractor = AndroidImageExtractor(
        progress_callback=lambda cur, tot, msg: logger.info(f"  [{int(cur/tot*100):3d}%] {msg}")
    )
    
    if args.analyze:
        # Just analyze
        info = extractor.analyze(input_path)
        logger.info(f"\nImage Analysis: {input_path}")
        logger.info(f"  Type: {info['type']}")
        logger.info(f"  Size: {info['size_human']}")
        
        if info['type'] == 'sparse':
            logger.info(f"  Raw size: {info['raw_size_human']}")
        elif info['type'] == 'boot':
            logger.info(f"  Header version: {info.get('header_version', 'unknown')}")
            logger.info(f"  Kernel size: {info.get('kernel_size', 0)}")
            logger.info(f"  Ramdisk size: {info.get('ramdisk_size', 0)}")
        elif info['type'] == 'super':
            logger.info(f"  Partitions:")
            for p in info.get('partitions', []):
                logger.info(f"    - {p['name']}: {p['size_human']}")
    else:
        # Extract
        partition_names = None
        if args.images:
            partition_names = [n.strip() for n in args.images.split(',')]
        
        result = extractor.extract(input_path, args.out, partition_names)
        logger.info(f"\nExtraction complete: {result['type']}")


# =============================================================================
# PLUGIN SYSTEM
# =============================================================================

# Required manifest.json fields in exact order
MANIFEST_REQUIRED_FIELDS = [
    "id",
    "name", 
    "version",
    "description",
    "author",
    "icon",
    "license_type",
    "website",
    "support_url",
    "min_version",
    "git_clone",
    "requirements",
    "bundled_binaries",
    "setup_commands",
    "enabled"
]

def validate_plugin_manifest(data: dict, plugin_id: str) -> tuple:
    """Validate plugin manifest.json against required schema.
    
    Args:
        data: The parsed manifest JSON data
        plugin_id: The plugin folder name (should match manifest id)
    
    Returns:
        tuple: (is_valid: bool, errors: list[str])
    """
    errors = []
    
    # Check for missing required fields
    for field in MANIFEST_REQUIRED_FIELDS:
        if field not in data:
            errors.append(f"Missing required field: '{field}'")
    
    # Validate specific fields
    if 'id' in data:
        manifest_id = data['id']
        if not isinstance(manifest_id, str) or not manifest_id:
            errors.append("Field 'id' must be a non-empty string")
        elif manifest_id != plugin_id:
            errors.append(f"Manifest 'id' ({manifest_id}) must match plugin folder name ({plugin_id})")
        elif not manifest_id[0].islower() or not all(c.islower() or c.isdigit() or c == '_' for c in manifest_id):
            errors.append("Field 'id' must start with lowercase letter and contain only lowercase letters, numbers, underscores")
    
    if 'name' in data and (not isinstance(data['name'], str) or not data['name']):
        errors.append("Field 'name' must be a non-empty string")
    
    if 'version' in data:
        import re
        if not isinstance(data['version'], str) or not re.match(r'^\d+\.\d+(\.\d+)?$', data['version']):
            errors.append("Field 'version' must be in format X.Y or X.Y.Z (e.g., '1.0' or '1.0.0')")
    
    if 'description' in data and not isinstance(data['description'], str):
        errors.append("Field 'description' must be a string")
    
    if 'author' in data and not isinstance(data['author'], str):
        errors.append("Field 'author' must be a string")
    
    if 'icon' in data and not isinstance(data['icon'], str):
        errors.append("Field 'icon' must be a string (emoji)")
    
    if 'license_type' in data:
        valid_licenses = ['free', 'paid', 'donation']
        if data['license_type'] not in valid_licenses:
            errors.append(f"Field 'license_type' must be one of: {valid_licenses}")
    
    if 'website' in data and not isinstance(data['website'], str):
        errors.append("Field 'website' must be a string (URL)")
    
    if 'support_url' in data and not isinstance(data['support_url'], str):
        errors.append("Field 'support_url' must be a string (URL)")
    
    if 'min_version' in data and not isinstance(data['min_version'], str):
        errors.append("Field 'min_version' must be a string (version)")
    
    if 'git_clone' in data and data['git_clone'] is not None and not isinstance(data['git_clone'], dict):
        errors.append("Field 'git_clone' must be null or an object with 'repo' key")
    
    if 'requirements' in data and not isinstance(data['requirements'], list):
        errors.append("Field 'requirements' must be an array of pip package names")
    
    if 'bundled_binaries' in data and not isinstance(data['bundled_binaries'], list):
        errors.append("Field 'bundled_binaries' must be an array")
    
    if 'setup_commands' in data and not isinstance(data['setup_commands'], list):
        errors.append("Field 'setup_commands' must be an array of command strings")
    
    if 'enabled' in data and not isinstance(data['enabled'], bool):
        errors.append("Field 'enabled' must be a boolean (true/false)")
    
    return len(errors) == 0, errors

@dataclass
class PluginManifest:
    """Plugin metadata from manifest.json."""
    id: str
    name: str
    version: str
    description: str
    author: str
    icon: str = "🔌"
    # Monetization
    license_type: str = "free"  # free, paid, donation
    price: float = 0.0
    currency: str = "USD"
    payment_address: str = ""  # BTC address, PayPal, etc.
    payment_type: str = ""  # btc, paypal, kofi, etc.
    # Links
    website: str = ""
    support_url: str = ""
    # Requirements
    min_version: str = "1.0"
    requirements: List[str] = None  # pip packages needed, e.g. ["requests", "pillow>=9.0"]
    # Git repository to clone (optional) - e.g. {"repo": "https://github.com/user/repo", "target": "subdir_name", "requirements_file": "requirements.txt"}
    git_clone: Dict[str, Any] = None
    # Bundled binaries that need to be downloaded (list of URLs or {url, target_path, sha256} dicts)
    bundled_binaries: List[Any] = None
    # Setup commands to run after git clone and pip install (bash-compatible)
    setup_commands: List[str] = None
    post_install: List[Dict[str, Any]] = None  # Post-install steps [{"type": "driver", "file": "..."}, {"type": "git_clone", "repo": "..."}]
    # Remote control
    remote_capable: bool = False  # Whether plugin supports remote Host/Professional control
    # State
    enabled: bool = True
    licensed: bool = False  # For paid plugins
    
    def __post_init__(self):
        if self.requirements is None:
            self.requirements = []
        if self.post_install is None:
            self.post_install = []
        if self.bundled_binaries is None:
            self.bundled_binaries = []
        if self.setup_commands is None:
            self.setup_commands = []
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any], plugin_id: str) -> 'PluginManifest':
        """Create manifest from dictionary."""
        return cls(
            id=plugin_id,
            name=data.get('name', plugin_id),
            version=data.get('version', '1.0'),
            description=data.get('description', ''),
            author=data.get('author', 'Unknown'),
            icon=data.get('icon', '🔌'),
            license_type=data.get('license_type', 'free'),
            price=float(data.get('price', 0.0)),
            currency=data.get('currency', 'USD'),
            payment_address=data.get('payment_address', ''),
            payment_type=data.get('payment_type', ''),
            website=data.get('website', ''),
            support_url=data.get('support_url', ''),
            min_version=data.get('min_version', '1.0'),
            requirements=data.get('requirements', []),
            git_clone=data.get('git_clone'),
            bundled_binaries=data.get('bundled_binaries', []),
            setup_commands=data.get('setup_commands', []),
            post_install=data.get('post_install', []),
            remote_capable=data.get('remote_capable', False),
            enabled=data.get('enabled', True),
            licensed=data.get('licensed', False)
        )


class PluginBase:
    """Base class for Image Anarchy plugins.
    
    To create a plugin:
    1. Create a folder in 'plugins/' with your plugin id
    2. Add manifest.json with plugin metadata
    3. Add plugin.py with a class that inherits from PluginBase
    4. Implement: get_name(), get_icon(), get_description(), create_widget()
    
    Example manifest.json:
    {
        "name": "My Plugin",
        "version": "1.0",
        "description": "Does something cool",
        "author": "Your Name",
        "icon": "🚀",
        "license_type": "donation",
        "payment_address": "bc1q...",
        "payment_type": "btc",
        "requirements": ["requests", "pillow"]
    }
    """
    
    manifest: Optional[PluginManifest] = None
    
    def get_name(self) -> str:
        """Return the plugin name."""
        return self.manifest.name if self.manifest else "Unknown Plugin"
    
    def get_icon(self) -> str:
        """Return emoji icon."""
        return self.manifest.icon if self.manifest else "🔌"
    
    def get_description(self) -> str:
        """Return plugin description."""
        return self.manifest.description if self.manifest else ""
    
    def get_version(self) -> str:
        """Return plugin version."""
        return self.manifest.version if self.manifest else "1.0"
    
    def get_author(self) -> str:
        """Return plugin author."""
        return self.manifest.author if self.manifest else "Unknown"
    
    def create_widget(self, parent_window) -> Any:
        """Create and return the main QWidget for this plugin.
        
        Args:
            parent_window: The main ImageAnarchyGUI window instance
            
        Returns:
            QWidget: The plugin's widget
        """
        raise NotImplementedError("Plugins must implement create_widget()")
    
    def on_load(self):
        """Called when plugin is loaded."""
        pass
    
    def on_unload(self):
        """Called when plugin is unloaded."""
        pass
    
    def is_licensed(self) -> bool:
        """Check if plugin is licensed (for paid plugins)."""
        if not self.manifest:
            return True
        if self.manifest.license_type == "free":
            return True
        return self.manifest.licensed
    
    def validate_license(self, license_key: str) -> bool:
        """Validate a license key. Override for custom validation."""
        # Default: accept any non-empty key
        return bool(license_key and len(license_key) > 0)

    # ── Remote Control (Host/Professional) ──────────────────────────────
    # Override these in your plugin to support the Remote Play system.
    # When a Host shares their device, the system calls these to discover
    # what a Professional can do remotely.

    def get_remote_operations(self) -> list:
        """Return operations available for remote control by a Professional.
        
        Each operation is a dict with:
            id:          str - operation identifier (e.g. 'read_imei')
            name:        str - human-readable name (e.g. 'Read IMEI')
            risk:        str - 'READ', 'MODIFY', or 'DANGER'
            description: str - what this operation does
            params:      list - required parameter names (empty if none)
        
        This is called dynamically - return only operations available RIGHT NOW
        (e.g. based on device connection state, current mode, etc.).
        
        Returns:
            list[dict]: Available operations, or empty list if none
        """
        return []

    def get_command_prefixes(self) -> list:
        """Return command prefixes this plugin handles in the master console.
        
        The Professional's master console auto-routes raw commands to the
        correct plugin based on the first word. For example:
            'adb devices'     → adb_toolkit handles it
            'fastboot getvar' → fastboot_toolkit handles it  
            'mtk read_imei'   → mtk_toolkit handles it
        
        Returns:
            list[str]: Command prefixes (e.g. ['adb'], ['fastboot'], ['mtk'])
        """
        return []

    def execute_raw_command(self, command: str, log_callback=None) -> dict:
        """Execute a raw command string from the Professional's master console.
        
        The command string has the prefix already included (e.g. 'adb devices').
        Stream output via log_callback(line: str) for real-time display.
        
        Args:
            command:      The full command string typed by the Professional
            log_callback: Optional callback(str) for streaming output lines
        
        Returns:
            dict: {'success': bool, 'output': str, 'error': str or None}
        """
        return {'success': False, 'output': '', 'error': 'Raw commands not supported by this plugin'}


class PluginManager:
    """Manages plugin discovery, loading, and lifecycle."""
    
    PLUGINS_DIR = "plugins"
    CONFIG_FILE = "plugins_config.json"
    
    def __init__(self):
        self.plugins: Dict[str, PluginBase] = {}
        self.manifests: Dict[str, PluginManifest] = {}
        self.config: Dict[str, Any] = {}
        self._load_config()
    
    def _get_plugins_dir(self) -> str:
        """Get the plugins directory path."""
        # Check multiple locations
        if getattr(sys, 'frozen', False):
            # Running as compiled exe
            base_dir = os.path.dirname(sys.executable)
        else:
            # Running as script
            base_dir = os.path.dirname(os.path.abspath(__file__))
        
        plugins_dir = os.path.join(base_dir, self.PLUGINS_DIR)
        os.makedirs(plugins_dir, exist_ok=True)
        return plugins_dir
    
    def _get_config_path(self) -> str:
        """Get the config file path."""
        return os.path.join(self._get_plugins_dir(), self.CONFIG_FILE)
    
    def _load_config(self):
        """Load plugin configuration (enabled states, licenses)."""
        config_path = self._get_config_path()
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    self.config = json.load(f)
            except Exception:
                self.config = {}
        else:
            self.config = {}
    
    def _save_config(self):
        """Save plugin configuration."""
        config_path = self._get_config_path()
        try:
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2)
        except Exception as e:
            logger.warning(f"Failed to save plugin config: {e}")
    
    def discover_plugins(self) -> List[PluginManifest]:
        """Discover all plugins in the plugins directory.
        
        Validates each manifest.json against the required schema.
        Plugins with invalid manifests are skipped with a warning.
        """
        plugins_dir = self._get_plugins_dir()
        discovered = []
        
        if not os.path.exists(plugins_dir):
            return discovered
        
        for item in os.listdir(plugins_dir):
            plugin_path = os.path.join(plugins_dir, item)
            manifest_path = os.path.join(plugin_path, "manifest.json")
            
            if os.path.isdir(plugin_path) and os.path.exists(manifest_path):
                try:
                    with open(manifest_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    
                    # Validate manifest against required schema
                    is_valid, errors = validate_plugin_manifest(data, item)
                    if not is_valid:
                        logger.warning(f"Invalid manifest for plugin '{item}':")
                        for error in errors:
                            logger.warning(f"  - {error}")
                        continue
                    
                    manifest = PluginManifest.from_dict(data, item)
                    
                    # Apply saved config
                    plugin_config = self.config.get(item, {})
                    manifest.enabled = plugin_config.get('enabled', True)
                    manifest.licensed = plugin_config.get('licensed', False)
                    
                    self.manifests[item] = manifest
                    discovered.append(manifest)
                    
                except json.JSONDecodeError as e:
                    logger.warning(f"Invalid JSON in manifest for plugin '{item}': {e}")
                except Exception as e:
                    logger.warning(f"Failed to load plugin manifest {item}: {e}")
        
        return discovered
    
    def load_plugin(self, plugin_id: str) -> Optional[PluginBase]:
        """Load a plugin by its ID."""
        if plugin_id in self.plugins:
            return self.plugins[plugin_id]
        
        plugins_dir = self._get_plugins_dir()
        plugin_path = os.path.join(plugins_dir, plugin_id)
        plugin_file = os.path.join(plugin_path, "plugin.py")
        
        if not os.path.exists(plugin_file):
            logger.warning(f"Plugin file not found: {plugin_file}")
            return None
        
        try:
            # Load the plugin module
            import importlib.util
            spec = importlib.util.spec_from_file_location(f"plugin_{plugin_id}", plugin_file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                sys.modules[f"plugin_{plugin_id}"] = module
                spec.loader.exec_module(module)
                
                # Find the plugin class - first check for 'Plugin' export (preferred)
                plugin_class = None
                if hasattr(module, 'Plugin'):
                    plugin_class = module.Plugin
                else:
                    # Fallback: look for PluginBase subclass
                    for name, obj in module.__dict__.items():
                        if isinstance(obj, type) and issubclass(obj, PluginBase) and obj != PluginBase:
                            plugin_class = obj
                            break
                
                if plugin_class:
                    plugin = plugin_class()
                    plugin.manifest = self.manifests.get(plugin_id)
                    if hasattr(plugin, 'on_load'):
                        plugin.on_load()
                    self.plugins[plugin_id] = plugin
                    return plugin
                else:
                    logger.warning(f"No Plugin class found in {plugin_file}")
                    
        except Exception as e:
            logger.error(f"Failed to load plugin {plugin_id}: {e}")
        
        return None
    
    def unload_plugin(self, plugin_id: str):
        """Unload a plugin."""
        if plugin_id in self.plugins:
            self.plugins[plugin_id].on_unload()
            del self.plugins[plugin_id]
    
    def enable_plugin(self, plugin_id: str, enabled: bool):
        """Enable or disable a plugin."""
        if plugin_id in self.manifests:
            self.manifests[plugin_id].enabled = enabled
            
            if plugin_id not in self.config:
                self.config[plugin_id] = {}
            self.config[plugin_id]['enabled'] = enabled
            self._save_config()
    
    def set_licensed(self, plugin_id: str, licensed: bool):
        """Set plugin license status."""
        if plugin_id in self.manifests:
            self.manifests[plugin_id].licensed = licensed
            
            if plugin_id not in self.config:
                self.config[plugin_id] = {}
            self.config[plugin_id]['licensed'] = licensed
            self._save_config()
    
    def get_plugin(self, plugin_id: str) -> Optional[PluginBase]:
        """Get a loaded plugin."""
        return self.plugins.get(plugin_id)
    
    def get_manifest(self, plugin_id: str) -> Optional[PluginManifest]:
        """Get a plugin's manifest."""
        return self.manifests.get(plugin_id)
    
    def get_all_manifests(self) -> List[PluginManifest]:
        """Get all discovered plugin manifests."""
        return list(self.manifests.values())
    
    def check_requirements(self, plugin_id: str) -> tuple:
        """Check if a plugin's requirements are installed.
        
        Returns:
            tuple: (all_installed: bool, missing: List[str], installed: List[str])
        """
        manifest = self.manifests.get(plugin_id)
        if not manifest or not manifest.requirements:
            return True, [], []
        
        missing = []
        installed = []
        
        # Use importlib.metadata for accurate package detection
        try:
            from importlib.metadata import distributions
            installed_packages = {dist.metadata['Name'].lower() for dist in distributions()}
        except ImportError:
            # Fallback for older Python
            try:
                import pkg_resources
                installed_packages = {pkg.key.lower() for pkg in pkg_resources.working_set}
            except ImportError:
                installed_packages = set()
        
        for req in manifest.requirements:
            # Parse package name (handle version specs like "requests>=2.0")
            pkg_name = req.split('>=')[0].split('<=')[0].split('==')[0].split('<')[0].split('>')[0].strip()
            
            # Check if package is installed (case-insensitive, handle underscores/hyphens)
            pkg_normalized = pkg_name.lower().replace('_', '-')
            pkg_alt = pkg_name.lower().replace('-', '_')
            
            if pkg_normalized in installed_packages or pkg_alt in installed_packages or pkg_name.lower() in installed_packages:
                installed.append(req)
            else:
                missing.append(req)
        
        return len(missing) == 0, missing, installed
    
    def install_requirements(self, requirements: List[str]) -> tuple:
        """Install pip packages to local plugin_packages directory.
        
        When running as a frozen PyInstaller exe, packages are installed to
        a local 'plugin_packages' directory using pip --target. This allows
        plugins to install their dependencies without requiring the packages
        to be bundled in the exe at build time.
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if not requirements:
            return True, "No requirements to install"
        
        try:
            import subprocess
            import sys
            
            # Determine target directory for frozen exe
            if getattr(sys, 'frozen', False):
                # Running as PyInstaller exe - install to local plugin_packages
                base_dir = os.path.dirname(sys.executable)
                target_dir = os.path.join(base_dir, 'plugin_packages')
                
                # Ensure target directory exists
                os.makedirs(target_dir, exist_ok=True)
                
                # Find Python interpreter - use embedded Python if available
                python_cmd = _get_python_executable()
                if not python_cmd:
                    return False, (
                        "Python interpreter not found.\n\n"
                        "The bundled Python was not found. Please reinstall Image Anarchy.\n\n"
                        f"You can try installing manually:\npip install --target \"{target_dir}\" {' '.join(requirements)}"
                    )
                
                # Install to local target directory so bundled Python can find them
                # Use --no-cache-dir to avoid permission issues with pip cache
                cmd = [python_cmd, '-m', 'pip', 'install', '--no-cache-dir', '--target', target_dir, '--upgrade'] + requirements
                # Use clean environment to avoid interference from system Python
                env = _get_clean_python_env()
            else:
                # Running from source - install normally
                # Use --no-cache-dir to avoid permission issues with pip cache
                cmd = [sys.executable, '-m', 'pip', 'install', '--no-cache-dir'] + requirements
                env = None  # Use default environment
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minute timeout
                env=env
            )
            
            if result.returncode == 0:
                return True, f"Successfully installed: {', '.join(requirements)}"
            else:
                return False, f"pip error: {result.stderr}\n\nYou can try installing manually:\npip install {' '.join(requirements)}"
                
        except subprocess.TimeoutExpired:
            return False, "Installation timed out (5 minutes)"
        except Exception as e:
            return False, f"Installation failed: {str(e)}"
    
    def get_git_executable(self) -> Optional[str]:
        """Find Git executable, preferring bundled portable Git."""
        # Check for bundled portable Git first
        if getattr(sys, 'frozen', False):
            base_dir = os.path.dirname(sys.executable)
        else:
            base_dir = os.path.dirname(os.path.abspath(__file__))
        
        # Check bundled git locations
        bundled_paths = [
            os.path.join(base_dir, "git", "bin", "git.exe"),
            os.path.join(base_dir, "git", "cmd", "git.exe"),
            os.path.join(base_dir, "PortableGit", "bin", "git.exe"),
            os.path.join(base_dir, "PortableGit", "cmd", "git.exe"),
        ]
        
        for git_path in bundled_paths:
            if os.path.exists(git_path):
                return git_path
        
        # Fallback to system Git
        git_in_path = shutil.which("git")
        if git_in_path:
            return git_in_path
        
        return None
    
    def run_post_install(self, plugin_id: str, progress_callback=None) -> Tuple[bool, str]:
        """Run post-install steps for a plugin.
        
        Args:
            plugin_id: The plugin identifier
            progress_callback: Optional callback(step_name: str, status: str)
            
        Returns:
            tuple: (success: bool, message: str)
        """
        manifest = self.manifests.get(plugin_id)
        if not manifest or not manifest.post_install:
            return True, "No post-install steps"
        
        plugins_dir = self._get_plugins_dir()
        plugin_dir = os.path.join(plugins_dir, plugin_id)
        
        if getattr(sys, 'frozen', False):
            base_dir = os.path.dirname(sys.executable)
        else:
            base_dir = os.path.dirname(os.path.abspath(__file__))
        
        drivers_dir = os.path.join(base_dir, "drivers")
        
        errors = []
        
        for step in manifest.post_install:
            step_type = step.get('type', '')
            step_name = step.get('name', step_type)
            optional = step.get('optional', False)
            
            if progress_callback:
                progress_callback(step_name, "running")
            
            try:
                if step_type == 'driver':
                    # Install a driver (MSI or EXE)
                    filename = step.get('file', '')
                    driver_path = os.path.join(drivers_dir, filename)
                    
                    if not os.path.exists(driver_path):
                        msg = f"Driver not found: {filename}"
                        if optional:
                            if progress_callback:
                                progress_callback(step_name, f"skipped: {msg}")
                            continue
                        else:
                            errors.append(msg)
                            continue
                    
                    # Launch installer with elevation (required for drivers)
                    if sys.platform == 'win32':
                        if filename.endswith('.msi'):
                            # MSI with elevation using PowerShell
                            msiexec_path = os.path.join(os.environ.get('SystemRoot', r'C:\Windows'), 'System32', 'msiexec.exe')
                            ps_command = f'Start-Process -FilePath "{msiexec_path}" -ArgumentList "/i","{driver_path}","/passive","/norestart" -Verb RunAs -Wait'
                            result = subprocess.run(
                                ['powershell', '-Command', ps_command],
                                capture_output=True, text=True, timeout=300
                            )
                        else:
                            # EXE installer with elevation
                            ps_command = f'Start-Process -FilePath "{driver_path}" -ArgumentList "/S","/silent","/quiet" -Verb RunAs -Wait'
                            result = subprocess.run(
                                ['powershell', '-Command', ps_command],
                                capture_output=True, text=True, timeout=300
                            )
                    else:
                        # Non-Windows - just try to run directly
                        result = subprocess.run(
                            [driver_path],
                            capture_output=True, text=True, timeout=300
                        )
                    
                    if progress_callback:
                        progress_callback(step_name, "completed")
                        
                elif step_type == 'git_clone':
                    # Clone a git repository
                    repo = step.get('repo', '')
                    target = step.get('target', '')  # Relative to plugin dir
                    
                    if not repo:
                        errors.append("git_clone: No repository specified")
                        continue
                    
                    # Determine target directory
                    if target:
                        clone_dir = os.path.join(plugin_dir, target)
                    else:
                        # Extract repo name from URL
                        repo_name = repo.rstrip('/').split('/')[-1].replace('.git', '')
                        clone_dir = os.path.join(plugin_dir, repo_name)
                    
                    # Check if already exists
                    if os.path.exists(clone_dir):
                        if progress_callback:
                            progress_callback(step_name, "already exists - skipped")
                        continue
                    
                    # Find git executable
                    git_exe = self.get_git_executable()
                    if not git_exe:
                        msg = "Git not found. Please install Git or ensure portable Git is bundled."
                        if optional:
                            if progress_callback:
                                progress_callback(step_name, f"skipped: {msg}")
                            continue
                        else:
                            errors.append(msg)
                            continue
                    
                    # Clone the repository
                    result = subprocess.run(
                        [git_exe, 'clone', '--depth', '1', repo, clone_dir],
                        capture_output=True, text=True, timeout=600,
                        cwd=plugin_dir
                    )
                    
                    if result.returncode != 0:
                        msg = f"Git clone failed: {result.stderr}"
                        if optional:
                            if progress_callback:
                                progress_callback(step_name, f"failed (optional): {msg}")
                            continue
                        else:
                            errors.append(msg)
                            continue
                    
                    # Apply known fixes for cloned repositories
                    self._apply_repo_fixes(clone_dir, repo)
                    
                    if progress_callback:
                        progress_callback(step_name, "completed")
                        
                elif step_type == 'pip_requirements':
                    # Install pip requirements from a file in the cloned repo
                    req_file = step.get('file', 'requirements.txt')
                    target = step.get('target', '')
                    
                    if target:
                        req_path = os.path.join(plugin_dir, target, req_file)
                    else:
                        req_path = os.path.join(plugin_dir, req_file)
                    
                    if not os.path.exists(req_path):
                        msg = f"Requirements file not found: {req_path}"
                        if optional:
                            if progress_callback:
                                progress_callback(step_name, f"skipped: {msg}")
                            continue
                        else:
                            errors.append(msg)
                            continue
                    
                    python_exe = _get_python_executable()
                    if not python_exe:
                        msg = "Python interpreter not found in PATH. Please install Python."
                        if optional:
                            if progress_callback:
                                progress_callback(step_name, f"skipped: {msg}")
                            continue
                        else:
                            errors.append(msg)
                            continue
                    
                    result = subprocess.run(
                        [python_exe, '-m', 'pip', 'install', '--no-cache-dir', '-r', req_path],
                        capture_output=True, text=True, timeout=600,
                        env=_get_clean_python_env()
                    )
                    
                    if result.returncode != 0:
                        msg = f"pip install failed: {result.stderr}"
                        if optional:
                            if progress_callback:
                                progress_callback(step_name, f"failed (optional): {msg}")
                            continue
                        else:
                            errors.append(msg)
                            continue
                    
                    if progress_callback:
                        progress_callback(step_name, "completed")
                        
                elif step_type == 'command':
                    # Run a custom command
                    cmd = step.get('cmd', [])
                    cwd = step.get('cwd', plugin_dir)
                    
                    if isinstance(cmd, str):
                        cmd = cmd.split()
                    
                    if not cmd:
                        errors.append("command: No command specified")
                        continue
                    
                    # Resolve relative cwd
                    if not os.path.isabs(cwd):
                        cwd = os.path.join(plugin_dir, cwd)
                    
                    result = subprocess.run(
                        cmd, capture_output=True, text=True,
                        timeout=300, cwd=cwd,
                        creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0
                    )
                    
                    if result.returncode != 0:
                        msg = f"Command failed: {result.stderr}"
                        if optional:
                            if progress_callback:
                                progress_callback(step_name, f"failed (optional): {msg}")
                            continue
                        else:
                            errors.append(msg)
                            continue
                    
                    if progress_callback:
                        progress_callback(step_name, "completed")
                        
                else:
                    errors.append(f"Unknown post-install type: {step_type}")
                    
            except subprocess.TimeoutExpired:
                msg = f"Step '{step_name}' timed out"
                if optional:
                    if progress_callback:
                        progress_callback(step_name, f"timed out (optional)")
                else:
                    errors.append(msg)
            except Exception as e:
                msg = f"Step '{step_name}' failed: {str(e)}"
                if optional:
                    if progress_callback:
                        progress_callback(step_name, f"error (optional): {str(e)}")
                else:
                    errors.append(msg)
        
        if errors:
            return False, "\n".join(errors)
        return True, "All post-install steps completed"
    
    def _apply_repo_fixes(self, clone_dir: str, repo_url: str):
        """Apply known fixes to cloned repositories.
        
        Some repositories have bugs in their requirements.txt or other files
        that need to be patched for proper installation on Windows.
        """
        # Fix mtkclient requirements.txt - has 'keystone' (OpenStack) instead of just 'keystone-engine'
        if 'mtkclient' in repo_url.lower():
            req_file = os.path.join(clone_dir, 'requirements.txt')
            if os.path.exists(req_file):
                try:
                    with open(req_file, 'r', encoding='utf-8') as f:
                        lines = f.readlines()
                    
                    # Remove 'keystone' line (OpenStack identity service)
                    # Keep 'keystone-engine' (the assembler library)
                    fixed_lines = []
                    for line in lines:
                        stripped = line.strip().lower()
                        # Skip lines that are exactly 'keystone' but keep 'keystone-engine'
                        if stripped == 'keystone':
                            continue
                        fixed_lines.append(line)
                    
                    with open(req_file, 'w', encoding='utf-8') as f:
                        f.writelines(fixed_lines)
                except Exception:
                    pass  # Best effort - if it fails, pip will just fail later
    
    def setup_plugin_dependencies(self, plugin_id: str, progress_callback=None) -> Tuple[bool, str]:
        """
        Complete setup of a plugin's dependencies AFTER extraction.
        
        Setup follows 4 phases in order:
        Phase 1: Git clone (if manifest.git_clone specified)
        Phase 2: Download binaries (if manifest.bundled_binaries has URLs)
        Phase 3: Install pip packages (manifest.requirements)
        Phase 4: Run setup commands (manifest.setup_commands like "pip install .")
        
        Args:
            plugin_id: The plugin identifier
            progress_callback: Optional callback(phase_info: str, status: str, progress: int)
                              phase_info format: "Phase X/4: Description"
            
        Returns:
            tuple: (success: bool, message: str)
        """
        # Load manifest from disk
        plugins_dir = self._get_plugins_dir()
        plugin_dir = os.path.join(plugins_dir, plugin_id)
        manifest_path = os.path.join(plugin_dir, 'manifest.json')
        
        if not os.path.exists(manifest_path):
            return False, f"manifest.json not found in {plugin_dir}"
        
        try:
            with open(manifest_path, 'r', encoding='utf-8') as f:
                manifest_data = json.load(f)
        except Exception as e:
            return False, f"Failed to read manifest.json: {str(e)}"
        
        manifest = PluginManifest.from_dict(manifest_data, plugin_id)
        self.manifests[plugin_id] = manifest
        
        errors = []
        
        # Determine which phases are active
        has_git_clone = bool(manifest.git_clone and manifest.git_clone.get('repo'))
        has_binaries = bool(manifest.bundled_binaries)
        has_requirements = bool(manifest.requirements)
        has_setup_commands = bool(manifest.setup_commands)
        has_post_install = bool(manifest.post_install)
        
        # DEFERRED SETUP: setup_commands run on first plugin open, not during install
        # This allows files to be fully extracted and paths to be validated
        # Mark it as pending if there are setup_commands
        if has_setup_commands:
            if plugin_id not in self.config:
                self.config[plugin_id] = {}
            self.config[plugin_id]['setup_commands_pending'] = True
            self._save_config()
        
        # Calculate total phases and their weights for progress
        # Phase weights represent relative time/importance
        # Note: setup_commands phase removed - runs on first open instead
        phases = []
        if has_git_clone:
            phases.append(('git_clone', 30))
        if has_binaries:
            phases.append(('binaries', 20))
        if has_requirements:
            phases.append(('pip_install', 40))
        # setup_commands deferred to first open
        if has_post_install:
            phases.append(('post_install', 10))
        
        total_phases = len(phases)
        if total_phases == 0:
            # No setup needed
            if progress_callback:
                progress_callback("No setup required", "completed", 100)
            return True, "No setup required"
        
        # Normalize weights to 100%
        total_weight = sum(p[1] for p in phases)
        progress_base = 0
        
        def get_phase_progress(phase_idx: int, sub_progress: float = 0.0) -> int:
            """Calculate overall progress percentage based on phase and sub-progress within phase."""
            nonlocal progress_base
            if phase_idx >= len(phases):
                return 100
            
            # Calculate base progress from completed phases
            base = sum(phases[i][1] for i in range(phase_idx)) * 100 // total_weight
            # Add sub-progress within current phase
            current_phase_weight = phases[phase_idx][1] * 100 // total_weight
            return min(99, base + int(current_phase_weight * sub_progress))
        
        phase_idx = 0
        phase_num = 0
        
        # ═══════════════════════════════════════════════════════════════════════
        # PHASE 1: Git Clone
        # ═══════════════════════════════════════════════════════════════════════
        if has_git_clone:
            phase_num += 1
            git_config = manifest.git_clone
            repo = git_config.get('repo', '')
            target = git_config.get('target', '')
            
            phase_label = f"Step {phase_num}/{total_phases}: Cloning repository"
            if progress_callback:
                progress_callback(phase_label, f"Cloning {repo.split('/')[-1]}...", get_phase_progress(phase_idx, 0.0))
            
            # Determine target directory
            if target:
                clone_dir = os.path.join(plugin_dir, target)
            else:
                repo_name = repo.rstrip('/').split('/')[-1].replace('.git', '')
                clone_dir = os.path.join(plugin_dir, repo_name)
            
            if os.path.exists(clone_dir):
                if progress_callback:
                    progress_callback(phase_label, "Already cloned ✓", get_phase_progress(phase_idx, 1.0))
            else:
                git_exe = self.get_git_executable()
                if not git_exe:
                    errors.append("Git not found. Please install Git to complete setup.")
                else:
                    try:
                        if progress_callback:
                            progress_callback(phase_label, f"Cloning {repo.split('/')[-1]}...", get_phase_progress(phase_idx, 0.3))
                        
                        result = subprocess.run(
                            [git_exe, 'clone', '--depth', '1', repo, clone_dir],
                            capture_output=True, text=True, timeout=600,
                            cwd=plugin_dir
                        )
                        if result.returncode != 0:
                            errors.append(f"Git clone failed: {result.stderr[:200]}")
                        else:
                            # Apply known fixes for specific repositories
                            self._apply_repo_fixes(clone_dir, repo)
                            if progress_callback:
                                progress_callback(phase_label, "Clone complete ✓", get_phase_progress(phase_idx, 1.0))
                    except subprocess.TimeoutExpired:
                        errors.append("Git clone timed out")
                    except Exception as e:
                        errors.append(f"Git clone error: {str(e)}")
            
            phase_idx += 1
        
        # ═══════════════════════════════════════════════════════════════════════
        # PHASE 2: Download Binaries
        # ═══════════════════════════════════════════════════════════════════════
        if has_binaries:
            import urllib.request
            import urllib.error
            
            phase_num += 1
            phase_label = f"Step {phase_num}/{total_phases}: Downloading binaries"
            
            # Filter to only URL-based binaries
            url_binaries = []
            for binary in manifest.bundled_binaries:
                if isinstance(binary, str) and binary.startswith(('http://', 'https://')):
                    url_binaries.append({'url': binary, 'target_path': os.path.basename(binary)})
                elif isinstance(binary, dict) and binary.get('url', '').startswith(('http://', 'https://')):
                    url_binaries.append(binary)
            
            if not url_binaries:
                if progress_callback:
                    progress_callback(phase_label, "No downloads needed ✓", get_phase_progress(phase_idx, 1.0))
            else:
                for i, binary in enumerate(url_binaries):
                    url = binary.get('url', '')
                    target_path = binary.get('target_path', os.path.basename(url))
                    expected_sha256 = binary.get('sha256')
                    binary_name = os.path.basename(target_path)
                    
                    sub_progress = i / len(url_binaries)
                    if progress_callback:
                        progress_callback(phase_label, f"Downloading {binary_name}...", get_phase_progress(phase_idx, sub_progress))
                    
                    full_path = os.path.join(plugin_dir, target_path)
                    os.makedirs(os.path.dirname(full_path), exist_ok=True)
                    
                    if os.path.exists(full_path):
                        continue  # Already exists
                    
                    try:
                        req = urllib.request.Request(url)
                        req.add_header('User-Agent', 'ImageAnarchy/2.0')
                        
                        with urllib.request.urlopen(req, timeout=120) as response:
                            data = response.read()
                        
                        if expected_sha256:
                            import hashlib
                            actual_sha256 = hashlib.sha256(data).hexdigest()
                            if actual_sha256.lower() != expected_sha256.lower():
                                errors.append(f"Binary {binary_name} SHA256 mismatch!")
                                continue
                        
                        with open(full_path, 'wb') as f:
                            f.write(data)
                            
                    except Exception as e:
                        errors.append(f"Failed to download {binary_name}: {str(e)}")
                
                if progress_callback:
                    progress_callback(phase_label, "Downloads complete ✓", get_phase_progress(phase_idx, 1.0))
            
            phase_idx += 1
        
        # ═══════════════════════════════════════════════════════════════════════
        # PHASE 3: Install pip packages
        # ═══════════════════════════════════════════════════════════════════════
        if has_requirements:
            phase_num += 1
            phase_label = f"Step {phase_num}/{total_phases}: Installing pip packages"
            
            if progress_callback:
                progress_callback(phase_label, "Checking installed packages...", get_phase_progress(phase_idx, 0.1))
            
            all_installed, missing, _ = self.check_requirements(plugin_id)
            
            if all_installed:
                if progress_callback:
                    progress_callback(phase_label, "All packages installed ✓", get_phase_progress(phase_idx, 1.0))
            else:
                if progress_callback:
                    pkg_list = ", ".join(missing[:3]) + ("..." if len(missing) > 3 else "")
                    progress_callback(phase_label, f"Installing {len(missing)} packages: {pkg_list}", get_phase_progress(phase_idx, 0.3))
                
                success, msg = self.install_requirements(missing)
                if not success:
                    errors.append(f"Pip install failed: {msg}")
                else:
                    if progress_callback:
                        progress_callback(phase_label, "Packages installed ✓", get_phase_progress(phase_idx, 1.0))
            
            phase_idx += 1
        
        # ═══════════════════════════════════════════════════════════════════════
        # PHASE 4: Setup commands DEFERRED to first plugin open
        # This allows git clone to complete fully and paths to be validated
        # See run_deferred_setup_commands() which runs on _open_plugin()
        # ═══════════════════════════════════════════════════════════════════════
        if has_setup_commands:
            if progress_callback:
                progress_callback("Setup commands", "Deferred to first plugin launch ✓", get_phase_progress(phase_idx, 1.0))
        
        # ═══════════════════════════════════════════════════════════════════════
        # PHASE 5: Post-install (drivers, etc.) - runs last
        # ═══════════════════════════════════════════════════════════════════════
        if has_post_install:
            phase_num += 1
            phase_label = f"Step {phase_num}/{total_phases}: Post-install steps"
            
            if progress_callback:
                progress_callback(phase_label, "Running post-install...", get_phase_progress(phase_idx, 0.5))
            
            success, msg = self.run_post_install(plugin_id, lambda name, status: None)
            if not success:
                errors.append(f"Post-install: {msg}")
            
            if progress_callback:
                progress_callback(phase_label, "Post-install complete ✓", get_phase_progress(phase_idx, 1.0))
            
            phase_idx += 1
        
        # ═══════════════════════════════════════════════════════════════════════
        # FINALIZE: Mark setup complete
        # ═══════════════════════════════════════════════════════════════════════
        if progress_callback:
            progress_callback("Setup Complete", "Finalizing...", 100)
        
        # Mark setup as complete in config
        if plugin_id not in self.config:
            self.config[plugin_id] = {}
        self.config[plugin_id]['setup_complete'] = True
        self.config[plugin_id]['post_install_done'] = True
        self._save_config()
        
        if errors:
            return False, "\n".join(errors)
        return True, "Plugin setup completed successfully"
    
    def is_plugin_setup_complete(self, plugin_id: str) -> bool:
        """Check if a plugin's setup has been completed."""
        plugin_config = self.config.get(plugin_id, {})
        if plugin_config.get('setup_complete', False):
            return True
        
        # Also check if manifest has any setup requirements
        manifest = self.manifests.get(plugin_id)
        if not manifest:
            # Try to load manifest
            plugins_dir = self._get_plugins_dir()
            manifest_path = os.path.join(plugins_dir, plugin_id, 'manifest.json')
            if os.path.exists(manifest_path):
                try:
                    with open(manifest_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    manifest = PluginManifest.from_dict(data, plugin_id)
                except Exception:
                    return True  # Can't read manifest, assume setup done
        
        if not manifest:
            return True  # No manifest, assume setup done
        
        # If no setup requirements, consider it complete
        has_requirements = bool(manifest.requirements or manifest.git_clone or manifest.bundled_binaries or manifest.setup_commands or manifest.post_install)
        if not has_requirements:
            return True
        
        return False
    
    def has_pending_setup_commands(self, plugin_id: str) -> bool:
        """Check if a plugin has deferred setup_commands that need to run."""
        plugin_config = self.config.get(plugin_id, {})
        return plugin_config.get('setup_commands_pending', False)
    
    def run_deferred_setup_commands(self, plugin_id: str, progress_callback=None) -> Tuple[bool, str]:
        """Run deferred setup_commands for a plugin.
        
        This is called on first plugin open, after git clone and pip install have completed.
        The deferred approach ensures all files are extracted and paths are validated.
        
        Args:
            plugin_id: The plugin ID
            progress_callback: Optional callback(step_name, status, progress_pct)
            
        Returns:
            tuple: (success: bool, message: str)
        """
        plugins_dir = self._get_plugins_dir()
        plugin_dir = os.path.join(plugins_dir, plugin_id)
        
        # Load manifest
        manifest = self.manifests.get(plugin_id)
        if not manifest:
            manifest_path = os.path.join(plugin_dir, 'manifest.json')
            if os.path.exists(manifest_path):
                try:
                    with open(manifest_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    manifest = PluginManifest.from_dict(data, plugin_id)
                except Exception as e:
                    return False, f"Failed to read manifest: {e}"
            else:
                return False, "manifest.json not found"
        
        if not manifest.setup_commands:
            # No setup commands - mark as done
            if plugin_id not in self.config:
                self.config[plugin_id] = {}
            self.config[plugin_id]['setup_commands_pending'] = False
            self._save_config()
            return True, "No setup commands to run"
        
        errors = []
        total_cmds = len(manifest.setup_commands)
        
        for i, cmd in enumerate(manifest.setup_commands):
            if not cmd or not isinstance(cmd, str):
                continue
            
            cmd_display = cmd[:50] + "..." if len(cmd) > 50 else cmd
            progress_pct = int((i / total_cmds) * 100)
            
            if progress_callback:
                progress_callback(f"Setup ({i+1}/{total_cmds})", f"Running: {cmd_display}", progress_pct)
            
            try:
                # Determine working directory - MUST be in git clone target for "pip install ."
                run_cwd = plugin_dir
                if manifest.git_clone:
                    target = manifest.git_clone.get('target', '')
                    if target:
                        potential_cwd = os.path.join(plugin_dir, target)
                    else:
                        repo = manifest.git_clone.get('repo', '')
                        repo_name = repo.rstrip('/').split('/')[-1].replace('.git', '')
                        potential_cwd = os.path.join(plugin_dir, repo_name)
                    
                    # Verify the directory exists and has setup.py or pyproject.toml
                    if os.path.exists(potential_cwd):
                        run_cwd = potential_cwd
                        # Log for debugging
                        logger.info(f"Setup command cwd: {run_cwd}")
                
                # Handle pip commands specially
                if 'pip install' in cmd.lower() or 'pip ' in cmd.lower():
                    python_exe = _get_python_executable()
                    if not python_exe:
                        errors.append(f"Setup command failed: {cmd_display}\nBundled Python not found.")
                        continue
                    
                    # Log the Python being used
                    logger.info(f"Using Python: {python_exe}")
                    
                    if 'pip install .' in cmd.lower():
                        # Verify we're in a directory with setup.py or pyproject.toml
                        has_setup = os.path.exists(os.path.join(run_cwd, 'setup.py'))
                        has_pyproject = os.path.exists(os.path.join(run_cwd, 'pyproject.toml'))
                        
                        if not has_setup and not has_pyproject:
                            errors.append(f"Setup command failed: {cmd_display}\n"
                                         f"No setup.py or pyproject.toml found in {run_cwd}")
                            continue
                        
                        if getattr(sys, 'frozen', False):
                            base_dir = os.path.dirname(sys.executable)
                            target_dir = os.path.join(base_dir, 'plugin_packages')
                            os.makedirs(target_dir, exist_ok=True)
                            win_cmd = f'"{python_exe}" -m pip install --no-cache-dir --target "{target_dir}" .'
                        else:
                            win_cmd = f'"{python_exe}" -m pip install --no-cache-dir .'
                    elif 'pip install' in cmd.lower():
                        pip_args = cmd.lower().split('pip install', 1)[1].strip()
                        win_cmd = f'"{python_exe}" -m pip install --no-cache-dir {pip_args}'
                    else:
                        pip_args = cmd.lower().split('pip ', 1)[1].strip()
                        win_cmd = f'"{python_exe}" -m pip {pip_args}'
                    
                    logger.info(f"Running: {win_cmd} in {run_cwd}")
                    
                    result = subprocess.run(
                        win_cmd, shell=True, capture_output=True, text=True,
                        timeout=600, cwd=run_cwd,
                        env=_get_clean_python_env()
                    )
                else:
                    result = subprocess.run(
                        cmd, shell=True, capture_output=True, text=True,
                        timeout=300, cwd=run_cwd
                    )
                
                if result.returncode != 0:
                    stderr = result.stderr[:500] if result.stderr else "Unknown error"
                    errors.append(f"Setup command failed: {cmd_display}\n{stderr}")
                    logger.error(f"Setup command failed: {result.stderr}")
                else:
                    logger.info(f"Setup command succeeded: {cmd_display}")
                    
            except subprocess.TimeoutExpired:
                errors.append(f"Setup command timed out: {cmd_display}")
            except Exception as e:
                errors.append(f"Setup command error: {cmd_display}\n{str(e)}")
        
        # Mark setup commands as completed
        if plugin_id not in self.config:
            self.config[plugin_id] = {}
        self.config[plugin_id]['setup_commands_pending'] = False
        self._save_config()
        
        if progress_callback:
            progress_callback("Setup Complete", "All commands finished", 100)
        
        if errors:
            return False, "\n".join(errors)
        return True, "Setup commands completed successfully"
    
    def create_example_plugin(self):
        """Create a developer guide plugin to show how to create plugins."""
        plugins_dir = self._get_plugins_dir()
        guide_dir = os.path.join(plugins_dir, "developer_guide")
        
        if os.path.exists(guide_dir):
            return  # Already exists
        
        os.makedirs(guide_dir, exist_ok=True)
        
        # Create manifest.json
        manifest = {
            "name": "Plugin Developer Guide",
            "version": "1.0",
            "description": "Learn how to create plugins for Image Anarchy - earn money doing what you love!",
            "author": "Image Anarchy",
            "icon": "🛠️",
            "license_type": "free",
            "website": "https://github.com/vehoelite/image-anarchy",
            "min_version": "1.0"
        }
        
        with open(os.path.join(guide_dir, "manifest.json"), 'w', encoding='utf-8') as f:
            json.dump(manifest, f, indent=2)
        
        # Create plugin.py - Developer Guide
        plugin_code = '''"""
Plugin Developer Guide for Image Anarchy
Learn how to create plugins and monetize your skills!
"""

from __main__ import PluginBase
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QTextEdit, QGroupBox, QScrollArea, QFrame
)
from PyQt6.QtCore import Qt
import webbrowser
import os
import subprocess
import sys


class DeveloperGuidePlugin(PluginBase):
    """Interactive developer guide for creating Image Anarchy plugins."""
    
    def create_widget(self, parent_window):
        """Create the developer guide widget."""
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.Shape.NoFrame)
        
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setSpacing(16)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # Hero Section
        hero = QLabel("Create Plugins for Image Anarchy")
        hero.setStyleSheet("font-size: 24px; font-weight: bold; color: #4fc3f7;")
        hero.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(hero)
        
        subtitle = QLabel("Build powerful tools for Android enthusiasts - and earn money doing it!")
        subtitle.setStyleSheet("font-size: 14px; color: #aaa; margin-bottom: 20px;")
        subtitle.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(subtitle)
        
        # Why Create Plugins
        why_group = QGroupBox("Why Create Plugins?")
        why_layout = QVBoxLayout(why_group)
        why_items = [
            "Reach thousands of users - Image Anarchy is used by Android enthusiasts worldwide",
            "Monetize your skills - Set your price, accept BTC, PayPal, Ko-fi, or Patreon",
            "It is incredibly easy - Just 2 files: manifest.json + plugin.py",
            "Full PyQt6 power - Create any UI you can imagine",
            "Access core features - Use Image Anarchy extractors, packers, and utilities"
        ]
        for item in why_items:
            lbl = QLabel("* " + item)
            lbl.setWordWrap(True)
            lbl.setStyleSheet("font-size: 13px; padding: 4px 0;")
            why_layout.addWidget(lbl)
        layout.addWidget(why_group)
        
        # How Easy Section
        easy_group = QGroupBox("How Easy Is It? Just 3 Steps!")
        easy_layout = QVBoxLayout(easy_group)
        
        steps = [
            ("Step 1:", "Create a folder in the plugins directory"),
            ("Step 2:", "Add manifest.json with your plugin info (name, author, price)"),
            ("Step 3:", "Add plugin.py with your code - implement create_widget()"),
        ]
        for title, desc in steps:
            step_lbl = QLabel(f"<b>{title}</b> {desc}")
            step_lbl.setTextFormat(Qt.TextFormat.RichText)
            step_lbl.setStyleSheet("font-size: 13px; padding: 6px 0;")
            easy_layout.addWidget(step_lbl)
        layout.addWidget(easy_group)
        
        # Code Example
        code_group = QGroupBox("Minimal Plugin Example (plugin.py)")
        code_layout = QVBoxLayout(code_group)
        
        code_text = QTextEdit()
        code_text.setReadOnly(True)
        code_text.setMaximumHeight(260)
        code_text.setStyleSheet("""
            QTextEdit {
                background-color: #1a1a2e;
                color: #4fc3f7;
                font-family: Consolas, Courier New, monospace;
                font-size: 11px;
                padding: 10px;
                border: 1px solid #333;
            }
        """)
        code_text.setPlainText("""# plugin.py - This is ALL you need!

from __main__ import PluginBase
from PyQt6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton

class MyPlugin(PluginBase):
    
    def create_widget(self, parent_window):
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        layout.addWidget(QLabel("Hello from my plugin!"))
        
        btn = QPushButton("Do Something Cool")
        btn.clicked.connect(self.do_something)
        layout.addWidget(btn)
        
        return widget
    
    def do_something(self):
        print("Plugin is working!")""")
        code_layout.addWidget(code_text)
        layout.addWidget(code_group)
        
        # Monetization Section
        money_group = QGroupBox("Monetization Options")
        money_layout = QVBoxLayout(money_group)
        
        money_intro = QLabel("Set license_type in your manifest.json:")
        money_intro.setStyleSheet("font-size: 13px; font-weight: bold;")
        money_layout.addWidget(money_intro)
        
        license_types = [
            '"free" - Open to everyone',
            '"donation" - Free with optional tip jar shown to users',
            '"paid" - Users see your price and payment info before using',
        ]
        for lt in license_types:
            lbl = QLabel("* " + lt)
            lbl.setStyleSheet("font-size: 12px; padding: 2px 0;")
            money_layout.addWidget(lbl)
        
        payment_label = QLabel("\\nSupported payment methods:")
        payment_label.setStyleSheet("font-size: 13px; font-weight: bold;")
        money_layout.addWidget(payment_label)
        
        payments = ["Bitcoin (BTC) - Direct wallet", "PayPal - Payment links", 
                   "Ko-fi - Creator support", "Patreon - Subscriptions", "GitHub Sponsors"]
        for p in payments:
            lbl = QLabel("* " + p)
            lbl.setStyleSheet("font-size: 12px; padding: 2px 0;")
            money_layout.addWidget(lbl)
        layout.addWidget(money_group)
        
        # Requirements Section
        req_group = QGroupBox("Using pip Packages")
        req_layout = QVBoxLayout(req_group)
        
        req_intro = QLabel("Need external packages? Add them to manifest.json:")
        req_intro.setStyleSheet("font-size: 13px; font-weight: bold;")
        req_layout.addWidget(req_intro)
        
        req_example = QTextEdit()
        req_example.setReadOnly(True)
        req_example.setMaximumHeight(80)
        req_example.setStyleSheet("""
            QTextEdit {
                background-color: #1a1a2e;
                color: #4fc3f7;
                font-family: Consolas, Courier New, monospace;
                font-size: 11px;
                padding: 8px;
                border: 1px solid #333;
            }
        """)
        req_example.setPlainText('{\n    "requirements": ["requests", "pillow>=9.0", "beautifulsoup4"]\n}')
        req_layout.addWidget(req_example)
        
        req_note = QLabel("Users will be prompted to install missing packages automatically!")
        req_note.setStyleSheet("font-size: 12px; color: #4caf50; padding: 4px 0;")
        req_layout.addWidget(req_note)
        layout.addWidget(req_group)
        
        # Plugin Ideas
        ideas_group = QGroupBox("Plugin Ideas to Get You Started")
        ideas_layout = QVBoxLayout(ideas_group)
        
        ideas = [
            "Build.prop Editor - Visual editor for system properties",
            "Boot Animation Creator - Design custom boot animations", 
            "Partition Analyzer - Deep analysis of partition contents",
            "Device Profiles - Save/restore device configurations",
            "Batch Processor - Process multiple images at once",
            "OTA Downloader - Download OTAs from manufacturers",
        ]
        for idea in ideas:
            lbl = QLabel("* " + idea)
            lbl.setStyleSheet("font-size: 12px; padding: 2px 0;")
            ideas_layout.addWidget(lbl)
        layout.addWidget(ideas_group)
        
        # Action Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        docs_btn = QPushButton("Documentation")
        docs_btn.setStyleSheet("padding: 10px 20px;")
        docs_btn.clicked.connect(lambda: webbrowser.open("https://github.com/vehoelite/image-anarchy"))
        btn_layout.addWidget(docs_btn)
        
        folder_btn = QPushButton("Open Plugins Folder")
        folder_btn.setStyleSheet("padding: 10px 20px;")
        folder_btn.clicked.connect(self._open_folder)
        btn_layout.addWidget(folder_btn)
        
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        
        # Footer
        footer = QLabel("Questions? Join our community on GitHub or XDA!")
        footer.setStyleSheet("color: #666; font-style: italic; margin-top: 20px;")
        footer.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(footer)
        
        layout.addStretch()
        scroll.setWidget(widget)
        return scroll
    
    def _open_folder(self):
        plugins_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        if sys.platform == "win32":
            os.startfile(plugins_dir)
        elif sys.platform == "darwin":
            subprocess.run(["open", plugins_dir])
        else:
            subprocess.run(["xdg-open", plugins_dir])
'''
        
        with open(os.path.join(guide_dir, "plugin.py"), 'w', encoding='utf-8') as f:
            f.write(plugin_code)
        
        # Create README
        readme = """# Plugin Developer Guide

Learn how to create plugins for Image Anarchy!

## Quick Start

1. Create a folder in `plugins/`
2. Add `manifest.json` with your plugin info
3. Add `plugin.py` with your PluginBase class
4. Restart Image Anarchy - your plugin appears automatically!

## Manifest Example

```json
{
    "name": "My Cool Plugin",
    "version": "1.0",
    "description": "Does amazing things",
    "author": "Your Name",
    "icon": "rocket",
    "license_type": "paid",
    "price": 5.00,
    "currency": "USD",
    "payment_address": "your-btc-address",
    "payment_type": "btc"
}
```

## Resources

- Documentation: https://github.com/vehoelite/image-anarchy
- Community: XDA Forums
"""
        
        with open(os.path.join(guide_dir, "README.md"), 'w', encoding='utf-8') as f:
            f.write(readme)


# Global plugin manager
plugin_manager = PluginManager()


# =============================================================================
# GUI COMPONENTS (PyQt6)
# =============================================================================

def create_gui_app():
    """Create and return the GUI application. Imports PyQt6 only when needed."""
    
    # IMPORTANT: Import QtWebEngineWidgets BEFORE QApplication is created
    # This is required for QWebEngineView to work properly
    try:
        from PyQt6.QtWebEngineWidgets import QWebEngineView as _QWebEngineView
        _webengine_available = True
    except ImportError:
        _QWebEngineView = None
        _webengine_available = False
    
    from PyQt6.QtWidgets import (
        QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
        QLabel, QLineEdit, QPushButton, QFileDialog, QListWidget,
        QListWidgetItem, QProgressBar, QTextEdit, QGroupBox, QCheckBox,
        QSplitter, QStatusBar, QMessageBox, QAbstractItemView, QTabWidget,
        QComboBox, QSpinBox, QTreeWidget, QTreeWidgetItem, QHeaderView,
        QFormLayout, QRadioButton, QScrollArea, QFrame, QMenu, QDoubleSpinBox,
        QGridLayout, QDialog, QInputDialog, QSystemTrayIcon, QGraphicsOpacityEffect,
        QPlainTextEdit, QStackedWidget, QButtonGroup, QSizePolicy
    )
    from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer, QPropertyAnimation, QPoint, QEasingCurve, QMimeData, QUrl, QObject, QEvent
    from PyQt6.QtGui import QFont, QDragEnterEvent, QDropEvent, QPalette, QColor, QAction, QIcon, QPixmap, QPainter, QDrag

    # =========================================================================
    # ANARCHY TOAST NOTIFICATION SYSTEM
    # =========================================================================
    
    class AnarchyToast(QLabel):
        """Rebellious toast notification - burns bright and fades away."""
        
        TOAST_STYLES = {
            'success': ('🔥', '#2e7d32', '#1b5e20'),
            'error': ('💀', '#c62828', '#b71c1c'),
            'warning': ('⚠️', '#f57c00', '#e65100'),
            'info': ('Ⓐ', '#1565c0', '#0d47a1'),
            'chaos': ('🏴', '#6a1b9a', '#4a148c'),
        }
        
        def __init__(self, parent, message: str, toast_type: str = 'info', duration: int = 3000):
            super().__init__(parent)
            
            icon, bg_color, border_color = self.TOAST_STYLES.get(toast_type, self.TOAST_STYLES['info'])
            
            self.setText(f"  {icon}  {message}  ")
            self.setStyleSheet(f"""
                QLabel {{
                    background-color: {bg_color};
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    border: 2px solid {border_color};
                    font-size: 13px;
                    font-weight: bold;
                }}
            """)
            self.setWordWrap(True)
            self.setMaximumWidth(400)
            self.adjustSize()
            
            # Position at bottom-right of parent
            self._position_toast()
            
            # Fade in animation
            self.opacity_effect = QGraphicsOpacityEffect(self)
            self.setGraphicsEffect(self.opacity_effect)
            
            self.fade_in = QPropertyAnimation(self.opacity_effect, b"opacity")
            self.fade_in.setDuration(200)
            self.fade_in.setStartValue(0)
            self.fade_in.setEndValue(1)
            
            # Fade out after duration
            self.fade_out = QPropertyAnimation(self.opacity_effect, b"opacity")
            self.fade_out.setDuration(500)
            self.fade_out.setStartValue(1)
            self.fade_out.setEndValue(0)
            self.fade_out.finished.connect(self.deleteLater)
            
            # Timer to start fade out
            self.timer = QTimer(self)
            self.timer.setSingleShot(True)
            self.timer.timeout.connect(self.fade_out.start)
            self.timer.start(duration)
            
            self.show()
            self.fade_in.start()
        
        def _position_toast(self):
            """Position toast at bottom-right with offset for stacking."""
            if self.parent():
                parent_rect = self.parent().rect()
                # Count existing toasts for stacking
                existing_toasts = [c for c in self.parent().children() 
                                   if isinstance(c, AnarchyToast) and c != self and c.isVisible()]
                offset = len(existing_toasts) * 60
                
                x = parent_rect.width() - self.width() - 20
                y = parent_rect.height() - self.height() - 20 - offset
                self.move(x, max(20, y))

    # =========================================================================
    # PRE-READY CHECKLIST SPLASH SCREEN
    # =========================================================================
    
    class PreReadyChecklistDialog(QDialog):
        """Splash screen that checks user's environment before starting."""
        
        def __init__(self, parent=None):
            super().__init__(parent)
            self.setWindowTitle("Image Anarchy - Environment Check")
            self.setMinimumSize(650, 550)
            self.setModal(True)
            
            # Flag to track if dialog is still open (prevents timer callbacks after close)
            self._is_open = True
            
            # Get app directory for drivers (handles frozen exe correctly)
            self.app_dir = Path(get_app_dir())
            self.drivers_dir = self.app_dir / "drivers"
            
            self._setup_ui()
            self._check_environment()
        
        def closeEvent(self, event):
            """Handle dialog close - prevents timer callbacks from running."""
            self._is_open = False
            super().closeEvent(event)
        
        def done(self, result):
            """Handle dialog done (accept/reject) - prevents timer callbacks."""
            self._is_open = False
            super().done(result)
        
        def _setup_ui(self):
            layout = QVBoxLayout(self)
            layout.setSpacing(16)
            layout.setContentsMargins(24, 24, 24, 24)
            
            # Header
            header = QLabel("🔧 Pre-Ready Checklist")
            header.setStyleSheet("font-size: 22px; font-weight: bold; color: #4fc3f7;")
            header.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(header)
            
            subtitle = QLabel("Checking your environment for Android development tools...")
            subtitle.setStyleSheet("font-size: 13px; color: #aaa;")
            subtitle.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(subtitle)
            
            # OS Detection
            os_group = QGroupBox("Operating System")
            os_layout = QVBoxLayout(os_group)
            
            self.os_label = QLabel()
            self.os_label.setStyleSheet("font-size: 14px; padding: 8px;")
            os_layout.addWidget(self.os_label)
            
            layout.addWidget(os_group)
            
            # Windows-specific section
            self.windows_group = QGroupBox("Windows Driver Signing (Required for unsigned USB drivers)")
            self.windows_layout = QVBoxLayout(self.windows_group)
            
            info_label = QLabel(
                "⚠️ These commands disable driver signature enforcement.\n"
                "Required to use unsigned Android USB drivers. Run as Administrator."
            )
            info_label.setStyleSheet("color: #FFA500; font-size: 11px; padding: 4px;")
            info_label.setWordWrap(True)
            self.windows_layout.addWidget(info_label)
            
            # Command 1: nointegritychecks
            self.cmd1_layout = QHBoxLayout()
            self.cmd1_status = QLabel("⏳")
            self.cmd1_status.setFixedWidth(30)
            self.cmd1_label = QLabel("bcdedit.exe -set nointegritychecks on")
            self.cmd1_label.setStyleSheet("font-family: Consolas; font-size: 12px; padding: 4px; background: #2d2d2d; border-radius: 4px;")
            self.cmd1_btn = QPushButton("Run")
            self.cmd1_btn.setFixedWidth(80)
            self.cmd1_btn.clicked.connect(lambda: self._run_bcdedit_command("bcdedit.exe -set nointegritychecks on"))
            self.cmd1_layout.addWidget(self.cmd1_status)
            self.cmd1_layout.addWidget(self.cmd1_label, 1)
            self.cmd1_layout.addWidget(self.cmd1_btn)
            self.windows_layout.addLayout(self.cmd1_layout)
            
            # Command 2: DISABLE_INTEGRITY_CHECKS
            self.cmd2_layout = QHBoxLayout()
            self.cmd2_status = QLabel("⏳")
            self.cmd2_status.setFixedWidth(30)
            self.cmd2_label = QLabel("bcdedit.exe -set loadoptions DISABLE_INTEGRITY_CHECKS")
            self.cmd2_label.setStyleSheet("font-family: Consolas; font-size: 12px; padding: 4px; background: #2d2d2d; border-radius: 4px;")
            self.cmd2_btn = QPushButton("Run")
            self.cmd2_btn.setFixedWidth(80)
            self.cmd2_btn.clicked.connect(lambda: self._run_bcdedit_command("bcdedit.exe -set loadoptions DISABLE_INTEGRITY_CHECKS"))
            self.cmd2_layout.addWidget(self.cmd2_status)
            self.cmd2_layout.addWidget(self.cmd2_label, 1)
            self.cmd2_layout.addWidget(self.cmd2_btn)
            self.windows_layout.addLayout(self.cmd2_layout)
            
            # Command 3: TESTSIGNING
            self.cmd3_layout = QHBoxLayout()
            self.cmd3_status = QLabel("⏳")
            self.cmd3_status.setFixedWidth(30)
            self.cmd3_label = QLabel("bcdedit.exe -set TESTSIGNING ON")
            self.cmd3_label.setStyleSheet("font-family: Consolas; font-size: 12px; padding: 4px; background: #2d2d2d; border-radius: 4px;")
            self.cmd3_btn = QPushButton("Run")
            self.cmd3_btn.setFixedWidth(80)
            self.cmd3_btn.clicked.connect(lambda: self._run_bcdedit_command("bcdedit.exe -set TESTSIGNING ON"))
            self.cmd3_layout.addWidget(self.cmd3_status)
            self.cmd3_layout.addWidget(self.cmd3_label, 1)
            self.cmd3_layout.addWidget(self.cmd3_btn)
            self.windows_layout.addLayout(self.cmd3_layout)
            
            # Run All button
            run_all_btn = QPushButton("⚡ Run All Commands (Admin Required)")
            run_all_btn.setStyleSheet("padding: 10px; font-weight: bold;")
            run_all_btn.clicked.connect(self._run_all_commands)
            self.windows_layout.addWidget(run_all_btn)
            
            layout.addWidget(self.windows_group)
            
            # Drivers section
            self.drivers_group = QGroupBox("USB Drivers (Click to Install)")
            drivers_layout = QGridLayout(self.drivers_group)
            drivers_layout.setSpacing(8)
            
            # Driver buttons with their installers
            self.driver_buttons = []
            drivers = [
                ("📱 ZTE USB Drivers", "ZTE_Android_Driver.exe", "ZTE devices"),
                ("📱 Samsung USB Drivers", "SAMSUNG_USB_Driver_for_Mobile_Phones_v1.9.0.0.exe", "Samsung Galaxy"),
                ("📱 MTK USB Drivers", "MTK_Driver_Setup.exe", "MediaTek devices"),
                ("📱 Motorola USB Drivers", "Motorola_Mobile_Drivers_64bit.msi", "Motorola/Lenovo"),
                ("📱 Alcatel USB Drivers", "Mobile_Upgrade_S_Gotu2_v6.1.0_Setup.exe", "Alcatel devices"),
                ("📱 LG USB Drivers", "LG_Mobile _Driver_v4.8.0.exe", "LG devices"),
            ]
            
            for i, (name, filename, tooltip) in enumerate(drivers):
                btn = QPushButton(name)
                btn.setToolTip(f"Install drivers for {tooltip}")
                btn.setStyleSheet("padding: 10px; text-align: left;")
                driver_path = self.drivers_dir / filename
                if driver_path.exists():
                    btn.clicked.connect(lambda checked, p=str(driver_path): self._install_driver(p))
                else:
                    btn.setEnabled(False)
                    btn.setToolTip(f"Driver not found: {filename}")
                    btn.setText(f"{name} (Not found)")
                drivers_layout.addWidget(btn, i // 2, i % 2)
                self.driver_buttons.append(btn)
            
            layout.addWidget(self.drivers_group)
            
            # Buttons
            btn_layout = QHBoxLayout()
            btn_layout.addStretch()
            
            refresh_btn = QPushButton("🔄 Refresh Status")
            refresh_btn.clicked.connect(self._check_environment)
            btn_layout.addWidget(refresh_btn)
            
            skip_btn = QPushButton("Skip →")
            skip_btn.setStyleSheet("padding: 10px 20px;")
            skip_btn.clicked.connect(self.accept)
            btn_layout.addWidget(skip_btn)
            
            continue_btn = QPushButton("Continue ✓")
            continue_btn.setProperty("primary", True)
            continue_btn.setStyleSheet("padding: 10px 20px; background-color: #0078d4; color: white; font-weight: bold;")
            continue_btn.clicked.connect(self.accept)
            btn_layout.addWidget(continue_btn)
            
            layout.addLayout(btn_layout)
        
        def _check_environment(self):
            """Check the current environment and update UI."""
            is_windows = sys.platform == 'win32'
            is_linux = sys.platform.startswith('linux')
            is_mac = sys.platform == 'darwin'
            
            if is_linux:
                self.os_label.setText("🐧 Linux Detected - Good to go! No driver signing issues.")
                self.os_label.setStyleSheet("font-size: 14px; padding: 8px; color: #4CAF50; background: #1b3d1b; border-radius: 4px;")
                self.windows_group.setVisible(False)
                self.drivers_group.setVisible(False)
            elif is_mac:
                self.os_label.setText("🍎 macOS Detected - Good to go! No driver signing issues.")
                self.os_label.setStyleSheet("font-size: 14px; padding: 8px; color: #4CAF50; background: #1b3d1b; border-radius: 4px;")
                self.windows_group.setVisible(False)
                self.drivers_group.setVisible(False)
            elif is_windows:
                self.os_label.setText("🪟 Windows Detected - Driver signing configuration may be needed.")
                self.os_label.setStyleSheet("font-size: 14px; padding: 8px; color: #FFA500; background: #3d3520; border-radius: 4px;")
                self.windows_group.setVisible(True)
                self.drivers_group.setVisible(True)
                self._check_windows_signing()
            else:
                self.os_label.setText(f"❓ Unknown OS: {sys.platform}")
                self.os_label.setStyleSheet("font-size: 14px; padding: 8px;")
                self.windows_group.setVisible(False)
        
        def _check_windows_signing(self):
            """Check Windows BCD settings for driver signing."""
            # Guard against callback after dialog is closed
            if not self._is_open:
                return
            try:
                # Run bcdedit to get current settings
                result = subprocess.run(
                    ['bcdedit', '/enum', '{current}'],
                    capture_output=True,
                    text=True,
                    creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0
                )
                output = result.stdout.lower()
                
                # Check nointegritychecks
                if 'nointegritychecks' in output and 'yes' in output:
                    self.cmd1_status.setText("✅")
                    self.cmd1_label.setStyleSheet("font-family: Consolas; font-size: 12px; padding: 4px; background: #1b3d1b; border-radius: 4px; color: #4CAF50; text-decoration: line-through;")
                    self.cmd1_btn.setEnabled(False)
                    self.cmd1_btn.setText("Done")
                else:
                    self.cmd1_status.setText("❌")
                    self.cmd1_label.setStyleSheet("font-family: Consolas; font-size: 12px; padding: 4px; background: #2d2d2d; border-radius: 4px;")
                    self.cmd1_btn.setEnabled(True)
                    self.cmd1_btn.setText("Run")
                
                # Check loadoptions DISABLE_INTEGRITY_CHECKS
                if 'disable_integrity_checks' in output:
                    self.cmd2_status.setText("✅")
                    self.cmd2_label.setStyleSheet("font-family: Consolas; font-size: 12px; padding: 4px; background: #1b3d1b; border-radius: 4px; color: #4CAF50; text-decoration: line-through;")
                    self.cmd2_btn.setEnabled(False)
                    self.cmd2_btn.setText("Done")
                else:
                    self.cmd2_status.setText("❌")
                    self.cmd2_label.setStyleSheet("font-family: Consolas; font-size: 12px; padding: 4px; background: #2d2d2d; border-radius: 4px;")
                    self.cmd2_btn.setEnabled(True)
                    self.cmd2_btn.setText("Run")
                
                # Check TESTSIGNING
                if 'testsigning' in output and 'yes' in output:
                    self.cmd3_status.setText("✅")
                    self.cmd3_label.setStyleSheet("font-family: Consolas; font-size: 12px; padding: 4px; background: #1b3d1b; border-radius: 4px; color: #4CAF50; text-decoration: line-through;")
                    self.cmd3_btn.setEnabled(False)
                    self.cmd3_btn.setText("Done")
                else:
                    self.cmd3_status.setText("❌")
                    self.cmd3_label.setStyleSheet("font-family: Consolas; font-size: 12px; padding: 4px; background: #2d2d2d; border-radius: 4px;")
                    self.cmd3_btn.setEnabled(True)
                    self.cmd3_btn.setText("Run")
                    
            except Exception as e:
                # Can't check - likely not admin
                self.cmd1_status.setText("❓")
                self.cmd2_status.setText("❓")
                self.cmd3_status.setText("❓")
        
        def _run_bcdedit_command(self, command):
            """Run a bcdedit command with admin privileges."""
            try:
                if sys.platform == 'win32':
                    # Use PowerShell Start-Process with -Verb RunAs for elevation
                    ps_command = f'Start-Process cmd -ArgumentList "/c {command}" -Verb RunAs -Wait'
                    subprocess.run(['powershell', '-Command', ps_command], check=False)
                    # Refresh status after command (only if dialog is still open)
                    def delayed_check():
                        if self._is_open:
                            self._check_windows_signing()
                    QTimer.singleShot(1000, delayed_check)
                    QMessageBox.information(self, "Command Executed", 
                        f"Command executed. A reboot may be required for changes to take effect.\n\n{command}")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to run command:\n{e}")
        
        def _run_all_commands(self):
            """Run all bcdedit commands at once."""
            try:
                if sys.platform == 'win32':
                    commands = [
                        "bcdedit.exe -set nointegritychecks on",
                        "bcdedit.exe -set loadoptions DISABLE_INTEGRITY_CHECKS",
                        "bcdedit.exe -set TESTSIGNING ON"
                    ]
                    combined = " && ".join(commands)
                    ps_command = f'Start-Process cmd -ArgumentList "/c {combined}" -Verb RunAs -Wait'
                    subprocess.run(['powershell', '-Command', ps_command], check=False)
                    # Refresh status after commands (only if dialog is still open)
                    def delayed_check():
                        if self._is_open:
                            self._check_windows_signing()
                    QTimer.singleShot(1000, delayed_check)
                    QMessageBox.information(self, "Commands Executed",
                        "All commands executed. A reboot is required for changes to take effect.")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to run commands:\n{e}")
        
        def _install_driver(self, driver_path):
            """Install a driver package."""
            try:
                if sys.platform == 'win32':
                    if driver_path.endswith('.msi'):
                        # MSI installer
                        subprocess.Popen(['msiexec', '/i', driver_path], creationflags=subprocess.CREATE_NO_WINDOW)
                    else:
                        # EXE installer - run with elevation
                        ps_command = f'Start-Process "{driver_path}" -Verb RunAs'
                        subprocess.run(['powershell', '-Command', ps_command], check=False)
                    QMessageBox.information(self, "Driver Installer", 
                        f"Driver installer launched:\n{Path(driver_path).name}\n\nFollow the on-screen instructions.")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to launch installer:\n{e}")

    @dataclass
    class PartitionDisplayInfo:
        """Information about a partition for display in the UI."""
        name: str
        size: int
        operations_count: int

    class PayloadAnalyzerThread(QThread):
        """Thread for analyzing payload files without blocking the UI."""
        
        finished = pyqtSignal(list)
        error = pyqtSignal(str)
        status = pyqtSignal(str)
        
        def __init__(self, payload_path: str):
            super().__init__()
            self.payload_path = payload_path
        
        def run(self):
            try:
                self.status.emit("Opening payload file...")
                with PayloadFile(self.payload_path) as payload_file:
                    self.status.emit("Reading manifest...")
                    
                    magic = payload_file.read(4)
                    if magic != PAYLOAD_MAGIC:
                        raise PayloadError("Invalid payload file")
                    
                    format_version = unpack_u64(payload_file.read(8))
                    if format_version != SUPPORTED_FORMAT_VERSION:
                        raise PayloadError(f"Unsupported format version: {format_version}")
                    
                    manifest_size = unpack_u64(payload_file.read(8))
                    metadata_signature_size = unpack_u32(payload_file.read(4))
                    manifest_data = payload_file.read(manifest_size)
                    
                    manifest = DeltaArchiveManifest()
                    manifest.ParseFromString(manifest_data)
                    
                    partitions = []
                    for part in manifest.partitions:
                        size = sum(
                            ext.num_blocks * manifest.block_size 
                            for op in part.operations 
                            for ext in op.dst_extents
                        )
                        partitions.append(PartitionDisplayInfo(
                            name=part.partition_name,
                            size=size,
                            operations_count=len(part.operations)
                        ))
                    
                    self.status.emit(f"Found {len(partitions)} partitions")
                    self.finished.emit(partitions)
                    
            except Exception as e:
                self.error.emit(str(e))

    class ExtractionThread(QThread):
        """Thread for extracting partitions without blocking the UI."""
        
        progress = pyqtSignal(int, int)
        partition_started = pyqtSignal(str)
        partition_finished = pyqtSignal(str)
        log = pyqtSignal(str)
        error = pyqtSignal(str)
        finished = pyqtSignal()
        
        def __init__(self, payload_path: str, output_dir: str, 
                     partitions: list[str], old_dir: Optional[str] = None,
                     extract_super: bool = False):
            super().__init__()
            self.payload_path = payload_path
            self.output_dir = output_dir
            self.partitions = partitions
            self.old_dir = old_dir
            self.extract_super = extract_super
            self._cancelled = False
            self._extracted_super_path = None
        
        def cancel(self):
            self._cancelled = True
        
        def run(self):
            try:
                Path(self.output_dir).mkdir(parents=True, exist_ok=True)
                
                with PayloadFile(self.payload_path) as payload_file:
                    magic = payload_file.read(4)
                    format_version = unpack_u64(payload_file.read(8))
                    manifest_size = unpack_u64(payload_file.read(8))
                    metadata_signature_size = unpack_u32(payload_file.read(4))
                    
                    manifest_data = payload_file.read(manifest_size)
                    payload_file.read(metadata_signature_size)
                    data_offset = payload_file.tell()
                    
                    manifest = DeltaArchiveManifest()
                    manifest.ParseFromString(manifest_data)
                    
                    handler = OperationHandler(payload_file, data_offset, manifest.block_size)
                    
                    parts_to_extract = [
                        p for p in manifest.partitions 
                        if p.partition_name in self.partitions
                    ]
                    
                    total_ops = sum(len(p.operations) for p in parts_to_extract)
                    current_op = 0
                    
                    for partition in parts_to_extract:
                        if self._cancelled:
                            self.log.emit("Extraction cancelled")
                            return
                        
                        name = partition.partition_name
                        self.partition_started.emit(name)
                        self.log.emit(f"Extracting {name}...")
                        
                        output_path = Path(self.output_dir) / f"{name}.img"
                        old_file = None
                        
                        if self.old_dir:
                            old_path = Path(self.old_dir) / f"{name}.img"
                            if old_path.exists():
                                old_file = open(old_path, 'rb')
                            else:
                                self.log.emit(f"  Warning: Original image not found for {name}")
                        
                        try:
                            with open(output_path, 'wb') as out_file:
                                for op in partition.operations:
                                    if self._cancelled:
                                        return
                                    handler.process(op, out_file, old_file)
                                    current_op += 1
                                    self.progress.emit(current_op, total_ops)
                        finally:
                            if old_file:
                                old_file.close()
                        
                        self.partition_finished.emit(name)
                        self.log.emit(f"  Done: {output_path}")
                        
                        # Track super partition for post-extraction
                        if name == 'super' and self.extract_super:
                            self._extracted_super_path = str(output_path)
                    
                    # Extract super partition contents if requested
                    if self._extracted_super_path and self.extract_super:
                        self._extract_super_contents()
                    
                    self.log.emit("\nExtraction complete!")
                    self.finished.emit()
                    
            except Exception as e:
                self.error.emit(str(e))
        
        def _extract_super_contents(self):
            """Extract partitions from super.img after payload extraction."""
            if not self._extracted_super_path or not Path(self._extracted_super_path).exists():
                return
            
            self.log.emit("\n" + "="*50)
            self.log.emit("Extracting super partition contents...")
            self.log.emit("="*50)
            
            try:
                # Check if it's a valid super image
                img_type = detect_image_type(self._extracted_super_path)
                
                if img_type == 'sparse':
                    # First convert sparse to raw
                    self.log.emit("Super image is sparse, converting to raw first...")
                    raw_path = self._extracted_super_path.replace('.img', '_raw.img')
                    converter = SparseImageConverter()
                    converter.convert(self._extracted_super_path, raw_path)
                    self.log.emit(f"  Converted to: {raw_path}")
                    super_path = raw_path
                else:
                    super_path = self._extracted_super_path
                
                # Check again for super partition magic
                img_type = detect_image_type(super_path)
                
                if img_type != 'super':
                    self.log.emit(f"Warning: super.img is not a dynamic partition image (type: {img_type})")
                    self.log.emit("Skipping super extraction")
                    return
                
                # Create output directory for super contents
                super_output_dir = Path(self.output_dir) / "super_extracted"
                super_output_dir.mkdir(parents=True, exist_ok=True)
                
                # List partitions in super image
                extractor = SuperImageExtractor()
                partitions = extractor.list_partitions(super_path)
                
                if not partitions:
                    self.log.emit("No partitions found in super image")
                    return
                
                valid_partitions = [p for p in partitions if p.size > 0]
                self.log.emit(f"Found {len(valid_partitions)} partition(s) in super image:")
                
                for p in valid_partitions:
                    self.log.emit(f"  - {p.name}: {p.size / (1024*1024):.2f} MB")
                
                # Extract all partitions
                self.log.emit("\nExtracting partitions from super image...")
                results = extractor.extract(super_path, str(super_output_dir))
                
                for name, path in results.items():
                    self.log.emit(f"  Extracted: {name} -> {path}")
                    
                    # Detect and report sub-partition types
                    if Path(path).exists():
                        sub_type = detect_image_type(path)
                        if sub_type != 'raw':
                            self.log.emit(f"    (Type: {sub_type})")
                
                self.log.emit(f"\nSuper partition contents extracted to: {super_output_dir}")
                
            except Exception as e:
                self.log.emit(f"Error extracting super partition: {e}")

    class CreationThread(QThread):
        """Thread for creating payload files without blocking the UI."""
        
        progress = pyqtSignal(int, int, str)  # current, total, message
        log = pyqtSignal(str)
        error = pyqtSignal(str)
        finished = pyqtSignal(str)  # output path
        
        def __init__(self, image_paths: list[str], output_path: str,
                     compression: str, compression_level: int):
            super().__init__()
            self.image_paths = image_paths
            self.output_path = output_path
            self.compression = compression
            self.compression_level = compression_level
            self._cancelled = False
        
        def cancel(self):
            self._cancelled = True
        
        def run(self):
            try:
                def progress_callback(current, total, msg):
                    if self._cancelled:
                        raise InterruptedError("Cancelled")
                    self.progress.emit(current, total, msg)
                    self.log.emit(f"  {msg}")
                
                self.log.emit(f"Creating payload: {self.output_path}")
                self.log.emit(f"Compression: {self.compression} (level {self.compression_level})")
                self.log.emit(f"Processing {len(self.image_paths)} partition(s)...\n")
                
                creator = PayloadCreator(
                    output_path=self.output_path,
                    compression=self.compression,
                    compression_level=self.compression_level,
                    progress_callback=progress_callback
                )
                creator.create(self.image_paths)
                
                size_mb = Path(self.output_path).stat().st_size / (1024 * 1024)
                self.log.emit(f"\nPayload created: {self.output_path}")
                self.log.emit(f"Size: {size_mb:.2f} MB")
                self.finished.emit(self.output_path)
                
            except InterruptedError:
                self.log.emit("\nCreation cancelled")
            except Exception as e:
                self.error.emit(str(e))

    class DropLineEdit(QLineEdit):
        """Line edit that accepts drag and drop of files."""
        
        def __init__(self, parent=None):
            super().__init__(parent)
            self.setAcceptDrops(True)
            self.setPlaceholderText("Enter path, URL, or drag & drop a file...")
        
        def dragEnterEvent(self, event: QDragEnterEvent):
            if event.mimeData().hasUrls():
                event.acceptProposedAction()
        
        def dropEvent(self, event: QDropEvent):
            urls = event.mimeData().urls()
            if urls:
                self.setText(urls[0].toLocalFile())

    # Plugin store URL - used for both plugin store and app updates
    # Cloudflare Zero Trust tunnel handles routing to port 6000 on server
    PLUGIN_STORE_URL = os.environ.get('PLUGIN_STORE_URL', 'https://plugins.imageanarchy.com')

    # Cloudflare Zero Trust Service Token - required for API access
    # These headers must be included in ALL requests to the plugin store
    CF_ACCESS_CLIENT_ID = 'dc6fbd9543b624d3bf1c8df830b57982.access'
    CF_ACCESS_CLIENT_SECRET = '408d77ac1dbffc080f79e88bbca96f983b88990c95a145321057e674283efa44'

    def get_cf_headers() -> dict:
        """Get Cloudflare Zero Trust headers for API requests.
        
        Includes:
        - CF-Access headers for Zero Trust authentication
        - User-Agent header that passes Cloudflare WAF rules
        """
        return {
            'CF-Access-Client-Id': CF_ACCESS_CLIENT_ID,
            'CF-Access-Client-Secret': CF_ACCESS_CLIENT_SECRET,
            'User-Agent': f'ImageAnarchy/{APP_VERSION}'
        }

    # ── Remote Device Control Server ────────────────────────────────────────
    # Separate CF tunnel for the remote control relay (Socket.IO on port 6001)
    REMOTE_CTL_URL = os.environ.get('REMOTE_CTL_URL', 'https://remote.ctl.imageanarchy.com')
    RC_CF_ACCESS_CLIENT_ID = '3f0cf6be40764d4c2824ab8797a10043.access'
    RC_CF_ACCESS_CLIENT_SECRET = '6dc136a90dd50670cc2d39858f1b07145671207e0e67ee33c2bbedc6bf670dcc'

    def get_rc_cf_headers() -> dict:
        """Get Cloudflare headers for remote control server requests."""
        return {
            'CF-Access-Client-Id': RC_CF_ACCESS_CLIENT_ID,
            'CF-Access-Client-Secret': RC_CF_ACCESS_CLIENT_SECRET,
            'User-Agent': f'ImageAnarchy/{APP_VERSION}'
        }

    def get_http_requests():
        """Get HTTP session with Cloudflare bypass support.
        
        Returns a Session with impersonate='chrome' for curl_cffi
        (bypasses CF TLS fingerprinting), or a plain requests.Session
        as fallback.
        
        Returns:
            Session object with .get()/.post()/.delete()/.put() methods,
            or None if neither library is available
        """
        try:
            from curl_cffi import requests as curl_requests
            return curl_requests.Session(impersonate='chrome')
        except ImportError:
            try:
                import requests
                return requests.Session()
            except ImportError:
                return None

    class UpdateChecker(QThread):
        """Background thread to check for application updates."""
        update_available = pyqtSignal(dict)  # Emits update info if available
        check_failed = pyqtSignal(str)  # Emits error message if check fails
        download_progress = pyqtSignal(int, int)  # bytes_downloaded, total_bytes
        download_complete = pyqtSignal(str)  # Emits path to downloaded file
        download_failed = pyqtSignal(str)  # Emits error message

        def __init__(self, download_path: str = None):
            # IMPORTANT: Don't pass parent to QThread - causes threading errors
            super().__init__()
            self.download_path = download_path
            self._download_mode = False
            self._download_version = None

        def run(self):
            """Check for updates or download update file."""
            if self._download_mode:
                self._download_update()
            else:
                self._check_for_update()

        def _check_for_update(self):
            """Check server for available updates."""
            try:
                from curl_cffi import requests as cffi_requests

                url = f"{PLUGIN_STORE_URL}/api/updates/check?current_version={APP_VERSION}&platform=windows"
                headers = get_cf_headers()

                session = cffi_requests.Session(impersonate='chrome')
                resp = session.get(url, headers=headers, timeout=15)
                resp.raise_for_status()
                data = resp.json()

                if data.get('update_available'):
                    self.update_available.emit(data)
                # If no update, signal nothing (silent check)

            except Exception as e:
                # Silent failure for update checks - don't bother user
                logger.debug(f"Update check failed: {e}")

        def start_download(self, version: str, download_path: str):
            """Start downloading a specific version."""
            self._download_mode = True
            self._download_version = version
            self.download_path = download_path
            self.start()

        def _download_update(self):
            """Download the update file with progress reporting."""
            try:
                from curl_cffi import requests as cffi_requests

                url = f"{PLUGIN_STORE_URL}/api/updates/download/{self._download_version}"
                headers = get_cf_headers()

                session = cffi_requests.Session(impersonate='chrome')
                # Stream the download for progress reporting
                resp = session.get(url, headers=headers, timeout=300, stream=True)
                resp.raise_for_status()

                total_size = int(resp.headers.get('content-length', 0))
                downloaded = 0
                chunk_size = 65536  # 64KB chunks

                with open(self.download_path, 'wb') as f:
                    for chunk in resp.iter_content(chunk_size=chunk_size):
                        if chunk:
                            f.write(chunk)
                            downloaded += len(chunk)
                            self.download_progress.emit(downloaded, total_size)

                self.download_complete.emit(self.download_path)

            except Exception as e:
                self.download_failed.emit(str(e))

    class UpdateDialog(QDialog):
        """Dialog to show update information and handle update process."""

        def __init__(self, parent, update_info: dict):
            super().__init__(parent)
            self.update_info = update_info
            self.update_checker = None
            self._setup_ui()

        def _setup_ui(self):
            self.setWindowTitle("🔥 Update Available - Break Free!")
            self.setMinimumWidth(500)
            self.setStyleSheet("""
                QDialog {
                    background-color: #1e1e1e;
                    color: #d4d4d4;
                }
                QLabel {
                    color: #d4d4d4;
                }
                QPushButton {
                    padding: 10px 20px;
                    border: 1px solid #3c3c3c;
                    border-radius: 4px;
                    background-color: #2d2d2d;
                    color: #d4d4d4;
                }
                QPushButton:hover {
                    background-color: #3c3c3c;
                }
                QPushButton#update_btn {
                    background-color: #c62828;
                    border-color: #c62828;
                    color: white;
                    font-weight: bold;
                }
                QPushButton#update_btn:hover {
                    background-color: #e53935;
                }
                QProgressBar {
                    border: 1px solid #3c3c3c;
                    border-radius: 4px;
                    background-color: #2d2d2d;
                    text-align: center;
                }
                QProgressBar::chunk {
                    background-color: #c62828;
                    border-radius: 3px;
                }
            """)

            layout = QVBoxLayout(self)
            layout.setSpacing(15)

            # Header
            header = QLabel(f"🏴 Image Anarchy v{self.update_info.get('latest_version', '?')} is here!")
            header.setStyleSheet("font-size: 18px; font-weight: bold; color: #ff4444;")
            layout.addWidget(header)

            # Current vs New version
            version_label = QLabel(f"Current: v{APP_VERSION}  →  New: v{self.update_info.get('latest_version', '?')}")
            version_label.setStyleSheet("font-size: 14px; color: #888;")
            layout.addWidget(version_label)

            # Critical update warning
            if self.update_info.get('is_critical'):
                critical_label = QLabel("⚠️ CRITICAL UPDATE - Security or major bug fixes!")
                critical_label.setStyleSheet("font-size: 14px; font-weight: bold; color: #ff9800; padding: 10px; background-color: #3d2c00; border-radius: 4px;")
                layout.addWidget(critical_label)

            # Changelog
            changelog_label = QLabel("What's New:")
            changelog_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
            layout.addWidget(changelog_label)

            changelog_text = QTextEdit()
            changelog_text.setReadOnly(True)
            changelog_text.setMaximumHeight(200)
            changelog_text.setPlainText(self.update_info.get('changelog', 'No changelog available.'))
            changelog_text.setStyleSheet("background-color: #2d2d2d; border: 1px solid #3c3c3c; border-radius: 4px;")
            layout.addWidget(changelog_text)

            # File size
            size_mb = self.update_info.get('file_size', 0) / (1024 * 1024)
            size_label = QLabel(f"Download size: {size_mb:.1f} MB")
            size_label.setStyleSheet("color: #888;")
            layout.addWidget(size_label)

            # Progress bar (hidden initially)
            self.progress_bar = QProgressBar()
            self.progress_bar.setMinimum(0)
            self.progress_bar.setMaximum(100)
            self.progress_bar.setValue(0)
            self.progress_bar.setVisible(False)
            layout.addWidget(self.progress_bar)

            # Status label
            self.status_label = QLabel("")
            self.status_label.setStyleSheet("color: #888; font-size: 12px;")
            self.status_label.setVisible(False)
            layout.addWidget(self.status_label)

            # Buttons
            btn_layout = QHBoxLayout()

            self.skip_btn = QPushButton("Skip This Version")
            self.skip_btn.clicked.connect(self.reject)
            btn_layout.addWidget(self.skip_btn)

            self.later_btn = QPushButton("Remind Me Later")
            self.later_btn.clicked.connect(self.reject)
            btn_layout.addWidget(self.later_btn)

            btn_layout.addStretch()

            self.update_btn = QPushButton("🔥 Update Now!")
            self.update_btn.setObjectName("update_btn")
            self.update_btn.clicked.connect(self._start_update)
            btn_layout.addWidget(self.update_btn)

            layout.addLayout(btn_layout)

        def _start_update(self):
            """Start the update download process."""
            self.update_btn.setEnabled(False)
            self.skip_btn.setEnabled(False)
            self.later_btn.setEnabled(False)
            self.progress_bar.setVisible(True)
            self.status_label.setVisible(True)
            self.status_label.setText("Preparing download...")

            # Determine download path - same directory as current exe
            if getattr(sys, 'frozen', False):
                app_dir = os.path.dirname(sys.executable)
                exe_name = os.path.basename(sys.executable)
                # Download to temp name first
                download_path = os.path.join(app_dir, f"ImageAnarchy_v{self.update_info['latest_version']}.exe.download")
            else:
                # Running from source - just download to current directory
                app_dir = os.path.dirname(os.path.abspath(__file__))
                download_path = os.path.join(app_dir, f"ImageAnarchy_v{self.update_info['latest_version']}.exe")

            self.download_path = download_path
            self.final_path = download_path.replace('.download', '')

            # Create update checker for download
            self.update_checker = UpdateChecker(self)
            self.update_checker.download_progress.connect(self._on_progress)
            self.update_checker.download_complete.connect(self._on_download_complete)
            self.update_checker.download_failed.connect(self._on_download_failed)
            self.update_checker.start_download(self.update_info['latest_version'], download_path)

        def _on_progress(self, downloaded: int, total: int):
            """Update progress bar."""
            if total > 0:
                percent = int((downloaded / total) * 100)
                self.progress_bar.setValue(percent)
                downloaded_mb = downloaded / (1024 * 1024)
                total_mb = total / (1024 * 1024)
                self.status_label.setText(f"Downloading... {downloaded_mb:.1f} / {total_mb:.1f} MB ({percent}%)")
            else:
                downloaded_mb = downloaded / (1024 * 1024)
                self.status_label.setText(f"Downloading... {downloaded_mb:.1f} MB")

        def _on_download_complete(self, path: str):
            """Handle successful download."""
            self.status_label.setText("Download complete! Preparing to install...")
            self.progress_bar.setValue(100)

            try:
                # Rename download file to final name
                if os.path.exists(self.final_path):
                    # Backup old version
                    backup_path = self.final_path + ".backup"
                    if os.path.exists(backup_path):
                        os.remove(backup_path)
                    os.rename(self.final_path, backup_path)

                os.rename(path, self.final_path)

                # Verify SHA256 if provided
                if self.update_info.get('sha256'):
                    self.status_label.setText("Verifying download integrity...")
                    with open(self.final_path, 'rb') as f:
                        file_hash = hashlib.sha256(f.read()).hexdigest()

                    if file_hash.lower() != self.update_info['sha256'].lower():
                        raise ValueError("Download verification failed - file may be corrupted!")

                self.status_label.setText("✅ Update ready! Restart to use the new version.")
                self.status_label.setStyleSheet("color: #4caf50; font-size: 12px; font-weight: bold;")

                # Change button to restart
                self.update_btn.setText("🔄 Restart Now")
                self.update_btn.setEnabled(True)
                self.update_btn.clicked.disconnect()
                self.update_btn.clicked.connect(self._restart_app)

                self.later_btn.setText("Restart Later")
                self.later_btn.setEnabled(True)

            except Exception as e:
                self._on_download_failed(str(e))

        def _on_download_failed(self, error: str):
            """Handle download failure."""
            self.status_label.setText(f"❌ Download failed: {error}")
            self.status_label.setStyleSheet("color: #f44336; font-size: 12px;")
            self.update_btn.setEnabled(True)
            self.update_btn.setText("Try Again")
            self.later_btn.setEnabled(True)
            self.skip_btn.setEnabled(True)

        def _restart_app(self):
            """Restart the application with the new version."""
            if getattr(sys, 'frozen', False):
                # For frozen exe, we need to start the new exe and close this one
                import subprocess

                # Start the new version
                subprocess.Popen([self.final_path], creationflags=subprocess.CREATE_NEW_CONSOLE if sys.platform == 'win32' else 0)

                # Close current app
                QApplication.instance().quit()
            else:
                # For source, just show message
                QMessageBox.information(self, "Update Downloaded",
                    f"New version downloaded to:\n{self.final_path}\n\nPlease run it manually.")
                self.accept()

    class ImageAnarchyGUI(QMainWindow):
        """Main application window."""
        
        STYLESHEET = """
            QMainWindow, QWidget {
                background-color: #1e1e1e;
                color: #d4d4d4;
                font-size: 13px;
            }
            QGroupBox {
                font-weight: bold;
                border: 1px solid #3c3c3c;
                border-radius: 6px;
                margin-top: 12px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 12px;
                padding: 0 6px;
            }
            QLineEdit, QListWidget, QTextEdit {
                padding: 8px;
                border: 1px solid #3c3c3c;
                border-radius: 4px;
                background-color: #2d2d2d;
                selection-background-color: #264f78;
            }
            QLineEdit:focus {
                border-color: #0078d4;
            }
            QPushButton {
                padding: 8px 16px;
                border: 1px solid #3c3c3c;
                border-radius: 4px;
                background-color: #2d2d2d;
            }
            QPushButton:hover {
                background-color: #3c3c3c;
            }
            QPushButton:pressed {
                background-color: #1e1e1e;
            }
            QPushButton:disabled {
                color: #6d6d6d;
            }
            QPushButton[primary="true"] {
                background-color: #0078d4;
                border-color: #0078d4;
                color: white;
            }
            QPushButton[primary="true"]:hover {
                background-color: #1084d8;
            }
            QPushButton[primary="true"]:disabled {
                background-color: #2d5a7b;
                color: #8a8a8a;
            }
            QListWidget::item {
                padding: 8px;
                border-bottom: 1px solid #3c3c3c;
            }
            QListWidget::item:selected {
                background-color: #264f78;
            }
            QListWidget::item:hover {
                background-color: #3c3c3c;
            }
            QProgressBar {
                border: 1px solid #3c3c3c;
                border-radius: 4px;
                background-color: #2d2d2d;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #0078d4;
                border-radius: 3px;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border: 1px solid #3c3c3c;
                border-radius: 3px;
                background-color: #2d2d2d;
            }
            QCheckBox::indicator:checked {
                background-color: #0078d4;
                border-color: #0078d4;
            }
            QStatusBar {
                background-color: #007acc;
                color: white;
            }
            QSplitter::handle {
                background-color: #3c3c3c;
            }
            QScrollBar:vertical {
                background-color: #1e1e1e;
                width: 12px;
            }
            QScrollBar::handle:vertical {
                background-color: #424242;
                border-radius: 6px;
                min-height: 20px;
                margin: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #525252;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0;
            }
        """
        
        def __init__(self):
            super().__init__()
            self.analyzer_thread: Optional[PayloadAnalyzerThread] = None
            self.extraction_thread: Optional[ExtractionThread] = None
            self.creation_thread: Optional[CreationThread] = None
            self.partitions: list[PartitionDisplayInfo] = []
            self.repack_images: list[str] = []
            
            self._force_quit = False  # Flag to allow actual quit vs minimize to tray
            self._setup_ui()
            self._apply_styles()
            self._setup_system_tray()
            self._setup_drag_drop()

            # Check for updates on startup (non-blocking, deferred to allow window to fully initialize)
            QTimer.singleShot(500, self._check_for_updates)

        def _check_for_updates(self):
            """Check for application updates in background."""
            self.update_checker = UpdateChecker()
            self.update_checker.update_available.connect(self._on_update_available)
            self.update_checker.finished.connect(self._on_update_check_finished)
            self.update_checker.start()

        def _on_update_check_finished(self):
            """Clean up update checker thread when finished."""
            if self.update_checker:
                self.update_checker.deleteLater()
                self.update_checker = None

        def _on_update_available(self, update_info: dict):
            """Show update dialog when update is available."""
            dialog = UpdateDialog(self, update_info)
            dialog.exec()

        def _setup_system_tray(self):
            """Setup the rebellious system tray icon."""
            self.tray_icon = QSystemTrayIcon(self)
            
            # Create anarchy icon programmatically
            pixmap = QPixmap(64, 64)
            pixmap.fill(Qt.GlobalColor.transparent)
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw circle-A anarchy symbol
            from PyQt6.QtGui import QPen, QBrush
            from PyQt6.QtCore import QRectF
            
            # Outer circle
            pen = QPen(QColor('#ff4444'))
            pen.setWidth(4)
            painter.setPen(pen)
            painter.drawEllipse(QRectF(4, 4, 56, 56))
            
            # The 'A'
            pen.setWidth(5)
            painter.setPen(pen)
            # Left leg
            painter.drawLine(32, 8, 12, 52)
            # Right leg  
            painter.drawLine(32, 8, 52, 52)
            # Crossbar
            painter.drawLine(18, 36, 46, 36)
            # Extended bottom (the anarchy style)
            painter.drawLine(32, 8, 32, 58)
            
            painter.end()
            self.tray_icon.setIcon(QIcon(pixmap))
            
            # Create context menu
            tray_menu = QMenu()
            tray_menu.setStyleSheet("""
                QMenu {
                    background-color: #2d2d2d;
                    color: #d4d4d4;
                    border: 1px solid #3c3c3c;
                    padding: 4px;
                }
                QMenu::item {
                    padding: 8px 20px;
                }
                QMenu::item:selected {
                    background-color: #c62828;
                }
            """)
            
            # Actions with anarchy flair
            show_action = QAction("🏴 Unleash Anarchy", self)
            show_action.triggered.connect(self._tray_show_window)
            tray_menu.addAction(show_action)
            
            tray_menu.addSeparator()
            
            extract_action = QAction("💣 Quick Extract", self)
            extract_action.triggered.connect(self._tray_quick_extract)
            tray_menu.addAction(extract_action)
            
            tray_menu.addSeparator()
            
            quit_action = QAction("💀 Burn It Down", self)
            quit_action.triggered.connect(self._force_quit_app)
            tray_menu.addAction(quit_action)
            
            self.tray_icon.setContextMenu(tray_menu)
            self.tray_icon.setToolTip("Image Anarchy - Right-click for chaos")
            self.tray_icon.activated.connect(self._tray_activated)
            self.tray_icon.show()
        
        def _setup_drag_drop(self):
            """Enable drag and drop for the main window."""
            self.setAcceptDrops(True)
        
        def dragEnterEvent(self, event: QDragEnterEvent):
            """Accept drags with file URLs."""
            if event.mimeData().hasUrls():
                # Check if any file is a supported type
                for url in event.mimeData().urls():
                    path = url.toLocalFile().lower()
                    if any(path.endswith(ext) for ext in ['.bin', '.img', '.zip', '.payload']):
                        event.acceptProposedAction()
                        self._show_toast("💣 Drop it like it's hot!", 'chaos')
                        return
            event.ignore()
        
        def dropEvent(self, event: QDropEvent):
            """Handle dropped files - route to appropriate handler."""
            files = [url.toLocalFile() for url in event.mimeData().urls()]
            
            for file_path in files:
                lower_path = file_path.lower()
                
                if lower_path.endswith('.bin') or 'payload' in lower_path:
                    # Payload file - go to extract tab
                    self.tab_widget.setCurrentIndex(0)  # Extract tab
                    self.path_input.setText(file_path)
                    self._show_toast(f"🔥 Payload locked and loaded!", 'success')
                    self._load_payload()
                    break
                    
                elif lower_path.endswith('.img'):
                    # Image file - go to Image Extract tab
                    for i in range(self.tab_widget.count()):
                        if 'Image' in self.tab_widget.tabText(i):
                            self.tab_widget.setCurrentIndex(i)
                            break
                    if hasattr(self, 'image_path_input'):
                        self.image_path_input.setText(file_path)
                        self._show_toast(f"🛠️ Image ready for destruction!", 'success')
                    break
                    
                elif lower_path.endswith('.zip'):
                    # ZIP file - could be OTA
                    self.tab_widget.setCurrentIndex(0)
                    self.path_input.setText(file_path)
                    self._show_toast(f"📦 OTA package detected - unleashing!", 'success')
                    self._load_payload()
                    break
            
            event.acceptProposedAction()
        
        def _tray_activated(self, reason):
            """Handle tray icon activation."""
            if reason == QSystemTrayIcon.ActivationReason.DoubleClick:
                self._tray_show_window()
        
        def _tray_show_window(self):
            """Show and raise the main window."""
            self.showNormal()
            self.activateWindow()
            self.raise_()
        
        def _tray_quick_extract(self):
            """Open file dialog for quick extraction from tray."""
            self._tray_show_window()
            self._browse_payload()
        
        def _show_toast(self, message: str, toast_type: str = 'info'):
            """Show a rebellious toast notification."""
            AnarchyToast(self, message, toast_type)
        
        def _show_tray_notification(self, title: str, message: str, icon_type: str = 'info'):
            """Show a system notification from tray."""
            icons = {
                'info': QSystemTrayIcon.MessageIcon.Information,
                'warning': QSystemTrayIcon.MessageIcon.Warning,
                'error': QSystemTrayIcon.MessageIcon.Critical,
            }
            self.tray_icon.showMessage(title, message, icons.get(icon_type, icons['info']), 3000)
        
        def _force_quit_app(self):
            """Force quit the application - no minimize to tray."""
            self._force_quit = True
            # Hide tray icon first to prevent orphaned icons
            self.tray_icon.hide()
            # Close the application
            QApplication.instance().quit()
        
        def closeEvent(self, event):
            """Minimize to tray instead of closing, unless force quit."""
            if self._force_quit:
                # User chose to quit - actually close
                self.tray_icon.hide()  # Ensure tray icon is removed
                event.accept()
            elif self.tray_icon.isVisible():
                self._show_toast("👻 Anarchy lurks in the shadows...", 'chaos')
                self.hide()
                self._show_tray_notification(
                    "Image Anarchy",
                    "Still running in the tray. Right-click to unleash chaos!",
                    'info'
                )
                event.ignore()
            else:
                event.accept()
        
        def _setup_ui(self):
            self.setWindowTitle(f"Image Anarchy {APP_VERSION} - Android Image Swiss Army Knife")
            self.setMinimumSize(1280, 900)
            self.resize(1400, 1000)
            
            central = QWidget()
            self.setCentralWidget(central)
            main_layout = QVBoxLayout(central)
            main_layout.setSpacing(12)
            main_layout.setContentsMargins(16, 16, 16, 16)
            
            # Tab widget for Extract/Repack modes
            self.tab_widget = QTabWidget()
            self.tab_widget.setDocumentMode(True)
            
            # ===================== EXTRACT TAB =====================
            extract_tab = QWidget()
            layout = QVBoxLayout(extract_tab)
            layout.setSpacing(12)
            layout.setContentsMargins(8, 12, 8, 8)
            
            # Input section
            input_group = QGroupBox("Payload Source")
            input_layout = QVBoxLayout(input_group)
            
            path_layout = QHBoxLayout()
            self.path_input = DropLineEdit()
            self.browse_btn = QPushButton("Browse...")
            self.browse_btn.clicked.connect(self._browse_payload)
            self.load_btn = QPushButton("Load")
            self.load_btn.setProperty("primary", True)
            self.load_btn.clicked.connect(self._load_payload)
            
            path_layout.addWidget(self.path_input, 1)
            path_layout.addWidget(self.browse_btn)
            path_layout.addWidget(self.load_btn)
            input_layout.addLayout(path_layout)
            layout.addWidget(input_group)
            
            # Main splitter
            splitter = QSplitter(Qt.Orientation.Horizontal)
            
            # Partitions list
            partitions_group = QGroupBox("Partitions")
            partitions_layout = QVBoxLayout(partitions_group)
            
            self.partitions_list = QListWidget()
            self.partitions_list.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)
            self.partitions_list.setAlternatingRowColors(True)
            partitions_layout.addWidget(self.partitions_list)
            
            selection_layout = QHBoxLayout()
            self.select_all_btn = QPushButton("Select All")
            self.select_all_btn.clicked.connect(self._select_all)
            self.select_none_btn = QPushButton("Select None")
            self.select_none_btn.clicked.connect(self._select_none)
            selection_layout.addWidget(self.select_all_btn)
            selection_layout.addWidget(self.select_none_btn)
            selection_layout.addStretch()
            partitions_layout.addLayout(selection_layout)
            
            splitter.addWidget(partitions_group)
            
            # Right panel
            right_panel = QWidget()
            right_layout = QVBoxLayout(right_panel)
            right_layout.setContentsMargins(0, 0, 0, 0)
            
            # Output settings
            output_group = QGroupBox("Output Settings")
            output_layout = QVBoxLayout(output_group)
            
            out_dir_layout = QHBoxLayout()
            out_dir_layout.addWidget(QLabel("Output Directory:"))
            self.output_input = QLineEdit("output")
            self.output_browse_btn = QPushButton("Browse...")
            self.output_browse_btn.clicked.connect(self._browse_output)
            out_dir_layout.addWidget(self.output_input, 1)
            out_dir_layout.addWidget(self.output_browse_btn)
            output_layout.addLayout(out_dir_layout)
            
            self.diff_checkbox = QCheckBox("Differential OTA (requires original images)")
            self.diff_checkbox.toggled.connect(self._toggle_diff)
            output_layout.addWidget(self.diff_checkbox)
            
            # Super partition extraction option
            self.extract_super_checkbox = QCheckBox("Extract super partition contents (system, vendor, etc.)")
            self.extract_super_checkbox.setToolTip(
                "If super.img is extracted, automatically extract its sub-partitions\n"
                "(system, vendor, product, odm, etc.) to a 'super_extracted' subfolder"
            )
            output_layout.addWidget(self.extract_super_checkbox)
            
            old_dir_layout = QHBoxLayout()
            self.old_dir_label = QLabel("Original Images:")
            self.old_dir_input = QLineEdit("old")
            self.old_dir_browse_btn = QPushButton("Browse...")
            self.old_dir_browse_btn.clicked.connect(self._browse_old_dir)
            old_dir_layout.addWidget(self.old_dir_label)
            old_dir_layout.addWidget(self.old_dir_input, 1)
            old_dir_layout.addWidget(self.old_dir_browse_btn)
            output_layout.addLayout(old_dir_layout)
            
            self.old_dir_label.setVisible(False)
            self.old_dir_input.setVisible(False)
            self.old_dir_browse_btn.setVisible(False)
            
            right_layout.addWidget(output_group)
            
            # Log output
            log_group = QGroupBox("Log")
            log_layout = QVBoxLayout(log_group)
            self.log_output = QTextEdit()
            self.log_output.setReadOnly(True)
            self.log_output.setFont(QFont("Consolas", 9))
            log_layout.addWidget(self.log_output)
            right_layout.addWidget(log_group, 1)
            
            splitter.addWidget(right_panel)
            splitter.setSizes([300, 500])
            layout.addWidget(splitter, 1)
            
            # Progress
            progress_layout = QHBoxLayout()
            self.progress_bar = QProgressBar()
            self.progress_bar.setMinimumHeight(24)
            self.progress_label = QLabel("Ready")
            progress_layout.addWidget(self.progress_bar, 1)
            progress_layout.addWidget(self.progress_label)
            layout.addLayout(progress_layout)
            
            # Actions
            action_layout = QHBoxLayout()
            action_layout.addStretch()
            
            self.extract_btn = QPushButton("Extract Selected")
            self.extract_btn.setProperty("primary", True)
            self.extract_btn.setMinimumWidth(150)
            self.extract_btn.clicked.connect(self._start_extraction)
            self.extract_btn.setEnabled(False)
            
            self.cancel_btn = QPushButton("Cancel")
            self.cancel_btn.clicked.connect(self._cancel_extraction)
            self.cancel_btn.setEnabled(False)
            self.cancel_btn.setVisible(False)
            
            action_layout.addWidget(self.cancel_btn)
            action_layout.addWidget(self.extract_btn)
            layout.addLayout(action_layout)
            
            self.tab_widget.addTab(extract_tab, "📦 Extract")
            
            # ===================== REPACK TAB =====================
            repack_tab = QWidget()
            repack_layout = QVBoxLayout(repack_tab)
            repack_layout.setSpacing(12)
            repack_layout.setContentsMargins(8, 12, 8, 8)
            
            # Input images section
            input_group = QGroupBox("Partition Images")
            input_layout = QVBoxLayout(input_group)
            
            input_dir_layout = QHBoxLayout()
            input_dir_layout.addWidget(QLabel("Images Directory:"))
            self.repack_input_dir = QLineEdit("output")
            self.repack_input_dir.setPlaceholderText("Directory containing .img files...")
            self.repack_browse_input_btn = QPushButton("Browse...")
            self.repack_browse_input_btn.clicked.connect(self._browse_repack_input)
            self.repack_scan_btn = QPushButton("Scan")
            self.repack_scan_btn.setProperty("primary", True)
            self.repack_scan_btn.clicked.connect(self._scan_images)
            input_dir_layout.addWidget(self.repack_input_dir, 1)
            input_dir_layout.addWidget(self.repack_browse_input_btn)
            input_dir_layout.addWidget(self.repack_scan_btn)
            input_layout.addLayout(input_dir_layout)
            repack_layout.addWidget(input_group)
            
            # Repack splitter
            repack_splitter = QSplitter(Qt.Orientation.Horizontal)
            
            # Images list
            images_group = QGroupBox("Found Images")
            images_layout = QVBoxLayout(images_group)
            
            self.repack_images_list = QListWidget()
            self.repack_images_list.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)
            self.repack_images_list.setAlternatingRowColors(True)
            images_layout.addWidget(self.repack_images_list)
            
            repack_sel_layout = QHBoxLayout()
            self.repack_select_all_btn = QPushButton("Select All")
            self.repack_select_all_btn.clicked.connect(self._repack_select_all)
            self.repack_select_none_btn = QPushButton("Select None")
            self.repack_select_none_btn.clicked.connect(self._repack_select_none)
            repack_sel_layout.addWidget(self.repack_select_all_btn)
            repack_sel_layout.addWidget(self.repack_select_none_btn)
            repack_sel_layout.addStretch()
            images_layout.addLayout(repack_sel_layout)
            
            repack_splitter.addWidget(images_group)
            
            # Repack settings panel
            repack_right = QWidget()
            repack_right_layout = QVBoxLayout(repack_right)
            repack_right_layout.setContentsMargins(0, 0, 0, 0)
            
            # Output settings
            repack_output_group = QGroupBox("Output Settings")
            repack_output_layout = QVBoxLayout(repack_output_group)
            
            out_file_layout = QHBoxLayout()
            out_file_layout.addWidget(QLabel("Output File:"))
            self.repack_output_path = QLineEdit("payload.bin")
            self.repack_browse_output_btn = QPushButton("Browse...")
            self.repack_browse_output_btn.clicked.connect(self._browse_repack_output)
            out_file_layout.addWidget(self.repack_output_path, 1)
            out_file_layout.addWidget(self.repack_browse_output_btn)
            repack_output_layout.addLayout(out_file_layout)
            
            # Compression settings
            compress_layout = QHBoxLayout()
            compress_layout.addWidget(QLabel("Compression:"))
            self.compression_combo = QComboBox()
            self.compression_combo.addItems(["zstd", "xz", "bz2", "none"])
            self.compression_combo.setCurrentText("zstd")
            compress_layout.addWidget(self.compression_combo)
            compress_layout.addWidget(QLabel("Level:"))
            self.compression_level = QSpinBox()
            self.compression_level.setRange(1, 22)
            self.compression_level.setValue(9)
            compress_layout.addWidget(self.compression_level)
            compress_layout.addStretch()
            repack_output_layout.addLayout(compress_layout)
            
            repack_right_layout.addWidget(repack_output_group)
            
            # Repack log
            repack_log_group = QGroupBox("Log")
            repack_log_layout = QVBoxLayout(repack_log_group)
            self.repack_log_output = QTextEdit()
            self.repack_log_output.setReadOnly(True)
            self.repack_log_output.setFont(QFont("Consolas", 9))
            repack_log_layout.addWidget(self.repack_log_output)
            repack_right_layout.addWidget(repack_log_group, 1)
            
            repack_splitter.addWidget(repack_right)
            repack_splitter.setSizes([300, 500])
            repack_layout.addWidget(repack_splitter, 1)
            
            # Repack progress
            repack_progress_layout = QHBoxLayout()
            self.repack_progress_bar = QProgressBar()
            self.repack_progress_bar.setMinimumHeight(24)
            self.repack_progress_label = QLabel("Ready")
            repack_progress_layout.addWidget(self.repack_progress_bar, 1)
            repack_progress_layout.addWidget(self.repack_progress_label)
            repack_layout.addLayout(repack_progress_layout)
            
            # Repack actions
            repack_action_layout = QHBoxLayout()
            repack_action_layout.addStretch()
            
            self.repack_btn = QPushButton("Create Payload")
            self.repack_btn.setProperty("primary", True)
            self.repack_btn.setMinimumWidth(150)
            self.repack_btn.clicked.connect(self._start_repack)
            self.repack_btn.setEnabled(False)
            
            self.repack_cancel_btn = QPushButton("Cancel")
            self.repack_cancel_btn.clicked.connect(self._cancel_repack)
            self.repack_cancel_btn.setEnabled(False)
            self.repack_cancel_btn.setVisible(False)
            
            repack_action_layout.addWidget(self.repack_cancel_btn)
            repack_action_layout.addWidget(self.repack_btn)
            repack_layout.addLayout(repack_action_layout)
            
            self.tab_widget.addTab(repack_tab, "🔧 Repack")
            
            # =========================================
            # Tab 3: Image Extract
            # =========================================
            image_tab = QWidget()
            image_layout = QVBoxLayout(image_tab)
            image_layout.setContentsMargins(16, 16, 16, 16)
            image_layout.setSpacing(12)
            
            # Image input
            image_input_layout = QHBoxLayout()
            image_input_layout.addWidget(QLabel("Image File:"))
            self.image_path_input = QLineEdit()
            self.image_path_input.setPlaceholderText("Select an Android image file (sparse, boot, super, ext4, erofs)...")
            self.image_browse_btn = QPushButton("Browse...")
            self.image_browse_btn.clicked.connect(self._browse_image)
            self.image_analyze_btn = QPushButton("Analyze")
            self.image_analyze_btn.setProperty("primary", True)
            self.image_analyze_btn.clicked.connect(self._analyze_image)
            image_input_layout.addWidget(self.image_path_input, 1)
            image_input_layout.addWidget(self.image_browse_btn)
            image_input_layout.addWidget(self.image_analyze_btn)
            image_layout.addLayout(image_input_layout)
            
            # Splitter for details and log
            image_splitter = QSplitter(Qt.Orientation.Horizontal)
            
            # Left side - Image info and partitions
            image_left = QWidget()
            image_left_layout = QVBoxLayout(image_left)
            image_left_layout.setContentsMargins(0, 0, 0, 0)
            
            # Image info
            image_info_group = QGroupBox("Image Information")
            image_info_layout = QFormLayout(image_info_group)
            self.image_type_label = QLabel("-")
            self.image_size_label = QLabel("-")
            self.image_details_label = QLabel("-")
            self.image_details_label.setWordWrap(True)
            image_info_layout.addRow("Type:", self.image_type_label)
            image_info_layout.addRow("Size:", self.image_size_label)
            image_info_layout.addRow("Details:", self.image_details_label)
            image_left_layout.addWidget(image_info_group)
            
            # Partitions tree (for super images)
            image_parts_group = QGroupBox("Partitions / Contents")
            image_parts_layout = QVBoxLayout(image_parts_group)
            self.image_tree = QTreeWidget()
            self.image_tree.setHeaderLabels(["Name", "Size", "Type"])
            self.image_tree.header().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
            self.image_tree.header().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
            self.image_tree.header().setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
            image_parts_layout.addWidget(self.image_tree)
            
            # Select all/none buttons
            image_select_layout = QHBoxLayout()
            image_select_all_btn = QPushButton("Select All")
            image_select_all_btn.clicked.connect(lambda: self._toggle_image_tree_selection(True))
            image_select_none_btn = QPushButton("Select None")
            image_select_none_btn.clicked.connect(lambda: self._toggle_image_tree_selection(False))
            image_select_layout.addWidget(image_select_all_btn)
            image_select_layout.addWidget(image_select_none_btn)
            image_select_layout.addStretch()
            image_parts_layout.addLayout(image_select_layout)
            
            image_left_layout.addWidget(image_parts_group, 1)
            image_splitter.addWidget(image_left)
            
            # Right side - Output and log
            image_right = QWidget()
            image_right_layout = QVBoxLayout(image_right)
            image_right_layout.setContentsMargins(0, 0, 0, 0)
            
            # Output settings
            image_output_group = QGroupBox("Output Settings")
            image_output_layout = QVBoxLayout(image_output_group)
            
            image_out_layout = QHBoxLayout()
            image_out_layout.addWidget(QLabel("Output:"))
            self.image_output_dir = QLineEdit()
            self.image_output_dir.setText(str(Path.cwd() / "extracted_images"))
            self.image_browse_output_btn = QPushButton("Browse...")
            self.image_browse_output_btn.clicked.connect(self._browse_image_output)
            image_out_layout.addWidget(self.image_output_dir, 1)
            image_out_layout.addWidget(self.image_browse_output_btn)
            image_output_layout.addLayout(image_out_layout)
            
            # Options
            image_options_layout = QHBoxLayout()
            self.convert_sparse_check = QCheckBox("Convert sparse to raw")
            self.convert_sparse_check.setChecked(True)
            self.extract_boot_check = QCheckBox("Extract boot components")
            self.extract_boot_check.setChecked(True)
            image_options_layout.addWidget(self.convert_sparse_check)
            image_options_layout.addWidget(self.extract_boot_check)
            image_options_layout.addStretch()
            image_output_layout.addLayout(image_options_layout)
            
            # vbmeta patching options (hidden by default)
            self.vbmeta_options_group = QGroupBox("vbmeta Patching Options")
            vbmeta_options_layout = QVBoxLayout(self.vbmeta_options_group)
            
            vbmeta_info_label = QLabel(
                "⚠️ Warning: Patching vbmeta invalidates the signature.\n"
                "Device bootloader must be unlocked to use patched vbmeta."
            )
            vbmeta_info_label.setStyleSheet("color: #FFA500; font-size: 11px;")
            vbmeta_options_layout.addWidget(vbmeta_info_label)
            
            vbmeta_check_layout = QHBoxLayout()
            self.disable_verity_check = QCheckBox("Disable dm-verity")
            self.disable_verity_check.setToolTip(
                "Disables dm-verity hashtree verification.\n"
                "Allows modifying system/vendor partitions without boot failure."
            )
            self.disable_verification_check = QCheckBox("Disable AVB verification")
            self.disable_verification_check.setToolTip(
                "Disables Android Verified Boot signature checking.\n"
                "Required when using modified boot/system images."
            )
            vbmeta_check_layout.addWidget(self.disable_verity_check)
            vbmeta_check_layout.addWidget(self.disable_verification_check)
            vbmeta_check_layout.addStretch()
            vbmeta_options_layout.addLayout(vbmeta_check_layout)
            
            # Reset flags option (separate row for visibility)
            reset_layout = QHBoxLayout()
            self.reset_vbmeta_flags_check = QCheckBox("🔄 Reset flags to stock (0x00)")
            self.reset_vbmeta_flags_check.setToolTip(
                "Reset ALL vbmeta flags to 0 (stock state).\n\n"
                "⚠️ IMPORTANT: This still invalidates the signature!\n"
                "The bootloader will REJECT this unless:\n"
                "  • Bootloader is UNLOCKED, or\n"
                "  • You also re-sign with a custom enrolled key\n\n"
                "To truly restore stock verification:\n"
                "Flash the ORIGINAL untouched vbmeta.img from factory firmware."
            )
            self.reset_vbmeta_flags_check.setStyleSheet("color: #00ff88;")
            self.reset_vbmeta_flags_check.stateChanged.connect(self._toggle_reset_flags_mode)
            reset_layout.addWidget(self.reset_vbmeta_flags_check)
            reset_layout.addStretch()
            vbmeta_options_layout.addLayout(reset_layout)
            
            # Current flags display
            self.vbmeta_current_flags = QLabel("Current flags: -")
            self.vbmeta_current_flags.setStyleSheet("color: #888; font-size: 10px;")
            vbmeta_options_layout.addWidget(self.vbmeta_current_flags)
            
            # Re-signing options
            signing_layout = QHBoxLayout()
            self.resign_vbmeta_check = QCheckBox("Re-sign with custom key")
            self.resign_vbmeta_check.setToolTip(
                "Re-sign the patched vbmeta with a custom AVB key.\n"
                "Only useful for:\n"
                "- Custom ROM developers\n"
                "- Devices with enrolled custom keys\n"
                "- Development/testing environments"
            )
            self.resign_vbmeta_check.stateChanged.connect(self._toggle_signing_options)
            signing_layout.addWidget(self.resign_vbmeta_check)
            
            # Check if cryptography is available
            if not CRYPTO_AVAILABLE:
                self.resign_vbmeta_check.setEnabled(False)
                self.resign_vbmeta_check.setToolTip(
                    "cryptography library not installed.\n"
                    "Install with: pip install cryptography"
                )
            
            signing_layout.addStretch()
            vbmeta_options_layout.addLayout(signing_layout)
            
            # Key selection (hidden by default)
            self.signing_options_widget = QWidget()
            signing_opts_layout = QVBoxLayout(self.signing_options_widget)
            signing_opts_layout.setContentsMargins(20, 0, 0, 0)
            
            # Key source selection
            key_source_layout = QHBoxLayout()
            self.key_generate_radio = QRadioButton("Generate new key")
            self.key_load_radio = QRadioButton("Load existing key")
            self.key_generate_radio.setChecked(True)
            key_source_layout.addWidget(self.key_generate_radio)
            key_source_layout.addWidget(self.key_load_radio)
            key_source_layout.addStretch()
            signing_opts_layout.addLayout(key_source_layout)
            
            # Key size selection (for generation)
            self.key_size_widget = QWidget()
            key_size_layout = QHBoxLayout(self.key_size_widget)
            key_size_layout.setContentsMargins(0, 0, 0, 0)
            key_size_layout.addWidget(QLabel("Key size:"))
            self.key_size_combo = QComboBox()
            self.key_size_combo.addItems(["RSA-2048", "RSA-4096", "RSA-8192"])
            self.key_size_combo.setCurrentIndex(1)  # Default to 4096
            key_size_layout.addWidget(self.key_size_combo)
            self.save_key_check = QCheckBox("Save generated key")
            self.save_key_check.setToolTip("Save the generated key pair for future use")
            key_size_layout.addWidget(self.save_key_check)
            key_size_layout.addStretch()
            signing_opts_layout.addWidget(self.key_size_widget)
            
            # Key file selection (for loading)
            self.key_file_widget = QWidget()
            key_file_layout = QHBoxLayout(self.key_file_widget)
            key_file_layout.setContentsMargins(0, 0, 0, 0)
            key_file_layout.addWidget(QLabel("Private key:"))
            self.key_file_edit = QLineEdit()
            self.key_file_edit.setPlaceholderText("Path to PEM private key file...")
            key_file_layout.addWidget(self.key_file_edit, 1)
            self.key_file_browse_btn = QPushButton("Browse...")
            self.key_file_browse_btn.clicked.connect(self._browse_key_file)
            key_file_layout.addWidget(self.key_file_browse_btn)
            signing_opts_layout.addWidget(self.key_file_widget)
            self.key_file_widget.setVisible(False)
            
            # Connect radio buttons
            self.key_generate_radio.toggled.connect(self._toggle_key_source)
            
            self.signing_options_widget.setVisible(False)
            vbmeta_options_layout.addWidget(self.signing_options_widget)
            
            # Signing status
            self.signing_status_label = QLabel("")
            self.signing_status_label.setStyleSheet("color: #888; font-size: 10px;")
            vbmeta_options_layout.addWidget(self.signing_status_label)
            
            self.vbmeta_options_group.setVisible(False)
            image_output_layout.addWidget(self.vbmeta_options_group)
            
            image_right_layout.addWidget(image_output_group)
            
            # Image log
            image_log_group = QGroupBox("Log")
            image_log_layout = QVBoxLayout(image_log_group)
            self.image_log_output = QTextEdit()
            self.image_log_output.setReadOnly(True)
            self.image_log_output.setFont(QFont("Consolas", 9))
            image_log_layout.addWidget(self.image_log_output)
            image_right_layout.addWidget(image_log_group, 1)
            
            image_splitter.addWidget(image_right)
            image_splitter.setSizes([300, 500])
            image_layout.addWidget(image_splitter, 1)
            
            # Image progress
            image_progress_layout = QHBoxLayout()
            self.image_progress_bar = QProgressBar()
            self.image_progress_bar.setMinimumHeight(24)
            self.image_progress_label = QLabel("Ready")
            image_progress_layout.addWidget(self.image_progress_bar, 1)
            image_progress_layout.addWidget(self.image_progress_label)
            image_layout.addLayout(image_progress_layout)
            
            # Image actions
            image_action_layout = QHBoxLayout()
            image_action_layout.addStretch()
            
            self.image_extract_btn = QPushButton("Extract Image")
            self.image_extract_btn.setProperty("primary", True)
            self.image_extract_btn.setMinimumWidth(150)
            self.image_extract_btn.clicked.connect(self._start_image_extract)
            self.image_extract_btn.setEnabled(False)
            
            self.image_cancel_btn = QPushButton("Cancel")
            self.image_cancel_btn.clicked.connect(self._cancel_image_extract)
            self.image_cancel_btn.setEnabled(False)
            self.image_cancel_btn.setVisible(False)
            
            image_action_layout.addWidget(self.image_cancel_btn)
            image_action_layout.addWidget(self.image_extract_btn)
            image_layout.addLayout(image_action_layout)
            
            self.tab_widget.addTab(image_tab, "🔍 Image Extract")
            
            # =============================================================
            # TAB 4: IMAGE REPACK
            # =============================================================
            repack_img_tab = QWidget()
            repack_img_outer_layout = QVBoxLayout(repack_img_tab)
            repack_img_outer_layout.setContentsMargins(0, 0, 0, 0)
            
            # Wrap in scroll area for 1080p compatibility
            repack_scroll = QScrollArea()
            repack_scroll.setWidgetResizable(True)
            repack_scroll.setStyleSheet("QScrollArea { border: none; }")
            
            repack_scroll_content = QWidget()
            repack_img_layout = QVBoxLayout(repack_scroll_content)
            repack_img_layout.setContentsMargins(10, 10, 10, 10)
            
            # Repack type selector
            repack_type_group = QGroupBox("Image Type to Create")
            repack_type_layout = QVBoxLayout(repack_type_group)
            
            self.repack_type_combo = QComboBox()
            self.repack_type_combo.addItems([
                "Boot Image (boot.img / recovery.img)",
                "Vendor Boot Image (vendor_boot.img)",
                "Sparse Image (from raw)",
                "vbmeta Image (disabled AVB)",
                "Ramdisk (from directory)",
                "Super Partition (dynamic partitions)",
                "EROFS Image (from directory)"
            ])
            self.repack_type_combo.currentIndexChanged.connect(self._on_repack_type_changed)
            repack_type_layout.addWidget(self.repack_type_combo)
            
            repack_img_layout.addWidget(repack_type_group)
            
            # Stacked widget for different repack options
            self.repack_stack = QWidget()
            self.repack_stack_layout = QVBoxLayout(self.repack_stack)
            
            # === Boot Image Options ===
            self.boot_repack_widget = QWidget()
            boot_layout = QVBoxLayout(self.boot_repack_widget)
            
            # Header version
            boot_ver_layout = QHBoxLayout()
            boot_ver_layout.addWidget(QLabel("Header Version:"))
            self.boot_version_combo = QComboBox()
            self.boot_version_combo.addItems(["v0", "v1", "v2", "v3", "v4"])
            self.boot_version_combo.setCurrentIndex(2)  # Default v2
            self.boot_version_combo.currentIndexChanged.connect(self._on_boot_version_changed)
            boot_ver_layout.addWidget(self.boot_version_combo)
            boot_ver_layout.addStretch()
            boot_layout.addLayout(boot_ver_layout)
            
            # Kernel
            kernel_layout = QHBoxLayout()
            kernel_layout.addWidget(QLabel("Kernel:"))
            self.boot_kernel_edit = QLineEdit()
            self.boot_kernel_edit.setPlaceholderText("Path to kernel (Image/zImage)...")
            kernel_layout.addWidget(self.boot_kernel_edit, 1)
            self.boot_kernel_browse = QPushButton("Browse...")
            self.boot_kernel_browse.clicked.connect(lambda: self._browse_repack_file(self.boot_kernel_edit, "Kernel"))
            kernel_layout.addWidget(self.boot_kernel_browse)
            boot_layout.addLayout(kernel_layout)
            
            # Ramdisk
            ramdisk_layout = QHBoxLayout()
            ramdisk_layout.addWidget(QLabel("Ramdisk:"))
            self.boot_ramdisk_edit = QLineEdit()
            self.boot_ramdisk_edit.setPlaceholderText("Path to ramdisk.cpio.gz...")
            ramdisk_layout.addWidget(self.boot_ramdisk_edit, 1)
            self.boot_ramdisk_browse = QPushButton("Browse...")
            self.boot_ramdisk_browse.clicked.connect(lambda: self._browse_repack_file(self.boot_ramdisk_edit, "Ramdisk"))
            ramdisk_layout.addWidget(self.boot_ramdisk_browse)
            boot_layout.addLayout(ramdisk_layout)
            
            # DTB (v2)
            self.boot_dtb_widget = QWidget()
            dtb_layout = QHBoxLayout(self.boot_dtb_widget)
            dtb_layout.setContentsMargins(0, 0, 0, 0)
            dtb_layout.addWidget(QLabel("DTB:"))
            self.boot_dtb_edit = QLineEdit()
            self.boot_dtb_edit.setPlaceholderText("Path to DTB (optional)...")
            dtb_layout.addWidget(self.boot_dtb_edit, 1)
            self.boot_dtb_browse = QPushButton("Browse...")
            self.boot_dtb_browse.clicked.connect(lambda: self._browse_repack_file(self.boot_dtb_edit, "DTB"))
            dtb_layout.addWidget(self.boot_dtb_browse)
            boot_layout.addWidget(self.boot_dtb_widget)
            
            # Cmdline
            cmdline_layout = QHBoxLayout()
            cmdline_layout.addWidget(QLabel("Cmdline:"))
            self.boot_cmdline_edit = QLineEdit()
            self.boot_cmdline_edit.setPlaceholderText("Kernel command line (optional)...")
            cmdline_layout.addWidget(self.boot_cmdline_edit, 1)
            boot_layout.addLayout(cmdline_layout)
            
            # Page size
            page_layout = QHBoxLayout()
            page_layout.addWidget(QLabel("Page Size:"))
            self.boot_page_size = QComboBox()
            self.boot_page_size.addItems(["2048", "4096"])
            self.boot_page_size.setCurrentIndex(1)
            page_layout.addWidget(self.boot_page_size)
            page_layout.addStretch()
            boot_layout.addLayout(page_layout)
            
            boot_layout.addStretch()
            self.repack_stack_layout.addWidget(self.boot_repack_widget)
            
            # === Vendor Boot Options ===
            self.vendor_boot_widget = QWidget()
            vendor_layout = QVBoxLayout(self.vendor_boot_widget)
            
            # Version
            vb_ver_layout = QHBoxLayout()
            vb_ver_layout.addWidget(QLabel("Header Version:"))
            self.vb_version_combo = QComboBox()
            self.vb_version_combo.addItems(["v3", "v4"])
            vb_ver_layout.addWidget(self.vb_version_combo)
            vb_ver_layout.addStretch()
            vendor_layout.addLayout(vb_ver_layout)
            
            # Vendor Ramdisk
            vb_ramdisk_layout = QHBoxLayout()
            vb_ramdisk_layout.addWidget(QLabel("Vendor Ramdisk:"))
            self.vb_ramdisk_edit = QLineEdit()
            self.vb_ramdisk_edit.setPlaceholderText("Path to vendor ramdisk...")
            vb_ramdisk_layout.addWidget(self.vb_ramdisk_edit, 1)
            self.vb_ramdisk_browse = QPushButton("Browse...")
            self.vb_ramdisk_browse.clicked.connect(lambda: self._browse_repack_file(self.vb_ramdisk_edit, "Vendor Ramdisk"))
            vb_ramdisk_layout.addWidget(self.vb_ramdisk_browse)
            vendor_layout.addLayout(vb_ramdisk_layout)
            
            # DTB
            vb_dtb_layout = QHBoxLayout()
            vb_dtb_layout.addWidget(QLabel("DTB:"))
            self.vb_dtb_edit = QLineEdit()
            self.vb_dtb_edit.setPlaceholderText("Path to DTB...")
            vb_dtb_layout.addWidget(self.vb_dtb_edit, 1)
            self.vb_dtb_browse = QPushButton("Browse...")
            self.vb_dtb_browse.clicked.connect(lambda: self._browse_repack_file(self.vb_dtb_edit, "DTB"))
            vb_dtb_layout.addWidget(self.vb_dtb_browse)
            vendor_layout.addLayout(vb_dtb_layout)
            
            # Cmdline
            vb_cmdline_layout = QHBoxLayout()
            vb_cmdline_layout.addWidget(QLabel("Cmdline:"))
            self.vb_cmdline_edit = QLineEdit()
            self.vb_cmdline_edit.setPlaceholderText("Vendor kernel cmdline...")
            vb_cmdline_layout.addWidget(self.vb_cmdline_edit, 1)
            vendor_layout.addLayout(vb_cmdline_layout)
            
            vendor_layout.addStretch()
            self.vendor_boot_widget.setVisible(False)
            self.repack_stack_layout.addWidget(self.vendor_boot_widget)
            
            # === Sparse Image Options ===
            self.sparse_widget = QWidget()
            sparse_layout = QVBoxLayout(self.sparse_widget)
            
            sparse_info = QLabel(
                "Convert a raw image to Android sparse format.\n"
                "Sparse images are smaller and faster to flash."
            )
            sparse_info.setStyleSheet("color: #888; font-style: italic;")
            sparse_layout.addWidget(sparse_info)
            
            # Input raw image
            sparse_input_layout = QHBoxLayout()
            sparse_input_layout.addWidget(QLabel("Raw Image:"))
            self.sparse_input_edit = QLineEdit()
            self.sparse_input_edit.setPlaceholderText("Path to raw .img file...")
            sparse_input_layout.addWidget(self.sparse_input_edit, 1)
            self.sparse_input_browse = QPushButton("Browse...")
            self.sparse_input_browse.clicked.connect(lambda: self._browse_repack_file(self.sparse_input_edit, "Raw Image"))
            sparse_input_layout.addWidget(self.sparse_input_browse)
            sparse_layout.addLayout(sparse_input_layout)
            
            # Block size
            sparse_block_layout = QHBoxLayout()
            sparse_block_layout.addWidget(QLabel("Block Size:"))
            self.sparse_block_size = QComboBox()
            self.sparse_block_size.addItems(["4096", "2048", "1024"])
            sparse_block_layout.addWidget(self.sparse_block_size)
            sparse_block_layout.addStretch()
            sparse_layout.addLayout(sparse_block_layout)
            
            sparse_layout.addStretch()
            self.sparse_widget.setVisible(False)
            self.repack_stack_layout.addWidget(self.sparse_widget)
            
            # === vbmeta Options ===
            self.vbmeta_widget = QWidget()
            vbmeta_layout = QVBoxLayout(self.vbmeta_widget)
            
            vbmeta_info = QLabel(
                "Create an empty/disabled vbmeta image.\n"
                "This effectively disables Android Verified Boot."
            )
            vbmeta_info.setStyleSheet("color: #FFA500; font-style: italic;")
            vbmeta_layout.addWidget(vbmeta_info)
            
            # Flags
            self.vbmeta_disable_verity_create = QCheckBox("Disable dm-verity")
            self.vbmeta_disable_verity_create.setChecked(True)
            self.vbmeta_disable_verification_create = QCheckBox("Disable verification")
            self.vbmeta_disable_verification_create.setChecked(True)
            vbmeta_layout.addWidget(self.vbmeta_disable_verity_create)
            vbmeta_layout.addWidget(self.vbmeta_disable_verification_create)
            
            # Signing option
            self.vbmeta_sign_create = QCheckBox("Sign with custom key")
            self.vbmeta_sign_create.setEnabled(CRYPTO_AVAILABLE)
            if not CRYPTO_AVAILABLE:
                self.vbmeta_sign_create.setToolTip("cryptography library not installed")
            vbmeta_layout.addWidget(self.vbmeta_sign_create)
            
            vbmeta_layout.addStretch()
            self.vbmeta_widget.setVisible(False)
            self.repack_stack_layout.addWidget(self.vbmeta_widget)
            
            # === Ramdisk Options ===
            self.ramdisk_widget = QWidget()
            ramdisk_layout = QVBoxLayout(self.ramdisk_widget)
            
            ramdisk_info = QLabel(
                "Pack a directory into a ramdisk image (cpio + compression)."
            )
            ramdisk_info.setStyleSheet("color: #888; font-style: italic;")
            ramdisk_layout.addWidget(ramdisk_info)
            
            # Input directory
            rd_input_layout = QHBoxLayout()
            rd_input_layout.addWidget(QLabel("Input Directory:"))
            self.ramdisk_input_edit = QLineEdit()
            self.ramdisk_input_edit.setPlaceholderText("Path to directory to pack...")
            rd_input_layout.addWidget(self.ramdisk_input_edit, 1)
            self.ramdisk_input_browse = QPushButton("Browse...")
            self.ramdisk_input_browse.clicked.connect(self._browse_ramdisk_dir)
            rd_input_layout.addWidget(self.ramdisk_input_browse)
            ramdisk_layout.addLayout(rd_input_layout)
            
            # Compression
            rd_comp_layout = QHBoxLayout()
            rd_comp_layout.addWidget(QLabel("Compression:"))
            self.ramdisk_compression = QComboBox()
            self.ramdisk_compression.addItems(["gzip", "lz4", "none"])
            rd_comp_layout.addWidget(self.ramdisk_compression)
            rd_comp_layout.addStretch()
            ramdisk_layout.addLayout(rd_comp_layout)
            
            ramdisk_layout.addStretch()
            self.ramdisk_widget.setVisible(False)
            self.repack_stack_layout.addWidget(self.ramdisk_widget)
            
            # === Super Partition Options ===
            self.super_widget = QWidget()
            super_layout = QVBoxLayout(self.super_widget)
            
            super_info = QLabel(
                "🔥 Create a super.img (dynamic partition) from individual partition images.\n"
                "Add partitions like system, vendor, product, odm, etc."
            )
            super_info.setStyleSheet("color: #FF6B35; font-style: italic;")
            super_info.setWordWrap(True)
            super_layout.addWidget(super_info)
            
            # Partition list with add/remove
            super_parts_group = QGroupBox("Partitions")
            super_parts_layout = QVBoxLayout(super_parts_group)
            
            self.super_partitions_list = QListWidget()
            self.super_partitions_list.setAlternatingRowColors(True)
            self.super_partitions_list.setMinimumHeight(120)
            super_parts_layout.addWidget(self.super_partitions_list)
            
            super_part_btns = QHBoxLayout()
            self.super_add_part_btn = QPushButton("+ Add Partition")
            self.super_add_part_btn.clicked.connect(self._super_add_partition)
            self.super_remove_part_btn = QPushButton("- Remove")
            self.super_remove_part_btn.clicked.connect(self._super_remove_partition)
            self.super_scan_parts_btn = QPushButton("📁 Scan Directory")
            self.super_scan_parts_btn.clicked.connect(self._super_scan_directory)
            super_part_btns.addWidget(self.super_add_part_btn)
            super_part_btns.addWidget(self.super_remove_part_btn)
            super_part_btns.addWidget(self.super_scan_parts_btn)
            super_part_btns.addStretch()
            super_parts_layout.addLayout(super_part_btns)
            
            super_layout.addWidget(super_parts_group)
            
            # Group configuration
            super_group_layout = QHBoxLayout()
            super_group_layout.addWidget(QLabel("Partition Group:"))
            self.super_group_name = QLineEdit("qti_dynamic_partitions")
            self.super_group_name.setPlaceholderText("Group name (e.g., qti_dynamic_partitions)")
            super_group_layout.addWidget(self.super_group_name, 1)
            super_layout.addLayout(super_group_layout)
            
            # Size settings
            super_size_group = QGroupBox("Size Configuration")
            super_size_layout = QFormLayout(super_size_group)
            
            # Super size
            super_size_row = QHBoxLayout()
            self.super_size_spin = QSpinBox()
            self.super_size_spin.setRange(1, 32768)  # 1MB to 32GB
            self.super_size_spin.setValue(8192)  # Default 8GB
            self.super_size_spin.setSuffix(" MB")
            self.super_size_spin.setToolTip("Total size of super.img (0 = auto-calculate)")
            super_size_row.addWidget(self.super_size_spin)
            self.super_size_auto = QCheckBox("Auto-calculate")
            self.super_size_auto.setChecked(True)
            self.super_size_auto.toggled.connect(lambda checked: self.super_size_spin.setEnabled(not checked))
            self.super_size_spin.setEnabled(False)
            super_size_row.addWidget(self.super_size_auto)
            super_size_row.addStretch()
            super_size_layout.addRow("Super Size:", super_size_row)
            
            # Group max size
            group_size_row = QHBoxLayout()
            self.super_group_size_spin = QSpinBox()
            self.super_group_size_spin.setRange(1, 32768)
            self.super_group_size_spin.setValue(8000)  # Default ~8GB
            self.super_group_size_spin.setSuffix(" MB")
            self.super_group_size_spin.setToolTip("Maximum size for partition group (0 = auto)")
            group_size_row.addWidget(self.super_group_size_spin)
            self.super_group_size_auto = QCheckBox("Auto-calculate")
            self.super_group_size_auto.setChecked(True)
            self.super_group_size_auto.toggled.connect(lambda checked: self.super_group_size_spin.setEnabled(not checked))
            self.super_group_size_spin.setEnabled(False)
            group_size_row.addStretch()
            super_size_layout.addRow("Group Max Size:", group_size_row)
            
            # Metadata size
            metadata_row = QHBoxLayout()
            self.super_metadata_size = QComboBox()
            self.super_metadata_size.addItems(["65536 (64KB)", "131072 (128KB)", "262144 (256KB)"])
            self.super_metadata_size.setToolTip("Metadata region size")
            metadata_row.addWidget(self.super_metadata_size)
            metadata_row.addStretch()
            super_size_layout.addRow("Metadata Size:", metadata_row)
            
            super_layout.addWidget(super_size_group)
            
            # Options
            super_opts_layout = QHBoxLayout()
            self.super_sparse_check = QCheckBox("Output as sparse image")
            self.super_sparse_check.setToolTip("Create sparse super.img (smaller, faster to flash)")
            self.super_sparse_check.setChecked(True)
            self.super_readonly_check = QCheckBox("Read-only partitions")
            self.super_readonly_check.setToolTip("Mark all partitions as read-only")
            self.super_readonly_check.setChecked(True)
            super_opts_layout.addWidget(self.super_sparse_check)
            super_opts_layout.addWidget(self.super_readonly_check)
            super_opts_layout.addStretch()
            super_layout.addLayout(super_opts_layout)
            
            # Calculated size display
            self.super_calc_label = QLabel("Total partition size: 0 MB")
            self.super_calc_label.setStyleSheet("color: #888; font-size: 11px;")
            super_layout.addWidget(self.super_calc_label)
            
            super_layout.addStretch()
            self.super_widget.setVisible(False)
            self.repack_stack_layout.addWidget(self.super_widget)
            
            # === EROFS Image Options ===
            self.erofs_widget = QWidget()
            erofs_layout = QVBoxLayout(self.erofs_widget)
            
            erofs_info = QLabel(
                "🔥 Create an EROFS (Enhanced Read-Only File System) image from a directory.\n"
                "EROFS is used by modern Android devices for system/vendor/product partitions."
            )
            erofs_info.setStyleSheet("color: #FF6B35; font-style: italic;")
            erofs_info.setWordWrap(True)
            erofs_layout.addWidget(erofs_info)
            
            # Source directory
            erofs_src_layout = QHBoxLayout()
            erofs_src_layout.addWidget(QLabel("Source Directory:"))
            self.erofs_source_edit = QLineEdit()
            self.erofs_source_edit.setPlaceholderText("Directory containing files to pack...")
            erofs_src_layout.addWidget(self.erofs_source_edit, 1)
            self.erofs_source_browse = QPushButton("Browse...")
            self.erofs_source_browse.clicked.connect(self._browse_erofs_source)
            erofs_src_layout.addWidget(self.erofs_source_browse)
            erofs_layout.addLayout(erofs_src_layout)
            
            # Compression settings
            erofs_comp_group = QGroupBox("Compression")
            erofs_comp_layout = QFormLayout(erofs_comp_group)
            
            # Compression algorithm
            self.erofs_compression_combo = QComboBox()
            self.erofs_compression_combo.addItems(["lz4", "lz4hc", "lzma", "none"])
            self.erofs_compression_combo.setCurrentIndex(0)  # Default lz4
            self.erofs_compression_combo.setToolTip(
                "lz4: Fast compression (default)\n"
                "lz4hc: Higher compression, slower\n"
                "lzma: Best compression, slowest\n"
                "none: No compression"
            )
            erofs_comp_layout.addRow("Algorithm:", self.erofs_compression_combo)
            
            # Block size
            self.erofs_block_size_combo = QComboBox()
            self.erofs_block_size_combo.addItems(["4096", "2048", "1024", "512"])
            self.erofs_block_size_combo.setToolTip("Filesystem block size (4096 recommended)")
            erofs_comp_layout.addRow("Block Size:", self.erofs_block_size_combo)
            
            erofs_layout.addWidget(erofs_comp_group)
            
            # Advanced options
            erofs_adv_group = QGroupBox("Advanced Options")
            erofs_adv_layout = QVBoxLayout(erofs_adv_group)
            
            # Volume name
            erofs_vol_layout = QHBoxLayout()
            erofs_vol_layout.addWidget(QLabel("Volume Name:"))
            self.erofs_volume_name = QLineEdit()
            self.erofs_volume_name.setPlaceholderText("Optional (max 16 chars)")
            self.erofs_volume_name.setMaxLength(16)
            erofs_vol_layout.addWidget(self.erofs_volume_name, 1)
            erofs_adv_layout.addLayout(erofs_vol_layout)
            
            # Feature checkboxes
            erofs_feat_layout = QHBoxLayout()
            self.erofs_dedupe_check = QCheckBox("Deduplication")
            self.erofs_dedupe_check.setToolTip("Enable data deduplication (reduces size)")
            self.erofs_fragments_check = QCheckBox("Fragments")
            self.erofs_fragments_check.setToolTip("Pack small files as fragments (reduces size)")
            self.erofs_ztailpacking_check = QCheckBox("Tail Packing")
            self.erofs_ztailpacking_check.setToolTip("Inline tail data of compressed files")
            erofs_feat_layout.addWidget(self.erofs_dedupe_check)
            erofs_feat_layout.addWidget(self.erofs_fragments_check)
            erofs_feat_layout.addWidget(self.erofs_ztailpacking_check)
            erofs_feat_layout.addStretch()
            erofs_adv_layout.addLayout(erofs_feat_layout)
            
            erofs_layout.addWidget(erofs_adv_group)
            
            # Tool availability check
            self.erofs_tool_label = QLabel()
            self._check_erofs_tool_availability()
            erofs_layout.addWidget(self.erofs_tool_label)
            
            erofs_layout.addStretch()
            self.erofs_widget.setVisible(False)
            self.repack_stack_layout.addWidget(self.erofs_widget)
            
            repack_img_layout.addWidget(self.repack_stack)
            
            # Output section
            repack_output_group = QGroupBox("Output")
            repack_output_layout = QHBoxLayout(repack_output_group)
            repack_output_layout.addWidget(QLabel("Save to:"))
            self.repack_img_output_edit = QLineEdit()
            self.repack_img_output_edit.setPlaceholderText("Output file path...")
            repack_output_layout.addWidget(self.repack_img_output_edit, 1)
            self.repack_img_output_browse = QPushButton("Browse...")
            self.repack_img_output_browse.clicked.connect(self._browse_repack_output_file)
            repack_output_layout.addWidget(self.repack_img_output_browse)
            repack_img_layout.addWidget(repack_output_group)
            
            # Log
            repack_log_group = QGroupBox("Log")
            repack_log_layout = QVBoxLayout(repack_log_group)
            self.repack_img_log = QTextEdit()
            self.repack_img_log.setReadOnly(True)
            self.repack_img_log.setFont(QFont("Consolas", 9))
            self.repack_img_log.setMaximumHeight(200)
            repack_log_layout.addWidget(self.repack_img_log)
            repack_img_layout.addWidget(repack_log_group, 1)
            
            # Progress and actions
            repack_progress_layout = QHBoxLayout()
            self.repack_img_progress = QProgressBar()
            self.repack_img_progress.setMinimumHeight(24)
            self.repack_img_progress_label = QLabel("Ready")
            repack_progress_layout.addWidget(self.repack_img_progress, 1)
            repack_progress_layout.addWidget(self.repack_img_progress_label)
            repack_img_layout.addLayout(repack_progress_layout)
            
            repack_action_layout = QHBoxLayout()
            repack_action_layout.addStretch()
            self.repack_img_btn = QPushButton("Create Image")
            self.repack_img_btn.setProperty("primary", True)
            self.repack_img_btn.setMinimumWidth(150)
            self.repack_img_btn.clicked.connect(self._start_image_repack)
            repack_action_layout.addWidget(self.repack_img_btn)
            repack_img_layout.addLayout(repack_action_layout)
            
            # Finalize scroll area
            repack_scroll.setWidget(repack_scroll_content)
            repack_img_outer_layout.addWidget(repack_scroll)
            
            self.tab_widget.addTab(repack_img_tab, "🔨 Image Repack")
            
            # =============================================================
            # TAB 5: RECOVERY PORTER
            # =============================================================
            recovery_tab = QWidget()
            recovery_layout = QVBoxLayout(recovery_tab)
            
            # Info banner
            recovery_info = QLabel(
                "🔧 Recovery Porter - Port custom recoveries (TWRP, OrangeFox) between devices\n"
                "Load a recovery.img to analyze, modify, swap kernel, edit fstab, and repack."
            )
            recovery_info.setStyleSheet("color: #FFA500; padding: 10px; background-color: #2d2d2d; border-radius: 4px;")
            recovery_info.setWordWrap(True)
            recovery_layout.addWidget(recovery_info)
            
            # Splitter for left/right panels
            recovery_splitter = QSplitter(Qt.Orientation.Horizontal)
            
            # Left panel - Source and components
            recovery_left = QWidget()
            recovery_left_layout = QVBoxLayout(recovery_left)
            recovery_left_layout.setContentsMargins(0, 0, 0, 0)
            
            # Source recovery
            source_group = QGroupBox("Source Recovery")
            source_layout = QVBoxLayout(source_group)
            
            source_input_layout = QHBoxLayout()
            self.recovery_source_edit = QLineEdit()
            self.recovery_source_edit.setPlaceholderText("Path to recovery.img...")
            source_input_layout.addWidget(self.recovery_source_edit, 1)
            self.recovery_browse_btn = QPushButton("Browse...")
            self.recovery_browse_btn.clicked.connect(self._browse_recovery_source)
            source_input_layout.addWidget(self.recovery_browse_btn)
            source_layout.addLayout(source_input_layout)
            
            self.recovery_analyze_btn = QPushButton("Analyze Recovery")
            self.recovery_analyze_btn.clicked.connect(self._analyze_recovery)
            source_layout.addWidget(self.recovery_analyze_btn)
            
            recovery_left_layout.addWidget(source_group)
            
            # Recovery info display
            info_group = QGroupBox("Recovery Information")
            info_layout = QVBoxLayout(info_group)
            
            self.recovery_info_tree = QTreeWidget()
            self.recovery_info_tree.setHeaderLabels(["Property", "Value"])
            self.recovery_info_tree.setAlternatingRowColors(True)
            info_layout.addWidget(self.recovery_info_tree)
            
            recovery_left_layout.addWidget(info_group, 1)
            
            # Component modifications
            mods_group = QGroupBox("Modifications")
            mods_layout = QVBoxLayout(mods_group)
            
            # Kernel swap
            kernel_layout = QHBoxLayout()
            kernel_layout.addWidget(QLabel("Replace Kernel:"))
            self.recovery_kernel_edit = QLineEdit()
            self.recovery_kernel_edit.setPlaceholderText("Leave empty to keep original...")
            kernel_layout.addWidget(self.recovery_kernel_edit, 1)
            self.recovery_kernel_browse = QPushButton("...")
            self.recovery_kernel_browse.setMaximumWidth(30)
            self.recovery_kernel_browse.clicked.connect(self._browse_recovery_kernel)
            kernel_layout.addWidget(self.recovery_kernel_browse)
            mods_layout.addLayout(kernel_layout)
            
            # DTB swap
            dtb_layout = QHBoxLayout()
            dtb_layout.addWidget(QLabel("Replace DTB:"))
            self.recovery_dtb_edit = QLineEdit()
            self.recovery_dtb_edit.setPlaceholderText("Leave empty to keep original...")
            dtb_layout.addWidget(self.recovery_dtb_edit, 1)
            self.recovery_dtb_browse = QPushButton("...")
            self.recovery_dtb_browse.setMaximumWidth(30)
            self.recovery_dtb_browse.clicked.connect(self._browse_recovery_dtb)
            dtb_layout.addWidget(self.recovery_dtb_browse)
            mods_layout.addLayout(dtb_layout)
            
            # Cmdline
            cmdline_layout = QHBoxLayout()
            cmdline_layout.addWidget(QLabel("Cmdline:"))
            self.recovery_cmdline_edit = QLineEdit()
            self.recovery_cmdline_edit.setPlaceholderText("Kernel command line...")
            cmdline_layout.addWidget(self.recovery_cmdline_edit, 1)
            mods_layout.addLayout(cmdline_layout)
            
            recovery_left_layout.addWidget(mods_group)
            
            recovery_splitter.addWidget(recovery_left)
            
            # Right panel - Ramdisk contents
            recovery_right = QWidget()
            recovery_right_layout = QVBoxLayout(recovery_right)
            recovery_right_layout.setContentsMargins(0, 0, 0, 0)
            
            ramdisk_group = QGroupBox("Ramdisk Contents")
            ramdisk_layout = QVBoxLayout(ramdisk_group)
            
            self.ramdisk_tree = QTreeWidget()
            self.ramdisk_tree.setHeaderLabels(["Name", "Size", "Type"])
            self.ramdisk_tree.setAlternatingRowColors(True)
            self.ramdisk_tree.itemDoubleClicked.connect(self._on_ramdisk_item_double_click)
            ramdisk_layout.addWidget(self.ramdisk_tree)
            
            # Ramdisk actions
            ramdisk_btn_layout = QHBoxLayout()
            self.ramdisk_extract_btn = QPushButton("Extract All")
            self.ramdisk_extract_btn.clicked.connect(self._extract_ramdisk)
            self.ramdisk_extract_btn.setEnabled(False)
            ramdisk_btn_layout.addWidget(self.ramdisk_extract_btn)
            
            self.ramdisk_edit_fstab_btn = QPushButton("Edit fstab")
            self.ramdisk_edit_fstab_btn.clicked.connect(self._edit_fstab)
            self.ramdisk_edit_fstab_btn.setEnabled(False)
            ramdisk_btn_layout.addWidget(self.ramdisk_edit_fstab_btn)
            
            ramdisk_btn_layout.addStretch()
            ramdisk_layout.addLayout(ramdisk_btn_layout)
            
            recovery_right_layout.addWidget(ramdisk_group, 1)
            
            # Log
            recovery_log_group = QGroupBox("Log")
            recovery_log_layout = QVBoxLayout(recovery_log_group)
            self.recovery_log = QTextEdit()
            self.recovery_log.setReadOnly(True)
            self.recovery_log.setFont(QFont("Consolas", 9))
            self.recovery_log.setMaximumHeight(150)
            recovery_log_layout.addWidget(self.recovery_log)
            recovery_right_layout.addWidget(recovery_log_group)
            
            recovery_splitter.addWidget(recovery_right)
            recovery_splitter.setSizes([400, 400])
            
            recovery_layout.addWidget(recovery_splitter, 1)
            
            # Output and actions
            recovery_output_layout = QHBoxLayout()
            recovery_output_layout.addWidget(QLabel("Output:"))
            self.recovery_output_edit = QLineEdit()
            self.recovery_output_edit.setPlaceholderText("Path for new recovery.img...")
            recovery_output_layout.addWidget(self.recovery_output_edit, 1)
            self.recovery_output_browse = QPushButton("Browse...")
            self.recovery_output_browse.clicked.connect(self._browse_recovery_output)
            recovery_output_layout.addWidget(self.recovery_output_browse)
            recovery_layout.addLayout(recovery_output_layout)
            
            # Progress and build button
            recovery_action_layout = QHBoxLayout()
            self.recovery_progress = QProgressBar()
            self.recovery_progress.setMaximumWidth(200)
            recovery_action_layout.addWidget(self.recovery_progress)
            recovery_action_layout.addStretch()
            
            self.recovery_build_btn = QPushButton("Build Recovery")
            self.recovery_build_btn.setProperty("primary", True)
            self.recovery_build_btn.setMinimumWidth(150)
            self.recovery_build_btn.clicked.connect(self._build_recovery)
            self.recovery_build_btn.setEnabled(False)
            recovery_action_layout.addWidget(self.recovery_build_btn)
            recovery_layout.addLayout(recovery_action_layout)
            
            self.tab_widget.addTab(recovery_tab, "🔄 Recovery Porter")
            
            # =============================================================
            # TAB 6: ALLWINNER TOOLKIT
            # =============================================================
            allwinner_tab = QWidget()
            allwinner_layout = QVBoxLayout(allwinner_tab)
            allwinner_layout.setSpacing(12)
            allwinner_layout.setContentsMargins(8, 12, 8, 8)
            
            # Info banner
            aw_info = QLabel(
                "🌞 <b>Allwinner Firmware Tools</b> - Unpack/repack LiveSuit & PhoenixSuit firmware images<br>"
                "<small>Supports: SC8600/9800, Boxchip F10-F20, Allwinner A10-A80, F1C100, A133</small>"
            )
            aw_info.setStyleSheet("padding: 10px; background: #1a3a1a; border-radius: 5px;")
            allwinner_layout.addWidget(aw_info)
            
            # Input firmware
            aw_input_group = QGroupBox("Firmware Image")
            aw_input_layout = QVBoxLayout(aw_input_group)
            
            aw_path_layout = QHBoxLayout()
            aw_path_layout.addWidget(QLabel("Firmware:"))
            self.aw_firmware_path = DropLineEdit()
            self.aw_firmware_path.setPlaceholderText("Select Allwinner firmware .img file...")
            aw_path_layout.addWidget(self.aw_firmware_path, 1)
            self.aw_browse_btn = QPushButton("Browse...")
            self.aw_browse_btn.clicked.connect(self._browse_allwinner_firmware)
            aw_path_layout.addWidget(self.aw_browse_btn)
            aw_input_layout.addLayout(aw_path_layout)
            allwinner_layout.addWidget(aw_input_group)
            
            # Output directory
            aw_output_group = QGroupBox("Output Directory")
            aw_output_layout = QHBoxLayout(aw_output_group)
            aw_output_layout.addWidget(QLabel("Output:"))
            self.aw_output_path = QLineEdit()
            self.aw_output_path.setPlaceholderText("Output directory (auto-generated if empty)")
            aw_output_layout.addWidget(self.aw_output_path, 1)
            self.aw_output_browse_btn = QPushButton("Browse...")
            self.aw_output_browse_btn.clicked.connect(self._browse_allwinner_output)
            aw_output_layout.addWidget(self.aw_output_browse_btn)
            allwinner_layout.addWidget(aw_output_group)
            
            # Options
            aw_options_group = QGroupBox("Options")
            aw_options_layout = QVBoxLayout(aw_options_group)
            
            aw_opts_row1 = QHBoxLayout()
            self.aw_2nd_layer_cb = QCheckBox("Process 2nd layer files (boot images, ramdisks)")
            self.aw_2nd_layer_cb.setChecked(True)
            aw_opts_row1.addWidget(self.aw_2nd_layer_cb)
            self.aw_noiso_cb = QCheckBox("Skip filesystem images")
            aw_opts_row1.addWidget(self.aw_noiso_cb)
            aw_opts_row1.addStretch()
            aw_options_layout.addLayout(aw_opts_row1)
            
            allwinner_layout.addWidget(aw_options_group)
            
            # Log output
            aw_log_group = QGroupBox("Log")
            aw_log_layout = QVBoxLayout(aw_log_group)
            self.aw_log = QPlainTextEdit()
            self.aw_log.setReadOnly(True)
            self.aw_log.setStyleSheet("font-family: Consolas; background: #0d0d0d;")
            self.aw_log.setMinimumHeight(200)
            aw_log_layout.addWidget(self.aw_log)
            allwinner_layout.addWidget(aw_log_group, 1)
            
            # Progress
            self.aw_progress = QProgressBar()
            self.aw_progress.setVisible(False)
            allwinner_layout.addWidget(self.aw_progress)
            
            # Action buttons
            aw_action_layout = QHBoxLayout()
            aw_action_layout.addStretch()
            
            self.aw_unpack_btn = QPushButton("📦 Unpack Firmware")
            self.aw_unpack_btn.setProperty("primary", True)
            self.aw_unpack_btn.setMinimumWidth(150)
            self.aw_unpack_btn.clicked.connect(self._allwinner_unpack)
            aw_action_layout.addWidget(self.aw_unpack_btn)
            
            self.aw_repack_btn = QPushButton("🔧 Repack Firmware")
            self.aw_repack_btn.setMinimumWidth(150)
            self.aw_repack_btn.clicked.connect(self._allwinner_repack)
            aw_action_layout.addWidget(self.aw_repack_btn)
            
            allwinner_layout.addLayout(aw_action_layout)
            
            self.tab_widget.addTab(allwinner_tab, "🌞 Allwinner")
            
            # =============================================================
            # TAB 7: ROCKCHIP TOOLKIT
            # =============================================================
            rockchip_tab = QWidget()
            rockchip_layout = QVBoxLayout(rockchip_tab)
            rockchip_layout.setSpacing(12)
            rockchip_layout.setContentsMargins(8, 12, 8, 8)
            
            # Info banner
            rk_info = QLabel(
                "🪨 <b>Rockchip Firmware Tools</b> - Unpack/repack RKFW & RKAF firmware images<br>"
                "<small>Supports: RK28xx, RK29xx, RK30xx, RK31xx, RK32xx, RK33xx</small>"
            )
            rk_info.setStyleSheet("padding: 10px; background: #1a2a3a; border-radius: 5px;")
            rockchip_layout.addWidget(rk_info)
            
            # Input firmware
            rk_input_group = QGroupBox("Firmware Image")
            rk_input_layout = QVBoxLayout(rk_input_group)
            
            rk_path_layout = QHBoxLayout()
            rk_path_layout.addWidget(QLabel("Firmware:"))
            self.rk_firmware_path = DropLineEdit()
            self.rk_firmware_path.setPlaceholderText("Select Rockchip firmware .img file...")
            rk_path_layout.addWidget(self.rk_firmware_path, 1)
            self.rk_browse_btn = QPushButton("Browse...")
            self.rk_browse_btn.clicked.connect(self._browse_rockchip_firmware)
            rk_path_layout.addWidget(self.rk_browse_btn)
            rk_input_layout.addLayout(rk_path_layout)
            rockchip_layout.addWidget(rk_input_group)
            
            # Output directory
            rk_output_group = QGroupBox("Output Directory")
            rk_output_layout = QHBoxLayout(rk_output_group)
            rk_output_layout.addWidget(QLabel("Output:"))
            self.rk_output_path = QLineEdit()
            self.rk_output_path.setPlaceholderText("Output directory (auto-generated if empty)")
            rk_output_layout.addWidget(self.rk_output_path, 1)
            self.rk_output_browse_btn = QPushButton("Browse...")
            self.rk_output_browse_btn.clicked.connect(self._browse_rockchip_output)
            rk_output_layout.addWidget(self.rk_output_browse_btn)
            rockchip_layout.addWidget(rk_output_group)
            
            # Options
            rk_options_group = QGroupBox("Options")
            rk_options_layout = QVBoxLayout(rk_options_group)
            
            rk_opts_row1 = QHBoxLayout()
            self.rk_2nd_layer_cb = QCheckBox("Process 2nd layer files (boot images, bootloaders)")
            self.rk_2nd_layer_cb.setChecked(True)
            rk_opts_row1.addWidget(self.rk_2nd_layer_cb)
            self.rk_rkaf_cb = QCheckBox("Create RKAF image (instead of RKFW)")
            rk_opts_row1.addWidget(self.rk_rkaf_cb)
            rk_opts_row1.addStretch()
            rk_options_layout.addLayout(rk_opts_row1)
            
            rk_opts_row2 = QHBoxLayout()
            self.rk_fix_crc_cb = QCheckBox("Fix MD5/CRC checksums")
            self.rk_fix_crc_cb.setChecked(True)
            rk_opts_row2.addWidget(self.rk_fix_crc_cb)
            self.rk_skip_cid_cb = QCheckBox("Skip ChipID verification")
            rk_opts_row2.addWidget(self.rk_skip_cid_cb)
            rk_opts_row2.addStretch()
            rk_options_layout.addLayout(rk_opts_row2)
            
            rockchip_layout.addWidget(rk_options_group)
            
            # Log output
            rk_log_group = QGroupBox("Log")
            rk_log_layout = QVBoxLayout(rk_log_group)
            self.rk_log = QPlainTextEdit()
            self.rk_log.setReadOnly(True)
            self.rk_log.setStyleSheet("font-family: Consolas; background: #0d0d0d;")
            self.rk_log.setMinimumHeight(200)
            rk_log_layout.addWidget(self.rk_log)
            rockchip_layout.addWidget(rk_log_group, 1)
            
            # Progress
            self.rk_progress = QProgressBar()
            self.rk_progress.setVisible(False)
            rockchip_layout.addWidget(self.rk_progress)
            
            # Action buttons
            rk_action_layout = QHBoxLayout()
            rk_action_layout.addStretch()
            
            self.rk_unpack_btn = QPushButton("📦 Unpack Firmware")
            self.rk_unpack_btn.setProperty("primary", True)
            self.rk_unpack_btn.setMinimumWidth(150)
            self.rk_unpack_btn.clicked.connect(self._rockchip_unpack)
            rk_action_layout.addWidget(self.rk_unpack_btn)
            
            self.rk_repack_btn = QPushButton("🔧 Repack Firmware")
            self.rk_repack_btn.setMinimumWidth(150)
            self.rk_repack_btn.clicked.connect(self._rockchip_repack)
            rk_action_layout.addWidget(self.rk_repack_btn)
            
            rockchip_layout.addLayout(rk_action_layout)
            
            self.tab_widget.addTab(rockchip_tab, "🪨 Rockchip")
            
            # =====================================================================
            # TAB 8: OPPO / OnePlus / Realme Firmware Decryption
            # =====================================================================
            oppo_tab = QWidget()
            oppo_layout = QVBoxLayout(oppo_tab)
            oppo_layout.setSpacing(10)
            
            # Header
            oppo_header = QLabel("📱 OPPO / OnePlus / Realme Firmware Decrypter")
            oppo_header.setStyleSheet("font-size: 16px; font-weight: bold; color: #4fc3f7; padding: 10px;")
            oppo_layout.addWidget(oppo_header)
            
            oppo_desc = QLabel(
                "Decrypt encrypted firmware files from OPPO, OnePlus, and Realme devices.\n"
                "Supports .ofp (OPPO/Realme Qualcomm & MTK) and .ops (OnePlus) formats.\n"
                "Based on bkerler's oppo_decrypt tool."
            )
            oppo_desc.setStyleSheet("color: #888; padding: 5px;")
            oppo_layout.addWidget(oppo_desc)
            
            # Firmware selection
            oppo_file_group = QGroupBox("Firmware File")
            oppo_file_layout = QVBoxLayout(oppo_file_group)
            
            oppo_path_layout = QHBoxLayout()
            self.oppo_firmware_path = QLineEdit()
            self.oppo_firmware_path.setPlaceholderText("Select .ofp (OPPO/Realme) or .ops (OnePlus) firmware file...")
            oppo_path_layout.addWidget(self.oppo_firmware_path)
            
            oppo_browse_btn = QPushButton("Browse...")
            oppo_browse_btn.clicked.connect(self._browse_oppo_firmware)
            oppo_path_layout.addWidget(oppo_browse_btn)
            oppo_file_layout.addLayout(oppo_path_layout)
            
            # Firmware type indicator
            self.oppo_firmware_type = QLabel("No file selected")
            self.oppo_firmware_type.setStyleSheet("color: #888; font-style: italic;")
            oppo_file_layout.addWidget(self.oppo_firmware_type)
            
            oppo_layout.addWidget(oppo_file_group)
            
            # Output directory
            oppo_output_group = QGroupBox("Output Directory")
            oppo_output_layout = QHBoxLayout(oppo_output_group)
            
            self.oppo_output_path = QLineEdit()
            self.oppo_output_path.setPlaceholderText("Leave empty to use firmware directory...")
            oppo_output_layout.addWidget(self.oppo_output_path)
            
            oppo_output_btn = QPushButton("Browse...")
            oppo_output_btn.clicked.connect(self._browse_oppo_output)
            oppo_output_layout.addWidget(oppo_output_btn)
            
            oppo_layout.addWidget(oppo_output_group)
            
            # Options
            oppo_options_group = QGroupBox("Options")
            oppo_options_layout = QVBoxLayout(oppo_options_group)
            
            oppo_opts_row1 = QHBoxLayout()
            self.oppo_auto_detect_cb = QCheckBox("Auto-detect firmware type (QC/MTK)")
            self.oppo_auto_detect_cb.setChecked(True)
            oppo_opts_row1.addWidget(self.oppo_auto_detect_cb)
            oppo_opts_row1.addStretch()
            oppo_options_layout.addLayout(oppo_opts_row1)
            
            oppo_layout.addWidget(oppo_options_group)
            
            # Log output
            oppo_log_group = QGroupBox("Decryption Log")
            oppo_log_layout = QVBoxLayout(oppo_log_group)
            self.oppo_log = QPlainTextEdit()
            self.oppo_log.setReadOnly(True)
            self.oppo_log.setStyleSheet("font-family: Consolas; background: #0d0d0d;")
            self.oppo_log.setMinimumHeight(200)
            oppo_log_layout.addWidget(self.oppo_log)
            oppo_layout.addWidget(oppo_log_group, 1)
            
            # Progress
            self.oppo_progress = QProgressBar()
            self.oppo_progress.setVisible(False)
            oppo_layout.addWidget(self.oppo_progress)
            
            # Action buttons
            oppo_action_layout = QHBoxLayout()
            oppo_action_layout.addStretch()
            
            self.oppo_decrypt_btn = QPushButton("🔓 Decrypt Firmware")
            self.oppo_decrypt_btn.setProperty("primary", True)
            self.oppo_decrypt_btn.setMinimumWidth(200)
            self.oppo_decrypt_btn.clicked.connect(self._oppo_decrypt)
            oppo_action_layout.addWidget(self.oppo_decrypt_btn)
            
            oppo_layout.addLayout(oppo_action_layout)
            
            self.tab_widget.addTab(oppo_tab, "📱 OPPO/OnePlus")
            
            main_layout.addWidget(self.tab_widget)
            
            # Status bar
            self.status_bar = QStatusBar()
            self.setStatusBar(self.status_bar)
            self.status_bar.showMessage("Ready - Ⓐ Image Anarchy | Extract, create, and manipulate Android images")
        
        def _apply_styles(self):
            self.setStyleSheet(self.STYLESHEET + """
                QTabWidget::pane {
                    border: 1px solid #3c3c3c;
                    border-radius: 4px;
                    background-color: #1e1e1e;
                }
                QTabBar::tab {
                    background-color: #2d2d2d;
                    color: #d4d4d4;
                    padding: 10px 20px;
                    border: 1px solid #3c3c3c;
                    border-bottom: none;
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                }
                QTabBar::tab:selected {
                    background-color: #1e1e1e;
                    border-bottom: 1px solid #1e1e1e;
                }
                QTabBar::tab:hover:!selected {
                    background-color: #3c3c3c;
                }
                QComboBox {
                    padding: 6px 12px;
                    border: 1px solid #3c3c3c;
                    border-radius: 4px;
                    background-color: #2d2d2d;
                    min-width: 80px;
                }
                QComboBox::drop-down {
                    border: none;
                    width: 20px;
                }
                QComboBox::down-arrow {
                    image: none;
                    border-left: 5px solid transparent;
                    border-right: 5px solid transparent;
                    border-top: 5px solid #d4d4d4;
                    margin-right: 5px;
                }
                QSpinBox {
                    padding: 6px;
                    border: 1px solid #3c3c3c;
                    border-radius: 4px;
                    background-color: #2d2d2d;
                    min-width: 60px;
                }
            """)
            self.load_btn.style().polish(self.load_btn)
            self.extract_btn.style().polish(self.extract_btn)
            self.repack_scan_btn.style().polish(self.repack_scan_btn)
            self.repack_btn.style().polish(self.repack_btn)
            self.image_analyze_btn.style().polish(self.image_analyze_btn)
            self.image_extract_btn.style().polish(self.image_extract_btn)
        
        def _log(self, message: str):
            self.log_output.append(message)
            scrollbar = self.log_output.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())
        
        def _repack_log(self, message: str):
            self.repack_log_output.append(message)
            scrollbar = self.repack_log_output.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())
        
        def _browse_payload(self):
            path, _ = QFileDialog.getOpenFileName(
                self, "Select Payload File", "",
                "Payload Files (*.bin *.zip);;All Files (*.*)"
            )
            if path:
                self.path_input.setText(path)
        
        def _browse_output(self):
            path = QFileDialog.getExistingDirectory(self, "Select Output Directory")
            if path:
                self.output_input.setText(path)
        
        def _browse_old_dir(self):
            path = QFileDialog.getExistingDirectory(self, "Select Original Images Directory")
            if path:
                self.old_dir_input.setText(path)
        
        def _toggle_diff(self, checked: bool):
            self.old_dir_label.setVisible(checked)
            self.old_dir_input.setVisible(checked)
            self.old_dir_browse_btn.setVisible(checked)
        
        def _load_payload(self):
            path = self.path_input.text().strip()
            if not path:
                QMessageBox.warning(self, "Error", "Please enter a payload file path or URL")
                return
            
            self.partitions_list.clear()
            self.partitions = []
            self.extract_btn.setEnabled(False)
            self.load_btn.setEnabled(False)
            self.progress_bar.setRange(0, 0)
            
            self.analyzer_thread = PayloadAnalyzerThread(path)
            self.analyzer_thread.finished.connect(self._on_payload_loaded)
            self.analyzer_thread.error.connect(self._on_load_error)
            self.analyzer_thread.status.connect(self.status_bar.showMessage)
            self.analyzer_thread.start()
        
        def _on_payload_loaded(self, partitions: list[PartitionDisplayInfo]):
            self.partitions = partitions
            self.progress_bar.setRange(0, 100)
            self.progress_bar.setValue(0)
            self.load_btn.setEnabled(True)
            
            self._log(f"Loaded payload with {len(partitions)} partitions:")
            
            for part in partitions:
                size_mb = part.size / (1024 * 1024)
                item = QListWidgetItem(f"{part.name}  ({size_mb:.1f} MB)")
                item.setData(Qt.ItemDataRole.UserRole, part.name)
                self.partitions_list.addItem(item)
                self._log(f"  • {part.name}: {size_mb:.1f} MB ({part.operations_count} operations)")
            
            self._select_all()
            self.extract_btn.setEnabled(True)
            self.status_bar.showMessage(f"Loaded {len(partitions)} partitions")
            self._show_toast(f"⚡ {len(partitions)} partitions ready for liberation!", 'success')
        
        def _on_load_error(self, error: str):
            self.progress_bar.setRange(0, 100)
            self.progress_bar.setValue(0)
            self.load_btn.setEnabled(True)
            self._log(f"Error: {error}")
            self.status_bar.showMessage("Error loading payload")
            self._show_toast("💀 Failed to crack the payload!", 'error')
            QMessageBox.critical(self, "Error", f"Failed to load payload:\n{error}")
        
        def _select_all(self):
            for i in range(self.partitions_list.count()):
                self.partitions_list.item(i).setSelected(True)
        
        def _select_none(self):
            for i in range(self.partitions_list.count()):
                self.partitions_list.item(i).setSelected(False)
        
        def _get_selected_partitions(self) -> list[str]:
            return [
                item.data(Qt.ItemDataRole.UserRole) 
                for item in self.partitions_list.selectedItems()
            ]
        
        def _start_extraction(self):
            selected = self._get_selected_partitions()
            if not selected:
                QMessageBox.warning(self, "Error", "Please select at least one partition")
                return
            
            output_dir = self.output_input.text().strip()
            if not output_dir:
                QMessageBox.warning(self, "Error", "Please specify an output directory")
                return
            
            old_dir = None
            if self.diff_checkbox.isChecked():
                old_dir = self.old_dir_input.text().strip()
                if not old_dir:
                    QMessageBox.warning(self, "Error", "Please specify the original images directory")
                    return
            
            self._set_extraction_mode(True)
            self.log_output.clear()
            self._log(f"Starting extraction of {len(selected)} partition(s)...\n")
            
            # Check if super extraction is requested
            extract_super = self.extract_super_checkbox.isChecked() and 'super' in selected
            if extract_super:
                self._log("Super partition contents will be extracted automatically.\n")
            
            self.extraction_thread = ExtractionThread(
                self.path_input.text().strip(),
                output_dir,
                selected,
                old_dir,
                extract_super
            )
            self.extraction_thread.progress.connect(self._on_progress)
            self.extraction_thread.partition_started.connect(
                lambda name: self.status_bar.showMessage(f"Extracting {name}...")
            )
            self.extraction_thread.log.connect(self._log)
            self.extraction_thread.error.connect(self._on_extraction_error)
            self.extraction_thread.finished.connect(self._on_extraction_finished)
            self.extraction_thread.start()
        
        def _set_extraction_mode(self, extracting: bool):
            self.extract_btn.setEnabled(not extracting)
            self.extract_btn.setVisible(not extracting)
            self.cancel_btn.setEnabled(extracting)
            self.cancel_btn.setVisible(extracting)
            self.load_btn.setEnabled(not extracting)
            self.path_input.setEnabled(not extracting)
            self.browse_btn.setEnabled(not extracting)
            self.partitions_list.setEnabled(not extracting)
        
        def _cancel_extraction(self):
            if self.extraction_thread:
                self.extraction_thread.cancel()
                self._log("\nCancelling extraction...")
        
        def _on_progress(self, current: int, total: int):
            self.progress_bar.setRange(0, total)
            self.progress_bar.setValue(current)
            self.progress_label.setText(f"{current}/{total}")
        
        def _on_extraction_error(self, error: str):
            self._set_extraction_mode(False)
            self._log(f"\nError: {error}")
            self.status_bar.showMessage("Extraction failed")
            self._show_toast(f"💀 Extraction failed! The system fought back.", 'error')
            QMessageBox.critical(self, "Error", f"Extraction failed:\n{error}")
        
        def _on_extraction_finished(self):
            self._set_extraction_mode(False)
            self.progress_bar.setValue(self.progress_bar.maximum())
            self.progress_label.setText("Complete")
            self.status_bar.showMessage("Extraction complete!")
            
            # Anarchy toast and tray notification
            self._show_toast("🔥 Extraction complete! Partitions liberated!", 'success')
            self._show_tray_notification("Image Anarchy", "💣 Extraction complete! The system has been dismantled.", 'info')
            
            result = QMessageBox.question(
                self, "Extraction Complete",
                "All partitions extracted successfully!\n\nOpen output directory?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if result == QMessageBox.StandardButton.Yes:
                output_dir = self.output_input.text().strip()
                if sys.platform == 'win32':
                    os.startfile(output_dir)
                elif sys.platform == 'darwin':
                    os.system(f'open "{output_dir}"')
                else:
                    os.system(f'xdg-open "{output_dir}"')
        
        # =================== REPACK METHODS ===================
        
        def _browse_repack_input(self):
            path = QFileDialog.getExistingDirectory(self, "Select Images Directory")
            if path:
                self.repack_input_dir.setText(path)
        
        def _browse_repack_output(self):
            path, _ = QFileDialog.getSaveFileName(
                self, "Save Payload File", "payload.bin",
                "Payload Files (*.bin);;All Files (*.*)"
            )
            if path:
                self.repack_output_path.setText(path)
        
        def _scan_images(self):
            input_dir = self.repack_input_dir.text().strip()
            if not input_dir:
                QMessageBox.warning(self, "Error", "Please specify an images directory")
                return
            
            input_path = Path(input_dir)
            if not input_path.exists():
                QMessageBox.warning(self, "Error", f"Directory not found: {input_dir}")
                return
            
            self.repack_images_list.clear()
            self.repack_images = []
            
            image_files = sorted(input_path.glob("*.img"))
            
            if not image_files:
                QMessageBox.warning(self, "No Images", f"No .img files found in {input_dir}")
                return
            
            self._repack_log(f"Found {len(image_files)} partition image(s):")
            
            for img in image_files:
                size_mb = img.stat().st_size / (1024 * 1024)
                name = img.stem
                item = QListWidgetItem(f"{name}  ({size_mb:.1f} MB)")
                item.setData(Qt.ItemDataRole.UserRole, str(img))
                self.repack_images_list.addItem(item)
                self.repack_images.append(str(img))
                self._repack_log(f"  • {name}: {size_mb:.1f} MB")
            
            self._repack_select_all()
            self.repack_btn.setEnabled(True)
            self.status_bar.showMessage(f"Found {len(image_files)} images ready for repacking")
        
        def _repack_select_all(self):
            for i in range(self.repack_images_list.count()):
                self.repack_images_list.item(i).setSelected(True)
        
        def _repack_select_none(self):
            for i in range(self.repack_images_list.count()):
                self.repack_images_list.item(i).setSelected(False)
        
        def _get_selected_images(self) -> list[str]:
            return [
                item.data(Qt.ItemDataRole.UserRole) 
                for item in self.repack_images_list.selectedItems()
            ]
        
        def _start_repack(self):
            selected = self._get_selected_images()
            if not selected:
                QMessageBox.warning(self, "Error", "Please select at least one image")
                return
            
            output_path = self.repack_output_path.text().strip()
            if not output_path:
                QMessageBox.warning(self, "Error", "Please specify an output file path")
                return
            
            self._set_repack_mode(True)
            self.repack_log_output.clear()
            
            compression = self.compression_combo.currentText()
            level = self.compression_level.value()
            
            self.creation_thread = CreationThread(
                selected,
                output_path,
                compression,
                level
            )
            self.creation_thread.progress.connect(self._on_repack_progress)
            self.creation_thread.log.connect(self._repack_log)
            self.creation_thread.error.connect(self._on_repack_error)
            self.creation_thread.finished.connect(self._on_repack_finished)
            self.creation_thread.start()
        
        def _set_repack_mode(self, repacking: bool):
            self.repack_btn.setEnabled(not repacking)
            self.repack_btn.setVisible(not repacking)
            self.repack_cancel_btn.setEnabled(repacking)
            self.repack_cancel_btn.setVisible(repacking)
            self.repack_scan_btn.setEnabled(not repacking)
            self.repack_input_dir.setEnabled(not repacking)
            self.repack_browse_input_btn.setEnabled(not repacking)
            self.repack_images_list.setEnabled(not repacking)
            if repacking:
                self.repack_progress_bar.setRange(0, 0)
        
        def _cancel_repack(self):
            if self.creation_thread:
                self.creation_thread.cancel()
                self._repack_log("\nCancelling...")
        
        def _on_repack_progress(self, current: int, total: int, msg: str):
            self.repack_progress_bar.setRange(0, total)
            self.repack_progress_bar.setValue(current)
            pct = int(current / total * 100) if total > 0 else 0
            self.repack_progress_label.setText(f"{pct}%")
            self.status_bar.showMessage(msg)
        
        def _on_repack_error(self, error: str):
            self._set_repack_mode(False)
            self._repack_log(f"\nError: {error}")
            self.status_bar.showMessage("Payload creation failed")
            QMessageBox.critical(self, "Error", f"Payload creation failed:\n{error}")
        
        def _on_repack_finished(self, output_path: str):
            self._set_repack_mode(False)
            self.repack_progress_bar.setValue(self.repack_progress_bar.maximum())
            self.repack_progress_label.setText("Complete")
            self.status_bar.showMessage("Payload created successfully!")
            
            result = QMessageBox.question(
                self, "Payload Created",
                f"Payload created successfully!\n\n{output_path}\n\nOpen containing folder?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if result == QMessageBox.StandardButton.Yes:
                folder = str(Path(output_path).parent)
                if sys.platform == 'win32':
                    os.startfile(folder)
                elif sys.platform == 'darwin':
                    os.system(f'open "{folder}"')
                else:
                    os.system(f'xdg-open "{folder}"')
        
        # ==========================================
        # Image Extract Tab Methods
        # ==========================================
        
        def _image_log(self, message: str):
            self.image_log_output.append(message)
            scrollbar = self.image_log_output.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())
        
        def _browse_image(self):
            path, _ = QFileDialog.getOpenFileName(
                self, "Select Android Image File", "",
                "Image Files (*.img *.bin);;All Files (*.*)"
            )
            if path:
                self.image_path_input.setText(path)
        
        def _browse_image_output(self):
            path = QFileDialog.getExistingDirectory(self, "Select Output Directory")
            if path:
                self.image_output_dir.setText(path)
        
        def _toggle_image_tree_selection(self, select: bool):
            for i in range(self.image_tree.topLevelItemCount()):
                item = self.image_tree.topLevelItem(i)
                if item:
                    item.setCheckState(0, Qt.CheckState.Checked if select else Qt.CheckState.Unchecked)
        
        def _analyze_image(self):
            path = self.image_path_input.text().strip()
            if not path:
                QMessageBox.warning(self, "Error", "Please enter an image file path")
                return
            
            if not Path(path).exists():
                QMessageBox.warning(self, "Error", f"File not found: {path}")
                return
            
            self.image_tree.clear()
            self.image_log_output.clear()
            self.image_extract_btn.setEnabled(False)
            
            self._image_log(f"Analyzing: {path}")
            
            try:
                extractor = AndroidImageExtractor(path)
                info = extractor.analyze()
                
                # Update info labels
                file_size = Path(path).stat().st_size
                self.image_type_label.setText(info['type'].upper())
                self.image_size_label.setText(f"{file_size / (1024*1024):.2f} MB ({file_size:,} bytes)")
                
                details = []
                for key, value in info.items():
                    if key not in ('type', 'partitions', 'contents'):
                        if isinstance(value, int) and value > 10000:
                            details.append(f"{key}: {value:,}")
                        else:
                            details.append(f"{key}: {value}")
                self.image_details_label.setText("\n".join(details) if details else "-")
                
                # Populate tree
                if 'partitions' in info:
                    for part in info['partitions']:
                        item = QTreeWidgetItem([
                            part.get('name', 'unknown'),
                            f"{part.get('size', 0) / (1024*1024):.2f} MB",
                            part.get('type', '-')
                        ])
                        item.setCheckState(0, Qt.CheckState.Checked)
                        item.setData(0, Qt.ItemDataRole.UserRole, part)
                        self.image_tree.addTopLevelItem(item)
                
                elif 'contents' in info:
                    for content in info['contents']:
                        item = QTreeWidgetItem([
                            content.get('name', 'unknown'),
                            f"{content.get('size', 0) / 1024:.2f} KB",
                            content.get('type', '-')
                        ])
                        item.setCheckState(0, Qt.CheckState.Checked)
                        item.setData(0, Qt.ItemDataRole.UserRole, content)
                        self.image_tree.addTopLevelItem(item)
                
                else:
                    # Single file extraction (sparse or simple image)
                    item = QTreeWidgetItem([
                        Path(path).stem,
                        f"{file_size / (1024*1024):.2f} MB",
                        info['type']
                    ])
                    item.setCheckState(0, Qt.CheckState.Checked)
                    item.setData(0, Qt.ItemDataRole.UserRole, {'name': Path(path).stem, 'type': info['type']})
                    self.image_tree.addTopLevelItem(item)
                
                self._image_log(f"Image type: {info['type']}")
                self._image_log(f"Found {self.image_tree.topLevelItemCount()} extractable item(s)")
                
                # Show/hide vbmeta options based on image type
                is_vbmeta = info['type'] == 'vbmeta'
                self.vbmeta_options_group.setVisible(is_vbmeta)
                
                if is_vbmeta:
                    # Get current flags and display
                    flags = VbmetaPatcher.get_current_flags(path)
                    if 'error' not in flags:
                        flag_status = []
                        if flags['verity_disabled']:
                            flag_status.append("verity DISABLED")
                        else:
                            flag_status.append("verity enabled")
                        if flags['verification_disabled']:
                            flag_status.append("verification DISABLED")
                        else:
                            flag_status.append("verification enabled")
                        self.vbmeta_current_flags.setText(
                            f"Current flags: 0x{flags['raw_flags']:08X} ({', '.join(flag_status)})"
                        )
                        # Pre-check boxes if already disabled
                        self.disable_verity_check.setChecked(flags['verity_disabled'])
                        self.disable_verification_check.setChecked(flags['verification_disabled'])
                    else:
                        self.vbmeta_current_flags.setText(f"Current flags: {flags['error']}")
                        self.disable_verity_check.setChecked(False)
                        self.disable_verification_check.setChecked(False)
                
                self.image_extract_btn.setEnabled(True)
                self.current_image_info = info
                self.current_image_path = path
                self.status_bar.showMessage(f"Analyzed: {info['type']} image")
                
            except Exception as e:
                self._image_log(f"Error: {e}")
                QMessageBox.critical(self, "Error", f"Failed to analyze image:\n{e}")
                self.image_type_label.setText("Error")
                self.image_size_label.setText("-")
                self.image_details_label.setText(str(e))
        
        def _get_selected_image_items(self) -> list[dict]:
            selected = []
            for i in range(self.image_tree.topLevelItemCount()):
                item = self.image_tree.topLevelItem(i)
                if item and item.checkState(0) == Qt.CheckState.Checked:
                    data = item.data(0, Qt.ItemDataRole.UserRole)
                    if data:
                        selected.append(data)
            return selected
        
        def _toggle_signing_options(self, state):
            """Show/hide signing options based on checkbox."""
            show = state == Qt.CheckState.Checked.value
            self.signing_options_widget.setVisible(show)
            if show:
                self._update_signing_status()
        
        def _toggle_reset_flags_mode(self, state):
            """Toggle reset flags mode - disable other options when reset is checked."""
            reset_mode = state == Qt.CheckState.Checked.value
            # When reset is checked, disable the individual disable checkboxes
            self.disable_verity_check.setEnabled(not reset_mode)
            self.disable_verification_check.setEnabled(not reset_mode)
            if reset_mode:
                # Uncheck the disable options when in reset mode
                self.disable_verity_check.setChecked(False)
                self.disable_verification_check.setChecked(False)
        
        def _toggle_key_source(self, generate: bool):
            """Toggle between generate and load key modes."""
            self.key_size_widget.setVisible(generate)
            self.key_file_widget.setVisible(not generate)
            self._update_signing_status()
        
        def _browse_key_file(self):
            """Browse for private key file."""
            path, _ = QFileDialog.getOpenFileName(
                self, "Select Private Key",
                "",
                "PEM Files (*.pem);;All Files (*.*)"
            )
            if path:
                self.key_file_edit.setText(path)
                self._update_signing_status()
        
        def _update_signing_status(self):
            """Update the signing status label."""
            if self.key_generate_radio.isChecked():
                key_size = self.key_size_combo.currentText()
                self.signing_status_label.setText(f"Will generate new {key_size} key for signing")
                self.signing_status_label.setStyleSheet("color: #4CAF50; font-size: 10px;")
            else:
                key_path = self.key_file_edit.text().strip()
                if key_path:
                    if os.path.exists(key_path):
                        self.signing_status_label.setText(f"Will use key: {Path(key_path).name}")
                        self.signing_status_label.setStyleSheet("color: #4CAF50; font-size: 10px;")
                    else:
                        self.signing_status_label.setText("Key file not found!")
                        self.signing_status_label.setStyleSheet("color: #F44336; font-size: 10px;")
                else:
                    self.signing_status_label.setText("Please select a key file")
                    self.signing_status_label.setStyleSheet("color: #FFA500; font-size: 10px;")
        
        # ===== Image Repack Tab Methods =====
        def _on_repack_type_changed(self, index: int):
            """Handle repack type selection change."""
            # Hide all widgets
            self.boot_repack_widget.setVisible(False)
            self.vendor_boot_widget.setVisible(False)
            self.sparse_widget.setVisible(False)
            self.vbmeta_widget.setVisible(False)
            self.ramdisk_widget.setVisible(False)
            self.super_widget.setVisible(False)
            self.erofs_widget.setVisible(False)
            
            # Show selected widget and set default output filename
            if index == 0:  # Boot Image
                self.boot_repack_widget.setVisible(True)
                if not self.repack_img_output_edit.text():
                    self.repack_img_output_edit.setText("boot.img")
            elif index == 1:  # Vendor Boot
                self.vendor_boot_widget.setVisible(True)
                if not self.repack_img_output_edit.text():
                    self.repack_img_output_edit.setText("vendor_boot.img")
            elif index == 2:  # Sparse
                self.sparse_widget.setVisible(True)
            elif index == 3:  # vbmeta
                self.vbmeta_widget.setVisible(True)
                if not self.repack_img_output_edit.text():
                    self.repack_img_output_edit.setText("vbmeta.img")
            elif index == 4:  # Ramdisk
                self.ramdisk_widget.setVisible(True)
                if not self.repack_img_output_edit.text():
                    self.repack_img_output_edit.setText("ramdisk.cpio.gz")
            elif index == 5:  # Super Partition
                self.super_widget.setVisible(True)
                if not self.repack_img_output_edit.text():
                    self.repack_img_output_edit.setText("super.img")
            elif index == 6:  # EROFS Image
                self.erofs_widget.setVisible(True)
                if not self.repack_img_output_edit.text():
                    self.repack_img_output_edit.setText("system.img")
        
        def _on_boot_version_changed(self, index: int):
            """Handle boot image version change."""
            version = index  # 0=v0, 1=v1, 2=v2, 3=v3, 4=v4
            # DTB is only for v2
            self.boot_dtb_widget.setVisible(version == 2)
        
        def _browse_repack_file(self, edit_widget: QLineEdit, file_type: str):
            """Browse for a repack input file."""
            path, _ = QFileDialog.getOpenFileName(
                self, f"Select {file_type}",
                "",
                "All Files (*.*)"
            )
            if path:
                edit_widget.setText(path)
        
        def _browse_ramdisk_dir(self):
            """Browse for ramdisk input directory."""
            path = QFileDialog.getExistingDirectory(
                self, "Select Ramdisk Directory"
            )
            if path:
                self.ramdisk_input_edit.setText(path)
        
        def _browse_erofs_source(self):
            """Browse for EROFS source directory."""
            path = QFileDialog.getExistingDirectory(
                self, "Select EROFS Source Directory"
            )
            if path:
                self.erofs_source_edit.setText(path)
        
        def _check_erofs_tool_availability(self):
            """Check if mkfs.erofs is available and update UI."""
            extractor = ErofsImageExtractor()
            mkfs_info = extractor._find_mkfs_erofs()
            
            if mkfs_info:
                tool_path = mkfs_info.get('path', 'Unknown')
                use_wsl = mkfs_info.get('use_wsl', False)
                if use_wsl:
                    self.erofs_tool_label.setText("✅ mkfs.erofs available via WSL")
                    self.erofs_tool_label.setStyleSheet("color: #4CAF50;")
                else:
                    self.erofs_tool_label.setText(f"✅ mkfs.erofs available: {Path(tool_path).name}")
                    self.erofs_tool_label.setStyleSheet("color: #4CAF50;")
            else:
                self.erofs_tool_label.setText("❌ mkfs.erofs not found - place mkfs.erofs.exe in Tools/ folder")
                self.erofs_tool_label.setStyleSheet("color: #F44336;")
        
        def _browse_repack_output_file(self):
            """Browse for repack output file."""
            repack_type = self.repack_type_combo.currentIndex()
            
            if repack_type == 0:
                default_name = "boot.img"
            elif repack_type == 1:
                default_name = "vendor_boot.img"
            elif repack_type == 2:
                default_name = "output_sparse.img"
            elif repack_type == 3:
                default_name = "vbmeta.img"
            elif repack_type == 4:
                default_name = "ramdisk.cpio.gz"
            elif repack_type == 5:
                default_name = "super.img"
            elif repack_type == 6:
                default_name = "system.img"
            else:
                default_name = "output.img"
            
            path, _ = QFileDialog.getSaveFileName(
                self, "Save Image As",
                default_name,
                "Image Files (*.img);;All Files (*.*)"
            )
            if path:
                self.repack_img_output_edit.setText(path)
        
        def _repack_log(self, msg: str):
            """Add message to repack log."""
            self.repack_img_log.append(msg)
        
        def _start_image_repack(self):
            """Start image repack operation."""
            output_path = self.repack_img_output_edit.text().strip()
            if not output_path:
                QMessageBox.warning(self, "Error", "Please specify an output file path")
                return
            
            repack_type = self.repack_type_combo.currentIndex()
            self.repack_img_log.clear()
            
            try:
                if repack_type == 0:
                    self._repack_boot_image(output_path)
                elif repack_type == 1:
                    self._repack_vendor_boot(output_path)
                elif repack_type == 2:
                    self._repack_sparse(output_path)
                elif repack_type == 3:
                    self._repack_vbmeta(output_path)
                elif repack_type == 4:
                    self._repack_ramdisk(output_path)
                elif repack_type == 5:
                    self._repack_super(output_path)
                elif repack_type == 6:
                    self._repack_erofs(output_path)
            except Exception as e:
                self._repack_log(f"Error: {e}")
                QMessageBox.critical(self, "Error", f"Failed to create image:\n{e}")
        
        def _repack_boot_image(self, output_path: str):
            """Repack boot image."""
            kernel_path = self.boot_kernel_edit.text().strip()
            ramdisk_path = self.boot_ramdisk_edit.text().strip()
            dtb_path = self.boot_dtb_edit.text().strip() if self.boot_dtb_widget.isVisible() else ""
            cmdline = self.boot_cmdline_edit.text().strip()
            page_size = int(self.boot_page_size.currentText())
            version = self.boot_version_combo.currentIndex()
            
            if not kernel_path:
                QMessageBox.warning(self, "Error", "Please select a kernel file")
                return
            
            self._repack_log(f"Creating boot.img v{version}...")
            self._repack_log(f"  Kernel: {kernel_path}")
            if ramdisk_path:
                self._repack_log(f"  Ramdisk: {ramdisk_path}")
            if dtb_path:
                self._repack_log(f"  DTB: {dtb_path}")
            self._repack_log(f"  Page size: {page_size}")
            
            self.repack_img_progress.setRange(0, 0)  # Indeterminate
            
            packer = BootImagePacker()
            success = packer.pack_boot_image(
                output_path,
                kernel=kernel_path,
                ramdisk=ramdisk_path if ramdisk_path else None,
                dtb=dtb_path if dtb_path else None,
                cmdline=cmdline,
                page_size=page_size,
                header_version=version
            )
            
            self.repack_img_progress.setRange(0, 100)
            self.repack_img_progress.setValue(100 if success else 0)
            
            if success:
                size = os.path.getsize(output_path)
                self._repack_log(f"\n✅ Boot image created successfully!")
                self._repack_log(f"  Output: {output_path}")
                self._repack_log(f"  Size: {size / (1024*1024):.2f} MB")
                self.repack_img_progress_label.setText("Complete")
                QMessageBox.information(self, "Success", f"Boot image created:\n{output_path}")
            else:
                self._repack_log("❌ Failed to create boot image")
                self.repack_img_progress_label.setText("Failed")
        
        def _repack_vendor_boot(self, output_path: str):
            """Repack vendor_boot image."""
            ramdisk_path = self.vb_ramdisk_edit.text().strip()
            dtb_path = self.vb_dtb_edit.text().strip()
            cmdline = self.vb_cmdline_edit.text().strip()
            version = 3 + self.vb_version_combo.currentIndex()
            
            self._repack_log(f"Creating vendor_boot.img v{version}...")
            if ramdisk_path:
                self._repack_log(f"  Vendor Ramdisk: {ramdisk_path}")
            if dtb_path:
                self._repack_log(f"  DTB: {dtb_path}")
            
            self.repack_img_progress.setRange(0, 0)
            
            packer = BootImagePacker()
            success = packer.pack_vendor_boot(
                output_path,
                ramdisk=ramdisk_path if ramdisk_path else None,
                dtb=dtb_path if dtb_path else None,
                vendor_cmdline=cmdline,
                header_version=version
            )
            
            self.repack_img_progress.setRange(0, 100)
            self.repack_img_progress.setValue(100 if success else 0)
            
            if success:
                size = os.path.getsize(output_path)
                self._repack_log(f"\n✅ Vendor boot image created!")
                self._repack_log(f"  Output: {output_path}")
                self._repack_log(f"  Size: {size / (1024*1024):.2f} MB")
                self.repack_img_progress_label.setText("Complete")
                QMessageBox.information(self, "Success", f"Vendor boot image created:\n{output_path}")
            else:
                self._repack_log("❌ Failed to create vendor boot image")
                self.repack_img_progress_label.setText("Failed")
        
        def _repack_sparse(self, output_path: str):
            """Convert raw image to sparse."""
            input_path = self.sparse_input_edit.text().strip()
            if not input_path:
                QMessageBox.warning(self, "Error", "Please select a raw image file")
                return
            
            if not os.path.exists(input_path):
                QMessageBox.warning(self, "Error", f"Input file not found:\n{input_path}")
                return
            
            block_size = int(self.sparse_block_size.currentText())
            
            self._repack_log(f"Converting to sparse format...")
            self._repack_log(f"  Input: {input_path}")
            self._repack_log(f"  Block size: {block_size}")
            
            input_size = os.path.getsize(input_path)
            self._repack_log(f"  Input size: {input_size / (1024*1024):.2f} MB")
            
            def progress_callback(current, total, msg):
                pct = int(current / total * 100) if total > 0 else 0
                self.repack_img_progress.setValue(pct)
                self.repack_img_progress_label.setText(msg)
            
            self.repack_img_progress.setRange(0, 100)
            
            creator = SparseImageCreator(block_size, progress_callback)
            success = creator.convert(input_path, output_path)
            
            if success:
                output_size = os.path.getsize(output_path)
                ratio = (1 - output_size / input_size) * 100 if input_size > 0 else 0
                self._repack_log(f"\n✅ Sparse image created!")
                self._repack_log(f"  Output: {output_path}")
                self._repack_log(f"  Output size: {output_size / (1024*1024):.2f} MB")
                self._repack_log(f"  Size reduction: {ratio:.1f}%")
                self.repack_img_progress_label.setText("Complete")
                QMessageBox.information(self, "Success", 
                    f"Sparse image created:\n{output_path}\n\nSize reduction: {ratio:.1f}%")
            else:
                self._repack_log("❌ Failed to create sparse image")
                self.repack_img_progress_label.setText("Failed")
        
        def _repack_vbmeta(self, output_path: str):
            """Create empty/disabled vbmeta."""
            disable_verity = self.vbmeta_disable_verity_create.isChecked()
            disable_verification = self.vbmeta_disable_verification_create.isChecked()
            sign_with_key = self.vbmeta_sign_create.isChecked() and CRYPTO_AVAILABLE
            
            self._repack_log("Creating vbmeta image...")
            self._repack_log(f"  Disable verity: {disable_verity}")
            self._repack_log(f"  Disable verification: {disable_verification}")
            self._repack_log(f"  Sign with key: {sign_with_key}")
            
            self.repack_img_progress.setRange(0, 0)
            
            signer = None
            if sign_with_key:
                signer = AvbSigner()
                self._repack_log("  Generating RSA-4096 signing key...")
                signer.generate_key(4096)
                
                # Save the key next to the vbmeta
                key_path = output_path.replace('.img', '_key.pem')
                signer.save_private_key(key_path)
                self._repack_log(f"  Signing key saved: {key_path}")
            
            creator = VbmetaCreator(signer)
            success = creator.create_empty_vbmeta(
                output_path,
                disable_verity=disable_verity,
                disable_verification=disable_verification
            )
            
            self.repack_img_progress.setRange(0, 100)
            self.repack_img_progress.setValue(100 if success else 0)
            
            if success:
                size = os.path.getsize(output_path)
                self._repack_log(f"\n✅ vbmeta image created!")
                self._repack_log(f"  Output: {output_path}")
                self._repack_log(f"  Size: {size} bytes")
                self.repack_img_progress_label.setText("Complete")
                QMessageBox.information(self, "Success", f"vbmeta image created:\n{output_path}")
            else:
                self._repack_log("❌ Failed to create vbmeta image")
                self.repack_img_progress_label.setText("Failed")
        
        def _repack_ramdisk(self, output_path: str):
            """Pack directory into ramdisk."""
            input_dir = self.ramdisk_input_edit.text().strip()
            if not input_dir:
                QMessageBox.warning(self, "Error", "Please select an input directory")
                return
            
            if not os.path.isdir(input_dir):
                QMessageBox.warning(self, "Error", f"Directory not found:\n{input_dir}")
                return
            
            compression = self.ramdisk_compression.currentText()
            
            self._repack_log(f"Creating ramdisk from directory...")
            self._repack_log(f"  Input: {input_dir}")
            self._repack_log(f"  Compression: {compression}")
            
            # Count files
            file_count = sum(1 for _ in Path(input_dir).rglob('*'))
            self._repack_log(f"  Files/dirs: {file_count}")
            
            def progress_callback(current, total, msg):
                pct = int(current / total * 100) if total > 0 else 0
                self.repack_img_progress.setValue(pct)
            
            self.repack_img_progress.setRange(0, 100)
            
            packer = RamdiskPacker(progress_callback)
            success = packer.pack(input_dir, output_path, compression)
            
            if success:
                size = os.path.getsize(output_path)
                self._repack_log(f"\n✅ Ramdisk created!")
                self._repack_log(f"  Output: {output_path}")
                self._repack_log(f"  Size: {size / 1024:.2f} KB")
                self.repack_img_progress_label.setText("Complete")
                QMessageBox.information(self, "Success", f"Ramdisk created:\n{output_path}")
            else:
                self._repack_log("❌ Failed to create ramdisk")
                self.repack_img_progress_label.setText("Failed")
        
        # ===== Super Partition Methods =====
        def _super_add_partition(self):
            """Add a partition image to the super list."""
            paths, _ = QFileDialog.getOpenFileNames(
                self, "Select Partition Image(s)",
                "",
                "Image Files (*.img);;All Files (*.*)"
            )
            for path in paths:
                # Extract partition name from filename
                name = Path(path).stem
                # Remove common suffixes
                for suffix in ['_a', '_b', '-sign', '.raw', '_raw']:
                    if name.endswith(suffix):
                        name = name[:-len(suffix)]
                
                size = os.path.getsize(path)
                size_mb = size / (1024 * 1024)
                
                item = QListWidgetItem(f"{name}: {size_mb:.2f} MB - {path}")
                item.setData(Qt.ItemDataRole.UserRole, {'name': name, 'path': path, 'size': size})
                self.super_partitions_list.addItem(item)
            
            self._super_update_calc()
        
        def _super_remove_partition(self):
            """Remove selected partition from the super list."""
            for item in self.super_partitions_list.selectedItems():
                self.super_partitions_list.takeItem(self.super_partitions_list.row(item))
            self._super_update_calc()
        
        def _super_scan_directory(self):
            """Scan a directory for partition images."""
            dir_path = QFileDialog.getExistingDirectory(
                self, "Select Directory with Partition Images",
                str(Path.cwd())
            )
            if not dir_path:
                return
            
            # Common partition names to look for
            partition_names = [
                'system', 'system_ext', 'vendor', 'product', 'odm', 
                'vendor_dlkm', 'odm_dlkm', 'system_dlkm'
            ]
            
            found = 0
            for img_file in Path(dir_path).glob('*.img'):
                name = img_file.stem.lower()
                # Check if it's a known partition or just add any .img
                base_name = name
                for suffix in ['_a', '_b', '-sign', '.raw', '_raw']:
                    if base_name.endswith(suffix):
                        base_name = base_name[:-len(suffix)]
                
                size = img_file.stat().st_size
                if size > 0:  # Skip empty files
                    size_mb = size / (1024 * 1024)
                    item = QListWidgetItem(f"{base_name}: {size_mb:.2f} MB - {img_file}")
                    item.setData(Qt.ItemDataRole.UserRole, {
                        'name': base_name, 
                        'path': str(img_file), 
                        'size': size
                    })
                    self.super_partitions_list.addItem(item)
                    found += 1
            
            self._super_update_calc()
            
            if found > 0:
                self._repack_log(f"Found {found} partition image(s) in {dir_path}")
            else:
                QMessageBox.information(self, "Scan Complete", 
                    f"No .img files found in:\n{dir_path}")
        
        def _super_update_calc(self):
            """Update the calculated total size display."""
            total_size = 0
            for i in range(self.super_partitions_list.count()):
                item = self.super_partitions_list.item(i)
                data = item.data(Qt.ItemDataRole.UserRole)
                if data:
                    total_size += data.get('size', 0)
            
            total_mb = total_size / (1024 * 1024)
            self.super_calc_label.setText(f"Total partition size: {total_mb:.2f} MB ({self.super_partitions_list.count()} partitions)")
        
        def _repack_super(self, output_path: str):
            """Create super.img from partition images."""
            if self.super_partitions_list.count() == 0:
                QMessageBox.warning(self, "Error", "Please add at least one partition image")
                return
            
            # Get settings
            group_name = self.super_group_name.text().strip() or "default"
            sparse_output = self.super_sparse_check.isChecked()
            readonly = self.super_readonly_check.isChecked()
            
            # Get metadata size
            metadata_text = self.super_metadata_size.currentText()
            metadata_size = int(metadata_text.split()[0])
            
            # Calculate or get sizes
            if self.super_size_auto.isChecked():
                super_size = 0  # Auto-calculate
            else:
                super_size = self.super_size_spin.value() * 1024 * 1024
            
            if self.super_group_size_auto.isChecked():
                group_max_size = 0  # Auto-calculate
            else:
                group_max_size = self.super_group_size_spin.value() * 1024 * 1024
            
            self._repack_log(f"\ud83d\udd25 Creating super.img (dynamic partition)...")
            self._repack_log(f"  Group: {group_name}")
            self._repack_log(f"  Partitions: {self.super_partitions_list.count()}")
            self._repack_log(f"  Metadata size: {metadata_size}")
            self._repack_log(f"  Sparse output: {sparse_output}")
            self._repack_log(f"  Read-only: {readonly}")
            
            def progress_callback(current, total, msg):
                pct = int(current / total * 100) if total > 0 else 0
                self.repack_img_progress.setValue(pct)
                self.repack_img_progress_label.setText(msg)
            
            self.repack_img_progress.setRange(0, 100)
            self.repack_img_progress.setValue(0)
            
            try:
                creator = SuperImageCreator(progress_callback)
                creator.set_metadata_size(metadata_size)
                creator.set_sparse(sparse_output)
                
                if super_size > 0:
                    creator.set_super_size(super_size)
                
                # Add partitions
                total_size = 0
                for i in range(self.super_partitions_list.count()):
                    item = self.super_partitions_list.item(i)
                    data = item.data(Qt.ItemDataRole.UserRole)
                    if data:
                        creator.add_partition(
                            data['name'], 
                            data['path'], 
                            group_name, 
                            readonly
                        )
                        total_size += data['size']
                        self._repack_log(f"  + {data['name']}: {data['size'] / (1024*1024):.2f} MB")
                
                # Set group max size
                if group_max_size > 0:
                    creator.add_group(group_name, group_max_size)
                else:
                    # Auto: total size + 10% buffer
                    creator.add_group(group_name, int(total_size * 1.1))
                
                self._repack_log(f"\nBuilding super.img...")
                
                # Create the image
                success = creator.create(output_path)
                
                if success:
                    size = os.path.getsize(output_path)
                    self._repack_log(f"\n🔥 Super image created successfully!")
                    self._repack_log(f"  Output: {output_path}")
                    self._repack_log(f"  Size: {size / (1024*1024):.2f} MB")
                    self.repack_img_progress.setValue(100)
                    self.repack_img_progress_label.setText("Complete")
                    self._show_toast(f"Super.img created: {size / (1024*1024):.0f} MB", 'success')
                    QMessageBox.information(self, "Success", 
                        f"Super partition image created!\n\n"
                        f"Output: {output_path}\n"
                        f"Size: {size / (1024*1024):.2f} MB\n"
                        f"Partitions: {self.super_partitions_list.count()}")
                else:
                    self._repack_log("💀 Failed to create super image")
                    self.repack_img_progress_label.setText("Failed")
                    
            except Exception as e:
                self._repack_log(f"💀 Error: {e}")
                self.repack_img_progress_label.setText("Failed")
                raise
        
        def _repack_erofs(self, output_path: str):
            """Create EROFS image from directory."""
            source_dir = self.erofs_source_edit.text().strip()
            if not source_dir:
                QMessageBox.warning(self, "Error", "Please select a source directory")
                return
            
            if not os.path.isdir(source_dir):
                QMessageBox.warning(self, "Error", f"Source directory not found:\n{source_dir}")
                return
            
            # Get settings
            compression = self.erofs_compression_combo.currentText()
            block_size = int(self.erofs_block_size_combo.currentText())
            volume_name = self.erofs_volume_name.text().strip() or None
            
            # Build extra args for features
            extra_args = []
            if self.erofs_dedupe_check.isChecked():
                extra_args.append('-Ededupe')
            if self.erofs_fragments_check.isChecked():
                extra_args.append('-Efragments')
            if self.erofs_ztailpacking_check.isChecked():
                extra_args.append('-Eztailpacking')
            
            self._repack_log(f"🔥 Creating EROFS image...")
            self._repack_log(f"  Source: {source_dir}")
            self._repack_log(f"  Compression: {compression}")
            self._repack_log(f"  Block size: {block_size}")
            if volume_name:
                self._repack_log(f"  Volume name: {volume_name}")
            if extra_args:
                self._repack_log(f"  Features: {', '.join(extra_args)}")
            
            def progress_callback(current, total, msg):
                pct = int(current / total * 100) if total > 0 else 0
                self.repack_img_progress.setValue(pct)
                self.repack_img_progress_label.setText(msg)
            
            self.repack_img_progress.setRange(0, 100)
            self.repack_img_progress.setValue(0)
            
            try:
                extractor = ErofsImageExtractor(progress_callback)
                
                # Check tool availability
                if not extractor.can_repack():
                    self._repack_log("❌ mkfs.erofs not found!")
                    self._repack_log("   Place mkfs.erofs.exe in the Tools/ folder")
                    self._repack_log("   Or install erofs-utils on your system")
                    QMessageBox.critical(self, "Error", 
                        "mkfs.erofs not found!\n\n"
                        "Place mkfs.erofs.exe in the Tools/ folder,\n"
                        "or install erofs-utils on your system.")
                    return
                
                self._repack_log("\nBuilding EROFS image...")
                
                success = extractor.repack(
                    source_dir=source_dir,
                    output_path=output_path,
                    compression=compression,
                    block_size=block_size,
                    volume_name=volume_name,
                    extra_args=extra_args if extra_args else None
                )
                
                if success:
                    size = os.path.getsize(output_path)
                    self._repack_log(f"\n🔥 EROFS image created successfully!")
                    self._repack_log(f"  Output: {output_path}")
                    self._repack_log(f"  Size: {size / (1024*1024):.2f} MB")
                    self.repack_img_progress.setValue(100)
                    self.repack_img_progress_label.setText("Complete")
                    self._show_toast(f"EROFS image created: {size / (1024*1024):.0f} MB", 'success')
                    QMessageBox.information(self, "Success", 
                        f"EROFS image created!\n\n"
                        f"Output: {output_path}\n"
                        f"Size: {size / (1024*1024):.2f} MB\n"
                        f"Compression: {compression}")
                else:
                    self._repack_log("💀 Failed to create EROFS image")
                    self.repack_img_progress_label.setText("Failed")
                    QMessageBox.critical(self, "Error", "Failed to create EROFS image. Check the log for details.")
                    
            except Exception as e:
                self._repack_log(f"💀 Error: {e}")
                self.repack_img_progress_label.setText("Failed")
                raise
        
        # ===== Recovery Porter Methods =====
        def _recovery_log(self, msg: str):
            """Add message to recovery log."""
            self.recovery_log.append(msg)
        
        def _browse_recovery_source(self):
            """Browse for source recovery image."""
            path, _ = QFileDialog.getOpenFileName(
                self, "Select Recovery Image",
                "",
                "Image Files (*.img);;All Files (*.*)"
            )
            if path:
                self.recovery_source_edit.setText(path)
        
        def _browse_recovery_kernel(self):
            """Browse for replacement kernel."""
            path, _ = QFileDialog.getOpenFileName(
                self, "Select Kernel",
                "",
                "All Files (*.*)"
            )
            if path:
                self.recovery_kernel_edit.setText(path)
        
        def _browse_recovery_dtb(self):
            """Browse for replacement DTB."""
            path, _ = QFileDialog.getOpenFileName(
                self, "Select DTB",
                "",
                "DTB Files (*.dtb);;All Files (*.*)"
            )
            if path:
                self.recovery_dtb_edit.setText(path)
        
        def _browse_recovery_output(self):
            """Browse for recovery output path."""
            path, _ = QFileDialog.getSaveFileName(
                self, "Save Recovery As",
                "recovery_ported.img",
                "Image Files (*.img);;All Files (*.*)"
            )
            if path:
                self.recovery_output_edit.setText(path)
        
        def _analyze_recovery(self):
            """Analyze the source recovery image."""
            source = self.recovery_source_edit.text().strip()
            if not source:
                QMessageBox.warning(self, "Error", "Please select a recovery image")
                return
            
            if not os.path.exists(source):
                QMessageBox.warning(self, "Error", f"File not found:\n{source}")
                return
            
            self.recovery_log.clear()
            self._recovery_log(f"Analyzing: {Path(source).name}")
            self._recovery_log("")
            
            self.recovery_progress.setRange(0, 0)  # Indeterminate
            
            try:
                porter = RecoveryPorter()
                info = porter.analyze(source)
                
                # Clear and populate info tree
                self.recovery_info_tree.clear()
                
                # Basic info
                basic = QTreeWidgetItem(["Basic Info", ""])
                basic.addChild(QTreeWidgetItem(["Recovery Type", info.get('recovery_type', 'Unknown')]))
                basic.addChild(QTreeWidgetItem(["Format", info.get('format', 'Unknown')]))
                basic.addChild(QTreeWidgetItem(["Header Version", str(info.get('header_version', 0))]))
                basic.addChild(QTreeWidgetItem(["Size", f"{info.get('size', 0) / (1024*1024):.2f} MB"]))
                if info.get('board_name'):
                    basic.addChild(QTreeWidgetItem(["Board Name", info['board_name']]))
                self.recovery_info_tree.addTopLevelItem(basic)
                basic.setExpanded(True)
                
                # Components
                components = QTreeWidgetItem(["Components", ""])
                components.addChild(QTreeWidgetItem(["Kernel", f"{info.get('kernel_size', 0) / 1024:.1f} KB"]))
                components.addChild(QTreeWidgetItem(["Ramdisk", f"{info.get('ramdisk_size', 0) / 1024:.1f} KB"]))
                if info.get('dtb_size', 0) > 0:
                    components.addChild(QTreeWidgetItem(["DTB", f"{info['dtb_size'] / 1024:.1f} KB"]))
                self.recovery_info_tree.addTopLevelItem(components)
                components.setExpanded(True)
                
                # Cmdline
                if info.get('cmdline'):
                    cmdline_item = QTreeWidgetItem(["Cmdline", info['cmdline'][:50] + "..." if len(info.get('cmdline', '')) > 50 else info['cmdline']])
                    self.recovery_info_tree.addTopLevelItem(cmdline_item)
                    self.recovery_cmdline_edit.setText(info['cmdline'])
                
                # Fstab files
                if info.get('fstab_files'):
                    fstab = QTreeWidgetItem(["Fstab Files", ""])
                    for f in info['fstab_files']:
                        fstab.addChild(QTreeWidgetItem([f, ""]))
                    self.recovery_info_tree.addTopLevelItem(fstab)
                    fstab.setExpanded(True)
                
                # Warnings
                if info.get('warnings'):
                    warnings = QTreeWidgetItem(["⚠️ Warnings", ""])
                    for w in info['warnings']:
                        warnings.addChild(QTreeWidgetItem([w, ""]))
                    self.recovery_info_tree.addTopLevelItem(warnings)
                    warnings.setExpanded(True)
                
                # Populate ramdisk tree
                self.ramdisk_tree.clear()
                ramdisk_files = info.get('ramdisk_files', [])
                
                # Group by directory
                dir_items = {}
                for f in ramdisk_files:
                    name = f['name']
                    parts = name.split('/')
                    
                    if len(parts) == 1:
                        # Root level
                        item = QTreeWidgetItem([name, f"{f['size']}" if f['size'] > 0 else "", f['type']])
                        self.ramdisk_tree.addTopLevelItem(item)
                    else:
                        # In subdirectory - simplified flat view with full path
                        item = QTreeWidgetItem([name, f"{f['size']}" if f['size'] > 0 else "", f['type']])
                        self.ramdisk_tree.addTopLevelItem(item)
                
                self._recovery_log(f"Recovery Type: {info.get('recovery_type', 'Unknown')}")
                self._recovery_log(f"Header Version: {info.get('header_version', 0)}")
                self._recovery_log(f"Kernel: {info.get('kernel_size', 0) / 1024:.1f} KB")
                self._recovery_log(f"Ramdisk: {info.get('ramdisk_size', 0) / 1024:.1f} KB")
                self._recovery_log(f"Ramdisk files: {len(ramdisk_files)}")
                
                if info.get('can_port', True):
                    self._recovery_log("\n✅ Recovery can be ported/modified")
                    self.recovery_build_btn.setEnabled(True)
                    self.ramdisk_extract_btn.setEnabled(True)
                    self.ramdisk_edit_fstab_btn.setEnabled(bool(info.get('fstab_files')))
                else:
                    self._recovery_log("\n❌ Recovery format not supported for porting")
                
                # Store for later use
                self._current_recovery_info = info
                self._current_recovery_path = source
                
            except Exception as e:
                self._recovery_log(f"Error: {e}")
                QMessageBox.critical(self, "Error", f"Failed to analyze recovery:\n{e}")
            finally:
                self.recovery_progress.setRange(0, 100)
                self.recovery_progress.setValue(100)
        
        def _on_ramdisk_item_double_click(self, item, column):
            """Handle double-click on ramdisk item."""
            name = item.text(0)
            file_type = item.text(2)
            self._recovery_log(f"Selected: {name} ({file_type})")
        
        def _extract_ramdisk(self):
            """Extract ramdisk contents to a directory."""
            if not hasattr(self, '_current_recovery_path'):
                return
            
            output_dir = QFileDialog.getExistingDirectory(
                self, "Select Output Directory for Ramdisk"
            )
            if not output_dir:
                return
            
            self._recovery_log(f"\nExtracting ramdisk to: {output_dir}")
            self.recovery_progress.setRange(0, 0)
            
            try:
                porter = RecoveryPorter()
                result = porter.extract_components(self._current_recovery_path, output_dir)
                
                if result.get('ramdisk_dir'):
                    self._recovery_log(f"✅ Ramdisk extracted to: {result['ramdisk_dir']}")
                    self._recovery_log(f"   Kernel: {result.get('kernel', 'N/A')}")
                    
                    # Store for repacking
                    self._extracted_components = result
                    
                    QMessageBox.information(self, "Success", 
                        f"Ramdisk extracted to:\n{result['ramdisk_dir']}\n\n"
                        "You can now modify files and rebuild.")
                else:
                    self._recovery_log("❌ Failed to extract ramdisk")
                    
            except Exception as e:
                self._recovery_log(f"Error: {e}")
                QMessageBox.critical(self, "Error", f"Extraction failed:\n{e}")
            finally:
                self.recovery_progress.setRange(0, 100)
                self.recovery_progress.setValue(100)
        
        def _edit_fstab(self):
            """Open fstab editor dialog."""
            if not hasattr(self, '_current_recovery_info'):
                return
            
            fstab_files = self._current_recovery_info.get('fstab_files', [])
            if not fstab_files:
                QMessageBox.information(self, "Info", "No fstab files found in recovery")
                return
            
            # For now, show info about fstab editing
            QMessageBox.information(self, "Fstab Editor",
                f"Found fstab files:\n" + "\n".join(f"• {f}" for f in fstab_files) +
                "\n\nTo edit fstab:\n"
                "1. Click 'Extract All' to extract ramdisk\n"
                "2. Edit the fstab file(s) in the extracted directory\n"
                "3. Modify partition paths for your target device\n"
                "4. Click 'Build Recovery' to repack\n\n"
                "Common fstab modifications:\n"
                "• Change /dev/block/bootdevice paths\n"
                "• Update partition names (system, vendor, data)\n"
                "• Adjust filesystem types (ext4, f2fs, erofs)")
        
        def _build_recovery(self):
            """Build the modified recovery image."""
            output_path = self.recovery_output_edit.text().strip()
            if not output_path:
                QMessageBox.warning(self, "Error", "Please specify an output path")
                return
            
            if not hasattr(self, '_current_recovery_path'):
                QMessageBox.warning(self, "Error", "Please analyze a recovery first")
                return
            
            self._recovery_log("\n" + "="*50)
            self._recovery_log("Building recovery image...")
            self.recovery_progress.setRange(0, 0)
            
            try:
                porter = RecoveryPorter()
                
                # Extract if not already extracted
                if not hasattr(self, '_extracted_components'):
                    import tempfile
                    temp_dir = tempfile.mkdtemp(prefix='recovery_')
                    self._recovery_log(f"Extracting to temp: {temp_dir}")
                    self._extracted_components = porter.extract_components(
                        self._current_recovery_path, temp_dir)
                
                components = self._extracted_components.copy()
                
                # Apply modifications
                new_kernel = self.recovery_kernel_edit.text().strip()
                if new_kernel and os.path.exists(new_kernel):
                    components['kernel'] = new_kernel
                    self._recovery_log(f"Using replacement kernel: {Path(new_kernel).name}")
                
                new_dtb = self.recovery_dtb_edit.text().strip()
                if new_dtb and os.path.exists(new_dtb):
                    components['dtb'] = new_dtb
                    self._recovery_log(f"Using replacement DTB: {Path(new_dtb).name}")
                
                new_cmdline = self.recovery_cmdline_edit.text().strip()
                if new_cmdline:
                    components['cmdline'] = new_cmdline
                    self._recovery_log(f"Using cmdline: {new_cmdline[:50]}...")
                
                # Build
                success = porter.repack(components, output_path)
                
                if success:
                    size = os.path.getsize(output_path)
                    self._recovery_log(f"\n✅ Recovery built successfully!")
                    self._recovery_log(f"   Output: {output_path}")
                    self._recovery_log(f"   Size: {size / (1024*1024):.2f} MB")
                    
                    QMessageBox.information(self, "Success",
                        f"Recovery image created:\n{output_path}\n\n"
                        f"Size: {size / (1024*1024):.2f} MB\n\n"
                        "Flash with:\n"
                        "fastboot flash recovery recovery.img")
                else:
                    self._recovery_log("❌ Failed to build recovery")
                    QMessageBox.critical(self, "Error", "Failed to build recovery image")
                    
            except Exception as e:
                self._recovery_log(f"Error: {e}")
                QMessageBox.critical(self, "Error", f"Build failed:\n{e}")
            finally:
                self.recovery_progress.setRange(0, 100)
                self.recovery_progress.setValue(100 if 'success' in dir() and success else 0)
        
        # =============================================================
        # ALLWINNER FIRMWARE METHODS
        # =============================================================
        
        def _get_allwinner_tool(self) -> Optional[str]:
            """Find the imgRePacker tool."""
            base = Path(sys.executable).parent if getattr(sys, 'frozen', False) else Path(__file__).parent
            
            # Check tools folder
            tool_path = base / 'tools' / 'Allwinner' / 'imgRePacker.exe'
            if tool_path.exists():
                return str(tool_path)
            
            # Check if it's in PATH
            if shutil.which('imgRePacker.exe'):
                return shutil.which('imgRePacker.exe')
            
            return None
        
        def _aw_log(self, msg: str):
            """Log message to Allwinner log."""
            self.aw_log.appendPlainText(msg)
            QApplication.processEvents()
        
        def _browse_allwinner_firmware(self):
            path, _ = QFileDialog.getOpenFileName(
                self, "Select Allwinner Firmware",
                "", "Firmware Images (*.img);;All Files (*)"
            )
            if path:
                self.aw_firmware_path.setText(path)
                # Auto-set output directory
                if not self.aw_output_path.text():
                    self.aw_output_path.setText(str(Path(path).parent / (Path(path).stem + ".dump")))
        
        def _browse_allwinner_output(self):
            path = QFileDialog.getExistingDirectory(self, "Select Output Directory")
            if path:
                self.aw_output_path.setText(path)
        
        def _allwinner_unpack(self):
            """Unpack Allwinner firmware using imgRePacker."""
            tool = self._get_allwinner_tool()
            if not tool:
                QMessageBox.critical(self, "Error", 
                    "imgRePacker.exe not found!\n\n"
                    "Please ensure the tool is in:\n"
                    "tools/Allwinner/imgRePacker.exe")
                return
            
            firmware = self.aw_firmware_path.text().strip()
            if not firmware or not os.path.exists(firmware):
                QMessageBox.warning(self, "Error", "Please select a valid firmware file")
                return
            
            self.aw_log.clear()
            self._aw_log(f"🌞 Allwinner Firmware Unpacker")
            self._aw_log(f"{'='*50}")
            self._aw_log(f"Tool: {tool}")
            self._aw_log(f"Firmware: {firmware}")
            self._aw_log("")
            
            # Build command
            cmd = [tool]
            
            if self.aw_2nd_layer_cb.isChecked():
                cmd.append("/2nd")
            if self.aw_noiso_cb.isChecked():
                cmd.append("/noiso")
            
            cmd.append(firmware)
            
            self._aw_log(f"Command: {' '.join(cmd)}")
            self._aw_log("")
            
            self.aw_progress.setVisible(True)
            self.aw_progress.setRange(0, 0)
            self.aw_unpack_btn.setEnabled(False)
            self.aw_repack_btn.setEnabled(False)
            
            try:
                # Run the tool
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    cwd=str(Path(tool).parent)
                )
                
                # Stream output
                for line in process.stdout:
                    self._aw_log(line.rstrip())
                
                process.wait()
                
                if process.returncode == 0:
                    dump_dir = firmware + ".dump"
                    self._aw_log("")
                    self._aw_log(f"✅ Unpack complete!")
                    self._aw_log(f"Output: {dump_dir}")
                    
                    if os.path.exists(dump_dir):
                        # Count extracted files
                        file_count = sum(1 for _ in Path(dump_dir).rglob('*') if _.is_file())
                        self._aw_log(f"Files extracted: {file_count}")
                        
                        QMessageBox.information(self, "Success",
                            f"Firmware unpacked successfully!\n\n"
                            f"Output: {dump_dir}\n"
                            f"Files: {file_count}")
                else:
                    self._aw_log(f"❌ Unpack failed with code: {process.returncode}")
                    QMessageBox.critical(self, "Error", "Firmware unpack failed!")
                    
            except Exception as e:
                self._aw_log(f"Error: {e}")
                QMessageBox.critical(self, "Error", f"Unpack failed:\n{e}")
            finally:
                self.aw_progress.setVisible(False)
                self.aw_unpack_btn.setEnabled(True)
                self.aw_repack_btn.setEnabled(True)
        
        def _allwinner_repack(self):
            """Repack Allwinner firmware using imgRePacker."""
            tool = self._get_allwinner_tool()
            if not tool:
                QMessageBox.critical(self, "Error", 
                    "imgRePacker.exe not found!\n\n"
                    "Please ensure the tool is in:\n"
                    "tools/Allwinner/imgRePacker.exe")
                return
            
            # Check for .dump directory
            firmware = self.aw_firmware_path.text().strip()
            dump_dir = firmware + ".dump" if firmware else self.aw_output_path.text().strip()
            
            if not dump_dir or not os.path.isdir(dump_dir):
                QMessageBox.warning(self, "Error", 
                    "Please select a .dump directory to repack\n"
                    "(created by unpacking firmware first)")
                return
            
            self.aw_log.clear()
            self._aw_log(f"🌞 Allwinner Firmware Repacker")
            self._aw_log(f"{'='*50}")
            self._aw_log(f"Tool: {tool}")
            self._aw_log(f"Source: {dump_dir}")
            self._aw_log("")
            
            # Build command
            cmd = [tool]
            
            if self.aw_2nd_layer_cb.isChecked():
                cmd.append("/2nd")
            if self.aw_noiso_cb.isChecked():
                cmd.append("/noiso")
            
            cmd.append(dump_dir)
            
            self._aw_log(f"Command: {' '.join(cmd)}")
            self._aw_log("")
            
            self.aw_progress.setVisible(True)
            self.aw_progress.setRange(0, 0)
            self.aw_unpack_btn.setEnabled(False)
            self.aw_repack_btn.setEnabled(False)
            
            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    cwd=str(Path(tool).parent)
                )
                
                for line in process.stdout:
                    self._aw_log(line.rstrip())
                
                process.wait()
                
                if process.returncode == 0:
                    # Output is typically original name without .dump
                    output_img = dump_dir.replace(".dump", "_new.img")
                    self._aw_log("")
                    self._aw_log(f"✅ Repack complete!")
                    
                    QMessageBox.information(self, "Success",
                        f"Firmware repacked successfully!\n\n"
                        f"Check the output directory for the new firmware.")
                else:
                    self._aw_log(f"❌ Repack failed with code: {process.returncode}")
                    QMessageBox.critical(self, "Error", "Firmware repack failed!")
                    
            except Exception as e:
                self._aw_log(f"Error: {e}")
                QMessageBox.critical(self, "Error", f"Repack failed:\n{e}")
            finally:
                self.aw_progress.setVisible(False)
                self.aw_unpack_btn.setEnabled(True)
                self.aw_repack_btn.setEnabled(True)
        
        # =============================================================
        # ROCKCHIP FIRMWARE METHODS
        # =============================================================
        
        def _get_rockchip_tool(self) -> Optional[str]:
            """Find the imgRePackerRK tool."""
            base = Path(sys.executable).parent if getattr(sys, 'frozen', False) else Path(__file__).parent
            
            # Check tools folder
            tool_path = base / 'tools' / 'Rockchip' / 'imgRePackerRK.exe'
            if tool_path.exists():
                return str(tool_path)
            
            # Check if it's in PATH
            if shutil.which('imgRePackerRK.exe'):
                return shutil.which('imgRePackerRK.exe')
            
            return None
        
        def _rk_log(self, msg: str):
            """Log message to Rockchip log."""
            self.rk_log.appendPlainText(msg)
            QApplication.processEvents()
        
        def _browse_rockchip_firmware(self):
            path, _ = QFileDialog.getOpenFileName(
                self, "Select Rockchip Firmware",
                "", "Firmware Images (*.img);;All Files (*)"
            )
            if path:
                self.rk_firmware_path.setText(path)
                # Auto-set output directory
                if not self.rk_output_path.text():
                    self.rk_output_path.setText(str(Path(path).parent / (Path(path).stem + ".dump")))
        
        def _browse_rockchip_output(self):
            path = QFileDialog.getExistingDirectory(self, "Select Output Directory")
            if path:
                self.rk_output_path.setText(path)
        
        def _rockchip_unpack(self):
            """Unpack Rockchip firmware using imgRePackerRK."""
            tool = self._get_rockchip_tool()
            if not tool:
                QMessageBox.critical(self, "Error", 
                    "imgRePackerRK.exe not found!\n\n"
                    "Please ensure the tool is in:\n"
                    "tools/Rockchip/imgRePackerRK.exe")
                return
            
            firmware = self.rk_firmware_path.text().strip()
            if not firmware or not os.path.exists(firmware):
                QMessageBox.warning(self, "Error", "Please select a valid firmware file")
                return
            
            self.rk_log.clear()
            self._rk_log(f"🪨 Rockchip Firmware Unpacker")
            self._rk_log(f"{'='*50}")
            self._rk_log(f"Tool: {tool}")
            self._rk_log(f"Firmware: {firmware}")
            self._rk_log("")
            
            # Build command
            cmd = [tool]
            
            if self.rk_2nd_layer_cb.isChecked():
                cmd.append("/2nd")
            if self.rk_skip_cid_cb.isChecked():
                cmd.append("/cid")
            if not self.rk_fix_crc_cb.isChecked():
                cmd.append("/md5")
                cmd.append("/rkcrc")
            
            cmd.append(firmware)
            
            self._rk_log(f"Command: {' '.join(cmd)}")
            self._rk_log("")
            
            self.rk_progress.setVisible(True)
            self.rk_progress.setRange(0, 0)
            self.rk_unpack_btn.setEnabled(False)
            self.rk_repack_btn.setEnabled(False)
            
            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    cwd=str(Path(tool).parent)
                )
                
                for line in process.stdout:
                    self._rk_log(line.rstrip())
                
                process.wait()
                
                if process.returncode == 0:
                    dump_dir = firmware + ".dump"
                    self._rk_log("")
                    self._rk_log(f"✅ Unpack complete!")
                    self._rk_log(f"Output: {dump_dir}")
                    
                    if os.path.exists(dump_dir):
                        file_count = sum(1 for _ in Path(dump_dir).rglob('*') if _.is_file())
                        self._rk_log(f"Files extracted: {file_count}")
                        
                        QMessageBox.information(self, "Success",
                            f"Firmware unpacked successfully!\n\n"
                            f"Output: {dump_dir}\n"
                            f"Files: {file_count}")
                else:
                    self._rk_log(f"❌ Unpack failed with code: {process.returncode}")
                    QMessageBox.critical(self, "Error", "Firmware unpack failed!")
                    
            except Exception as e:
                self._rk_log(f"Error: {e}")
                QMessageBox.critical(self, "Error", f"Unpack failed:\n{e}")
            finally:
                self.rk_progress.setVisible(False)
                self.rk_unpack_btn.setEnabled(True)
                self.rk_repack_btn.setEnabled(True)
        
        def _rockchip_repack(self):
            """Repack Rockchip firmware using imgRePackerRK."""
            tool = self._get_rockchip_tool()
            if not tool:
                QMessageBox.critical(self, "Error", 
                    "imgRePackerRK.exe not found!\n\n"
                    "Please ensure the tool is in:\n"
                    "tools/Rockchip/imgRePackerRK.exe")
                return
            
            # Check for .dump directory
            firmware = self.rk_firmware_path.text().strip()
            dump_dir = firmware + ".dump" if firmware else self.rk_output_path.text().strip()
            
            if not dump_dir or not os.path.isdir(dump_dir):
                QMessageBox.warning(self, "Error", 
                    "Please select a .dump directory to repack\n"
                    "(created by unpacking firmware first)")
                return
            
            self.rk_log.clear()
            self._rk_log(f"🪨 Rockchip Firmware Repacker")
            self._rk_log(f"{'='*50}")
            self._rk_log(f"Tool: {tool}")
            self._rk_log(f"Source: {dump_dir}")
            self._rk_log("")
            
            # Build command
            cmd = [tool]
            
            if self.rk_2nd_layer_cb.isChecked():
                cmd.append("/2nd")
            if self.rk_rkaf_cb.isChecked():
                cmd.append("/rkaf")
            if self.rk_skip_cid_cb.isChecked():
                cmd.append("/cid")
            
            cmd.append(dump_dir)
            
            self._rk_log(f"Command: {' '.join(cmd)}")
            self._rk_log("")
            
            self.rk_progress.setVisible(True)
            self.rk_progress.setRange(0, 0)
            self.rk_unpack_btn.setEnabled(False)
            self.rk_repack_btn.setEnabled(False)
            
            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    cwd=str(Path(tool).parent)
                )
                
                for line in process.stdout:
                    self._rk_log(line.rstrip())
                
                process.wait()
                
                if process.returncode == 0:
                    self._rk_log("")
                    self._rk_log(f"✅ Repack complete!")
                    
                    QMessageBox.information(self, "Success",
                        f"Firmware repacked successfully!\n\n"
                        f"Check the output directory for the new firmware.")
                else:
                    self._rk_log(f"❌ Repack failed with code: {process.returncode}")
                    QMessageBox.critical(self, "Error", "Firmware repack failed!")
                    
            except Exception as e:
                self._rk_log(f"Error: {e}")
                QMessageBox.critical(self, "Error", f"Repack failed:\n{e}")
            finally:
                self.rk_progress.setVisible(False)
                self.rk_unpack_btn.setEnabled(True)
                self.rk_repack_btn.setEnabled(True)
        
        # =====================================================================
        # OPPO / OnePlus / Realme Firmware Decryption Methods
        # =====================================================================
        
        def _oppo_log(self, message: str):
            """Log message to OPPO decrypt log."""
            self.oppo_log.appendPlainText(message)
            QApplication.processEvents()
        
        def _browse_oppo_firmware(self):
            """Browse for OPPO/OnePlus firmware file."""
            path, _ = QFileDialog.getOpenFileName(
                self, "Select OPPO/OnePlus/Realme Firmware",
                "",
                "Firmware Files (*.ofp *.ops *.zip);;OPPO Firmware (*.ofp);;OnePlus Firmware (*.ops);;All Files (*.*)"
            )
            if path:
                self.oppo_firmware_path.setText(path)
                # Detect firmware type
                ext = Path(path).suffix.lower()
                if ext == '.ofp':
                    self.oppo_firmware_type.setText("📱 OPPO/Realme Firmware (.ofp) - Qualcomm or MediaTek")
                    self.oppo_firmware_type.setStyleSheet("color: #4fc3f7;")
                elif ext == '.ops':
                    self.oppo_firmware_type.setText("📱 OnePlus Firmware (.ops)")
                    self.oppo_firmware_type.setStyleSheet("color: #81c784;")
                elif ext == '.zip':
                    self.oppo_firmware_type.setText("📦 ZIP archive - may contain encrypted firmware")
                    self.oppo_firmware_type.setStyleSheet("color: #ffb74d;")
                else:
                    self.oppo_firmware_type.setText("Unknown firmware type")
                    self.oppo_firmware_type.setStyleSheet("color: #888;")
        
        def _browse_oppo_output(self):
            """Browse for output directory."""
            path = QFileDialog.getExistingDirectory(self, "Select Output Directory")
            if path:
                self.oppo_output_path.setText(path)
        
        def _oppo_decrypt(self):
            """Decrypt OPPO/OnePlus/Realme firmware."""
            firmware = self.oppo_firmware_path.text().strip()
            if not firmware or not os.path.exists(firmware):
                QMessageBox.warning(self, "Error", "Please select a valid firmware file")
                return
            
            ext = Path(firmware).suffix.lower()
            
            self.oppo_log.clear()
            self._oppo_log("📱 OPPO/OnePlus/Realme Firmware Decrypter")
            self._oppo_log("Based on bkerler's oppo_decrypt")
            self._oppo_log("=" * 50)
            self._oppo_log(f"Firmware: {firmware}")
            self._oppo_log(f"Type: {ext}")
            self._oppo_log("")
            
            # Determine output directory
            output_dir = self.oppo_output_path.text().strip()
            if not output_dir:
                output_dir = str(Path(firmware).parent / (Path(firmware).stem + "_decrypted"))
            
            self._oppo_log(f"Output: {output_dir}")
            self._oppo_log("")
            
            self.oppo_progress.setVisible(True)
            self.oppo_progress.setRange(0, 0)
            self.oppo_decrypt_btn.setEnabled(False)
            
            try:
                # Check for pycryptodome
                try:
                    from Cryptodome.Cipher import AES
                except ImportError:
                    try:
                        from Crypto.Cipher import AES
                    except ImportError:
                        QMessageBox.critical(self, "Missing Dependency",
                            "pycryptodome is required for OPPO/OnePlus decryption.\n\n"
                            "Install with: pip install pycryptodome")
                        return
                
                if ext == '.ofp':
                    self._decrypt_ofp(firmware, output_dir)
                elif ext == '.ops':
                    self._decrypt_ops(firmware, output_dir)
                elif ext == '.zip':
                    self._decrypt_oppo_zip(firmware, output_dir)
                else:
                    QMessageBox.warning(self, "Error", f"Unsupported file type: {ext}")
                    
            except Exception as e:
                self._oppo_log(f"❌ Error: {e}")
                import traceback
                self._oppo_log(traceback.format_exc())
                QMessageBox.critical(self, "Error", f"Decryption failed:\n{e}")
            finally:
                self.oppo_progress.setVisible(False)
                self.oppo_decrypt_btn.setEnabled(True)
        
        def _decrypt_oppo_zip(self, filename: str, output_dir: str):
            """Decrypt password-protected OPPO ZIP firmware."""
            import zipfile
            
            self._oppo_log("Detected ZIP file, trying known passwords...")
            
            # Known OPPO/Realme ZIP passwords
            passwords = [
                b"flash@realme$50E7F7D847732396F1582CD62DD385ED7ABB0897",
                b"flash@realme",
                b"oppo@flash",
            ]
            
            try:
                with zipfile.ZipFile(filename) as zf:
                    for pwd in passwords:
                        try:
                            # Try to read first file with this password
                            test_file = zf.namelist()[0]
                            zf.read(test_file, pwd=pwd)
                            self._oppo_log(f"✅ Password found!")
                            
                            # Extract all files
                            os.makedirs(output_dir, exist_ok=True)
                            for zfile in zf.namelist():
                                self._oppo_log(f"Extracting: {zfile}")
                                zf.extract(zfile, pwd=pwd, path=output_dir)
                            
                            file_count = len(zf.namelist())
                            self._oppo_log("")
                            self._oppo_log(f"✅ Extraction complete!")
                            self._oppo_log(f"Files extracted: {file_count}")
                            self._oppo_log(f"Output: {output_dir}")
                            
                            QMessageBox.information(self, "Success",
                                f"ZIP firmware extracted!\n\n"
                                f"Files: {file_count}\n"
                                f"Output: {output_dir}")
                            return
                        except (RuntimeError, zipfile.BadZipFile):
                            continue
                    
                    # No password worked, try without password
                    self._oppo_log("Trying without password...")
                    os.makedirs(output_dir, exist_ok=True)
                    zf.extractall(output_dir)
                    
                    self._oppo_log(f"✅ Extracted (no encryption)")
                    QMessageBox.information(self, "Success", f"ZIP extracted to:\n{output_dir}")
                    
            except Exception as e:
                self._oppo_log(f"❌ ZIP extraction failed: {e}")
                raise
        
        def _decrypt_ofp(self, filename: str, output_dir: str):
            """Decrypt OPPO .ofp firmware (Qualcomm or MTK)."""
            from Cryptodome.Cipher import AES
            import hashlib
            from struct import unpack
            import xml.etree.ElementTree as ET
            
            self._oppo_log("Analyzing .ofp firmware...")
            
            # Helper functions
            def swap(ch):
                return ((ch & 0xF) << 4) + ((ch & 0xF0) >> 4)
            
            def keyshuffle(key, hkey):
                key = bytearray(key)
                for i in range(0, 0x10, 4):
                    key[i] = swap((hkey[i] ^ key[i]))
                    key[i + 1] = swap(hkey[i + 1] ^ key[i + 1])
                    key[i + 2] = swap(hkey[i + 2] ^ key[i + 2])
                    key[i + 3] = swap(hkey[i + 3] ^ key[i + 3])
                return bytes(key)
            
            def rol(x, n, bits=32):
                n = bits - n
                mask = (2**n) - 1
                mask_bits = x & mask
                return (x >> n) | (mask_bits << (bits - n))
            
            def deobfuscate(data, mask):
                ret = bytearray()
                for i in range(len(data)):
                    v = rol((data[i] ^ mask[i]), 4, 8)
                    ret.append(v)
                return ret
            
            def mtk_shuffle(key, keylength, inp, inputlength):
                inp = bytearray(inp)
                for i in range(inputlength):
                    k = key[i % keylength]
                    h = (((inp[i] & 0xF0) >> 4) | (16 * (inp[i] & 0xF)))
                    inp[i] = k ^ h
                return bytes(inp)
            
            def mtk_shuffle2(key, keylength, inp, inputlength):
                inp = bytearray(inp)
                for i in range(inputlength):
                    tmp = key[i % keylength] ^ inp[i]
                    inp[i] = ((tmp & 0xF0) >> 4) | (16 * (tmp & 0xF))
                return bytes(inp)
            
            # Qualcomm key tables
            qc_keys = [
                ["V1.4.17/1.4.27", "27827963787265EF89D126B69A495A21", "82C50203285A2CE7D8C3E198383CE94C", "422DD5399181E223813CD8ECDF2E4D72"],
                ["V1.6.17", "E11AA7BB558A436A8375FD15DDD4651F", "77DDF6A0696841F6B74782C097835169", "A739742384A44E8BA45207AD5C3700EA"],
                ["V1.5.13", "67657963787565E837D226B69A495D21", "F6C50203515A2CE7D8C3E1F938B7E94C", "42F2D5399137E2B2813CD8ECDF2F4D72"],
                ["V1.6.6/1.6.9/1.6.17/1.6.24/1.6.26/1.7.6", "3C2D518D9BF2E4279DC758CD535147C3", "87C74A29709AC1BF2382276C4E8DF232", "598D92E967265E9BCABE2469FE4A915E"],
                ["V1.7.2", "8FB8FB261930260BE945B841AEFA9FD4", "E529E82B28F5A2F8831D860AE39E425D", "8A09DA60ED36F125D64709973372C1CF"],
                ["V2.0.3", "E8AE288C0192C54BF10C5707E9C4705B", "D64FC385DCD52A3C9B5FBA8650F92EDA", "79051FD8D8B6297E2E4559E997F63B7F"],
            ]
            
            # MTK key tables
            mtk_keys = [
                ["67657963787565E837D226B69A495D21", "F6C50203515A2CE7D8C3E1F938B7E94C", "42F2D5399137E2B2813CD8ECDF2F4D72"],
                ["9E4F32639D21357D37D226B69A495D21", "A3D8D358E42F5A9E931DD3917D9A3218", "386935399137416B67416BECF22F519A"],
                ["892D57E92A4D8A975E3C216B7C9DE189", "D26DF2D9913785B145D18C7219B89F26", "516989E4A1BFC78B365C6BC57D944391"],
                ["27827963787265EF89D126B69A495A21", "82C50203285A2CE7D8C3E198383CE94C", "422DD5399181E223813CD8ECDF2E4D72"],
                ["3C4A618D9BF2E4279DC758CD535147C3", "87B13D29709AC1BF2382276C4E8DF232", "59B7A8E967265E9BCABE2469FE4A915E"],
                ["1C3288822BF824259DC852C1733127D3", "E7918D22799181CF2312176C9E2DF298", "3247F889A7B6DECBCA3E28693E4AAAFE"],
            ]
            
            filesize = os.stat(filename).st_size
            
            # Try to detect if it's Qualcomm or MTK
            with open(filename, 'rb') as rf:
                # Check for MTK magic
                rf.seek(0)
                first_bytes = rf.read(16)
                
                # Try MTK first
                is_mtk = False
                aeskey = None
                aesiv = None
                
                for kt in mtk_keys:
                    obskey = bytearray.fromhex(kt[0])
                    encaeskey = bytearray.fromhex(kt[1])
                    encaesiv = bytearray.fromhex(kt[2])
                    test_key = hashlib.md5(mtk_shuffle2(obskey, 16, encaeskey, 16)).hexdigest()[:16].encode()
                    test_iv = hashlib.md5(mtk_shuffle2(obskey, 16, encaesiv, 16)).hexdigest()[:16].encode()
                    
                    cipher = AES.new(test_key, AES.MODE_CFB, IV=test_iv, segment_size=128)
                    dec = cipher.decrypt(first_bytes)
                    if dec[:3] == b"MMM":
                        is_mtk = True
                        aeskey = test_key
                        aesiv = test_iv
                        self._oppo_log("✅ Detected MediaTek firmware")
                        break
                
                if is_mtk:
                    self._decrypt_ofp_mtk(filename, output_dir, aeskey, aesiv)
                    return
                
                # Try Qualcomm
                self._oppo_log("Trying Qualcomm decryption...")
                
                # Find XML in footer
                pagesize = 0
                for x in [0x200, 0x1000]:
                    rf.seek(filesize - x + 0x10)
                    if unpack("<I", rf.read(4))[0] == 0x7CEF:
                        pagesize = x
                        break
                
                if pagesize == 0:
                    self._oppo_log("❌ Unknown firmware format")
                    QMessageBox.critical(self, "Error", "Unknown firmware format - neither MTK nor Qualcomm detected")
                    return
                
                # Try each Qualcomm key
                for dkey in qc_keys:
                    mc = bytearray.fromhex(dkey[1])
                    userkey = bytearray.fromhex(dkey[2])
                    ivec = bytearray.fromhex(dkey[3])
                    
                    key = hashlib.md5(deobfuscate(userkey, mc)).hexdigest()[:16].encode()
                    iv = hashlib.md5(deobfuscate(ivec, mc)).hexdigest()[:16].encode()
                    
                    # Try to decrypt XML
                    xmloffset = filesize - pagesize
                    rf.seek(xmloffset + 0x14)
                    offset = unpack("<I", rf.read(4))[0] * pagesize
                    length = unpack("<I", rf.read(4))[0]
                    if length < 200:
                        length = xmloffset - offset - 0x57
                    
                    rf.seek(offset)
                    data = rf.read(length)
                    cipher = AES.new(key, AES.MODE_CFB, iv=iv, segment_size=128)
                    dec = cipher.decrypt(data)
                    
                    if b"<?xml" in dec:
                        self._oppo_log(f"✅ Key found: {dkey[0]}")
                        self._decrypt_ofp_qc(filename, output_dir, key, iv, pagesize, dec)
                        return
                
                self._oppo_log("❌ No valid key found")
                QMessageBox.critical(self, "Error", "Could not find valid decryption key for this firmware")
        
        def _decrypt_ofp_mtk(self, filename: str, output_dir: str, aeskey: bytes, aesiv: bytes):
            """Decrypt MTK-based OPPO .ofp firmware."""
            from Cryptodome.Cipher import AES
            from struct import unpack
            
            def mtk_shuffle(key, keylength, inp, inputlength):
                inp = bytearray(inp)
                for i in range(inputlength):
                    k = key[i % keylength]
                    h = (((inp[i] & 0xF0) >> 4) | (16 * (inp[i] & 0xF)))
                    inp[i] = k ^ h
                return bytes(inp)
            
            os.makedirs(output_dir, exist_ok=True)
            
            hdrkey = bytearray(b"geyixue")
            filesize = os.stat(filename).st_size
            hdrlength = 0x6C
            
            with open(filename, 'rb') as rf:
                rf.seek(filesize - hdrlength)
                hdr = mtk_shuffle(hdrkey, len(hdrkey), bytearray(rf.read(hdrlength)), hdrlength)
                
                prjname, unknownval, reserved, cpu, flashtype, hdr2entries, prjinfo, crc = unpack("46s Q 4s 7s 5s H 32s H", hdr)
                hdr2length = hdr2entries * 0x60
                
                prjname = prjname.replace(b"\x00", b"").decode('utf-8', errors='ignore')
                prjinfo = prjinfo.replace(b"\x00", b"").decode('utf-8', errors='ignore')
                cpu = cpu.replace(b"\x00", b"").decode('utf-8', errors='ignore')
                flashtype = flashtype.replace(b"\x00", b"").decode('utf-8', errors='ignore')
                
                if prjname:
                    self._oppo_log(f"Project: {prjname}")
                if cpu:
                    self._oppo_log(f"CPU: {cpu}")
                if flashtype:
                    self._oppo_log(f"Flash: {flashtype}")
                self._oppo_log("")
                
                rf.seek(filesize - hdr2length - hdrlength)
                hdr2 = mtk_shuffle(hdrkey, len(hdrkey), bytearray(rf.read(hdr2length)), hdr2length)
                
                extracted = 0
                for i in range(len(hdr2) // 0x60):
                    name, start, length, enclength, fname, crc = unpack("<32s Q Q Q 32s Q", hdr2[i*0x60:(i*0x60)+0x60])
                    name = name.replace(b"\x00", b"").decode('utf-8', errors='ignore')
                    fname = fname.replace(b"\x00", b"").decode('utf-8', errors='ignore')
                    
                    self._oppo_log(f"Extracting: {fname}")
                    
                    out_path = os.path.join(output_dir, fname)
                    with open(out_path, 'wb') as wf:
                        if enclength > 0:
                            rf.seek(start)
                            encdata = rf.read(enclength)
                            if enclength % 16 != 0:
                                encdata += b"\x00" * (16 - (enclength % 16))
                            cipher = AES.new(aeskey, AES.MODE_CFB, IV=aesiv, segment_size=128)
                            data = cipher.decrypt(encdata)
                            wf.write(data[:enclength])
                            length -= enclength
                        
                        while length > 0:
                            size = min(0x200000, length)
                            data = rf.read(size)
                            length -= size
                            wf.write(data)
                    
                    extracted += 1
            
            self._oppo_log("")
            self._oppo_log(f"✅ Decryption complete!")
            self._oppo_log(f"Files extracted: {extracted}")
            self._oppo_log(f"Output: {output_dir}")
            
            QMessageBox.information(self, "Success",
                f"MTK firmware decrypted!\n\n"
                f"Files: {extracted}\n"
                f"Output: {output_dir}")
        
        def _decrypt_ofp_qc(self, filename: str, output_dir: str, key: bytes, iv: bytes, pagesize: int, xml_data: bytes):
            """Decrypt Qualcomm-based OPPO .ofp firmware."""
            from Cryptodome.Cipher import AES
            from struct import unpack
            import xml.etree.ElementTree as ET
            
            os.makedirs(output_dir, exist_ok=True)
            
            # Parse XML
            xml_str = xml_data[:xml_data.rfind(b">") + 1].decode('utf-8', errors='ignore')
            
            # Save XML
            xml_path = os.path.join(output_dir, "ProFile.xml")
            with open(xml_path, 'w') as f:
                f.write(xml_str)
            self._oppo_log("Saved ProFile.xml")
            
            root = ET.fromstring(xml_str)
            
            extracted = 0
            with open(filename, 'rb') as rf:
                for child in root:
                    for item in child:
                        wfilename = item.attrib.get("Path", item.attrib.get("filename", ""))
                        if not wfilename:
                            continue
                        
                        start = -1
                        if "FileOffsetInSrc" in item.attrib:
                            start = int(item.attrib["FileOffsetInSrc"]) * pagesize
                        elif "SizeInSectorInSrc" in item.attrib:
                            start = int(item.attrib["SizeInSectorInSrc"]) * pagesize
                        
                        if start == -1:
                            continue
                        
                        rlength = int(item.attrib.get("SizeInByteInSrc", 0))
                        if rlength == 0:
                            continue
                        
                        self._oppo_log(f"Extracting: {wfilename}")
                        
                        out_path = os.path.join(output_dir, wfilename)
                        os.makedirs(os.path.dirname(out_path) if os.path.dirname(out_path) else output_dir, exist_ok=True)
                        
                        # Determine if we need to decrypt or just copy
                        if child.tag in ["DigestsToSign", "ChainedTableOfDigests", "Firmware"]:
                            # Just copy
                            rf.seek(start)
                            with open(out_path, 'wb') as wf:
                                remaining = rlength
                                while remaining > 0:
                                    chunk = min(0x100000, remaining)
                                    wf.write(rf.read(chunk))
                                    remaining -= chunk
                        else:
                            # Decrypt first 256KB, copy rest
                            decryptsize = 0x40000
                            if child.tag in ["Sahara"]:
                                decryptsize = rlength
                            
                            rf.seek(start)
                            with open(out_path, 'wb') as wf:
                                size = min(decryptsize, rlength)
                                data = rf.read(size)
                                if size % 4:
                                    data += (4 - (size % 4)) * b'\x00'
                                cipher = AES.new(key, AES.MODE_CFB, iv=iv, segment_size=128)
                                outp = cipher.decrypt(data)
                                wf.write(outp[:size])
                                
                                if rlength > decryptsize:
                                    remaining = rlength - size
                                    while remaining > 0:
                                        chunk = min(0x100000, remaining)
                                        wf.write(rf.read(chunk))
                                        remaining -= chunk
                        
                        extracted += 1
            
            self._oppo_log("")
            self._oppo_log(f"✅ Decryption complete!")
            self._oppo_log(f"Files extracted: {extracted}")
            self._oppo_log(f"Output: {output_dir}")
            
            QMessageBox.information(self, "Success",
                f"Qualcomm firmware decrypted!\n\n"
                f"Files: {extracted}\n"
                f"Output: {output_dir}")
        
        def _decrypt_ops(self, filename: str, output_dir: str):
            """Decrypt OnePlus .ops firmware."""
            from Cryptodome.Cipher import AES
            from struct import unpack, pack
            import hashlib
            import xml.etree.ElementTree as ET
            
            self._oppo_log("Decrypting OnePlus .ops firmware...")
            
            # OnePlus encryption key
            key = unpack("<4I", bytes.fromhex("d1b5e39e5eea049d671dd5abd2afcbaf"))
            
            # Magic boxes for different versions
            mbox5 = bytes([0x60, 0x8a, 0x3f, 0x2d, 0x68, 0x6b, 0xd4, 0x23, 0x51, 0x0c,
                         0xd0, 0x95, 0xbb, 0x40, 0xe9, 0x76, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
            
            mbox6 = bytes([0xA4, 0x2D, 0xCF, 0xE2, 0xAD, 0x68, 0xEB, 0x52, 0x85, 0xE4,
                         0x81, 0x6B, 0xED, 0x10, 0x0B, 0x4B, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
            
            mbox4 = bytes([0x4B, 0x8C, 0x3F, 0x2E, 0xA8, 0x6B, 0xD4, 0x63, 0x51, 0x0C,
                         0xD0, 0x95, 0xBB, 0x41, 0x79, 0x76, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
            
            # S-box for custom encryption
            sbox = bytes.fromhex(
                "637c777bf26b6fc53001672bfed7ab76ca82c97dfa5947f0add4a2af9ca472c0" +
                "b7fd9326363ff7cc34a5e5f171d8311504c723c31896059a071280e2eb27b275" +
                "09832c1a1b6e5aa0523bd6b329e32f8453d100ed20fcb15b6acbbe394a4c58cf" +
                "d0efaafb434d338545f9027f503c9fa851a3408f929d38f5bcb6da2110fff3d2" +
                "cd0c13ec5f974417c4a77e3d645d197360814fdc222a908846eeb814de5e0bdb" +
                "e0323a0a4906245cc2d3ac629195e479e7c8376d8dd54ea96c56f4ea657aae08" +
                "ba78252e1ca6b4c6e8dd741f4bbd8b8a703eb5664803f60e613557b986c11d9e" +
                "e1f8981169d98e949b1e87e9ce5528df8ca1890dbfe6426841992d0fb054bb16"
            )
            
            os.makedirs(output_dir, exist_ok=True)
            
            def gsbox(offset):
                return sbox[offset >> 4] | (sbox[offset & 0xf] << 8)
            
            def key_update(iv1, asbox):
                # Complex key update - simplified version
                return iv1  # Placeholder
            
            def key_custom(inp, rkey, outlength=0, encrypt=False):
                # OnePlus custom decryption
                if len(inp) == 0:
                    return b""
                
                # This is a simplified implementation
                # The full algorithm is complex - for now, try basic XOR
                outp = bytearray(len(inp))
                for i in range(len(inp)):
                    outp[i] = inp[i] ^ (rkey[i % 16] if isinstance(rkey, (bytes, bytearray)) else (rkey[i % 4] >> ((i % 4) * 8)) & 0xFF)
                return bytes(outp)
            
            def try_extract_xml(rf, mbox):
                filesize = os.stat(filename).st_size
                rf.seek(filesize - 0x200)
                hdr = rf.read(0x200)
                
                if len(hdr) < 0x1C:
                    return None
                
                xmllength = int.from_bytes(hdr[0x18:0x1C], 'little')
                if xmllength == 0 or xmllength > filesize:
                    return None
                
                xmlpad = 0x200 - (xmllength % 0x200) if xmllength % 0x200 else 0
                rf.seek(filesize - 0x200 - (xmllength + xmlpad))
                inp = rf.read(xmllength + xmlpad)
                
                # Try simple decryption
                # The full OnePlus decryption is complex
                if b"<?xml" in inp or b"xml " in inp:
                    return inp[:xmllength]
                
                return None
            
            try:
                with open(filename, 'rb') as rf:
                    xml = None
                    mbox = mbox5
                    
                    for try_mbox in [mbox5, mbox6, mbox4]:
                        xml = try_extract_xml(rf, try_mbox)
                        if xml:
                            mbox = try_mbox
                            break
                    
                    if xml is None:
                        self._oppo_log("❌ Could not decrypt .ops file")
                        self._oppo_log("OnePlus .ops decryption requires the full oppo_decrypt tool")
                        self._oppo_log("")
                        self._oppo_log("Please download from: https://github.com/bkerler/oppo_decrypt")
                        self._oppo_log("Run: python opscrypto.py decrypt your_file.ops")
                        
                        QMessageBox.warning(self, "Complex Encryption",
                            "OnePlus .ops files use complex encryption.\n\n"
                            "Please use bkerler's oppo_decrypt tool:\n"
                            "https://github.com/bkerler/oppo_decrypt\n\n"
                            "Command: python opscrypto.py decrypt file.ops")
                        return
                    
                    # Save XML
                    xml_path = os.path.join(output_dir, "settings.xml")
                    with open(xml_path, 'wb') as wf:
                        wf.write(xml)
                    self._oppo_log("Saved settings.xml")
                    
                    # Parse and extract
                    root = ET.fromstring(xml.decode('utf-8', errors='ignore'))
                    extracted = 1  # settings.xml
                    
                    for child in root:
                        for item in child:
                            wfilename = item.attrib.get("Path", item.attrib.get("filename", ""))
                            if not wfilename:
                                continue
                            
                            start = int(item.attrib.get("FileOffsetInSrc", 0)) * 0x200
                            length = int(item.attrib.get("SizeInByteInSrc", 0))
                            
                            if length == 0:
                                continue
                            
                            self._oppo_log(f"Extracting: {wfilename}")
                            
                            out_path = os.path.join(output_dir, wfilename)
                            rf.seek(start)
                            
                            with open(out_path, 'wb') as wf:
                                remaining = length
                                while remaining > 0:
                                    chunk = min(0x100000, remaining)
                                    wf.write(rf.read(chunk))
                                    remaining -= chunk
                            
                            extracted += 1
                    
                    self._oppo_log("")
                    self._oppo_log(f"✅ Extraction complete!")
                    self._oppo_log(f"Files extracted: {extracted}")
                    self._oppo_log(f"Output: {output_dir}")
                    
                    QMessageBox.information(self, "Success",
                        f"OnePlus firmware extracted!\n\n"
                        f"Files: {extracted}\n"
                        f"Output: {output_dir}")
                    
            except Exception as e:
                self._oppo_log(f"❌ Error: {e}")
                raise
        
        def _start_image_extract(self):
            if not hasattr(self, 'current_image_path'):
                QMessageBox.warning(self, "Error", "Please analyze an image first")
                return
            
            selected = self._get_selected_image_items()
            if not selected:
                QMessageBox.warning(self, "Error", "Please select at least one item to extract")
                return
            
            output_dir = self.image_output_dir.text().strip()
            if not output_dir:
                QMessageBox.warning(self, "Error", "Please specify an output directory")
                return
            
            # Get vbmeta patching options
            disable_verity = self.disable_verity_check.isChecked()
            disable_verification = self.disable_verification_check.isChecked()
            reset_flags = self.reset_vbmeta_flags_check.isChecked()
            
            # Get signing options
            signing_options = None
            if self.resign_vbmeta_check.isChecked() and CRYPTO_AVAILABLE:
                if self.key_generate_radio.isChecked():
                    # Generate new key
                    key_size_text = self.key_size_combo.currentText()
                    key_size = int(key_size_text.replace("RSA-", ""))
                    signing_options = {
                        'mode': 'generate',
                        'key_size': key_size,
                        'save_key': self.save_key_check.isChecked()
                    }
                else:
                    # Load existing key
                    key_path = self.key_file_edit.text().strip()
                    if not key_path:
                        QMessageBox.warning(self, "Error", "Please select a private key file for signing")
                        return
                    if not os.path.exists(key_path):
                        QMessageBox.warning(self, "Error", f"Private key file not found:\n{key_path}")
                        return
                    signing_options = {
                        'mode': 'load',
                        'key_path': key_path
                    }
            
            self._set_image_mode(True)
            self.image_log_output.clear()
            
            self.image_extract_thread = ImageExtractThread(
                self.current_image_path,
                output_dir,
                self.current_image_info,
                selected,
                self.convert_sparse_check.isChecked(),
                self.extract_boot_check.isChecked(),
                disable_verity,
                disable_verification,
                reset_flags,
                signing_options
            )
            self.image_extract_thread.progress.connect(self._on_image_progress)
            self.image_extract_thread.log.connect(self._image_log)
            self.image_extract_thread.error.connect(self._on_image_error)
            self.image_extract_thread.finished.connect(self._on_image_finished)
            self.image_extract_thread.start()
        
        def _set_image_mode(self, extracting: bool):
            self.image_extract_btn.setEnabled(not extracting)
            self.image_extract_btn.setVisible(not extracting)
            self.image_cancel_btn.setEnabled(extracting)
            self.image_cancel_btn.setVisible(extracting)
            self.image_analyze_btn.setEnabled(not extracting)
            self.image_browse_btn.setEnabled(not extracting)
            self.image_path_input.setEnabled(not extracting)
            if extracting:
                self.image_progress_bar.setRange(0, 0)
        
        def _cancel_image_extract(self):
            if hasattr(self, 'image_extract_thread') and self.image_extract_thread:
                self.image_extract_thread.cancel()
                self._image_log("\nCancelling...")
        
        def _on_image_progress(self, current: int, total: int, msg: str):
            self.image_progress_bar.setRange(0, total)
            self.image_progress_bar.setValue(current)
            pct = int(current / total * 100) if total > 0 else 0
            self.image_progress_label.setText(f"{pct}%")
            self.status_bar.showMessage(msg)
        
        def _on_image_error(self, error: str):
            self._set_image_mode(False)
            self._image_log(f"\nError: {error}")
            self.status_bar.showMessage("Image extraction failed")
            QMessageBox.critical(self, "Error", f"Image extraction failed:\n{error}")
        
        def _on_image_finished(self, output_dir: str):
            self._set_image_mode(False)
            self.image_progress_bar.setValue(self.image_progress_bar.maximum())
            self.image_progress_label.setText("Complete")
            self.status_bar.showMessage("Image extraction completed!")
            
            result = QMessageBox.question(
                self, "Extraction Complete",
                f"Image extraction completed!\n\n{output_dir}\n\nOpen output folder?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if result == QMessageBox.StandardButton.Yes:
                if sys.platform == 'win32':
                    os.startfile(output_dir)
                elif sys.platform == 'darwin':
                    os.system(f'open "{output_dir}"')
                else:
                    os.system(f'xdg-open "{output_dir}"')

    class PluginUploadThread(QThread):
        """Thread for uploading plugins without blocking the UI."""
        
        finished = pyqtSignal(dict)  # Emits result dict
        progress = pyqtSignal(str)   # Emits status message
        
        def __init__(self, api, manifest: dict, file_path: str, screenshots: list = None):
            super().__init__()
            self.api = api
            self.manifest = manifest
            self.file_path = file_path
            self.screenshots = screenshots or []
        
        def run(self):
            try:
                self.progress.emit("📤 Uploading plugin file...")
                result = self.api.submit_plugin(self.manifest, self.file_path, self.screenshots)
                self.finished.emit(result)
            except Exception as e:
                self.finished.emit({'error': str(e)})

    class StoreRefreshThread(QThread):
        """Thread for refreshing store plugins without blocking the UI."""
        
        finished = pyqtSignal(list)  # Emits plugin list
        error = pyqtSignal(str)      # Emits error message
        
        def __init__(self, api):
            super().__init__()
            self.api = api
        
        def run(self):
            try:
                plugins = self.api.get_plugins()
                self.finished.emit(plugins if plugins else [])
            except Exception as e:
                self.error.emit(str(e))

    class AdminApiThread(QThread):
        """Thread for admin API calls without blocking the UI."""
        
        finished = pyqtSignal(dict)  # Emits result dict
        
        def __init__(self, api, method: str, *args):
            super().__init__()
            self.api = api
            self.method = method
            self.args = args
        
        def run(self):
            try:
                # Call the appropriate API method
                api_method = getattr(self.api, self.method, None)
                if api_method:
                    result = api_method(*self.args)
                    self.finished.emit(result)
                else:
                    self.finished.emit({'error': f'Unknown API method: {self.method}'})
            except Exception as e:
                self.finished.emit({'error': str(e)})

    class ImageExtractThread(QThread):
        """Thread for extracting Android images without blocking the UI."""
        
        progress = pyqtSignal(int, int, str)
        log = pyqtSignal(str)
        error = pyqtSignal(str)
        finished = pyqtSignal(str)
        
        def __init__(self, image_path: str, output_dir: str, image_info: dict,
                     selected_items: list[dict], convert_sparse: bool, extract_boot: bool,
                     disable_verity: bool = False, disable_verification: bool = False,
                     reset_flags: bool = False,
                     signing_options: Optional[dict] = None):
            super().__init__()
            self.image_path = image_path
            self.base_output_dir = output_dir
            self.image_info = image_info
            self.selected_items = selected_items
            self.convert_sparse = convert_sparse
            self.extract_boot = extract_boot
            self.disable_verity = disable_verity
            self.disable_verification = disable_verification
            self.reset_flags = reset_flags
            self.signing_options = signing_options
            self._cancelled = False
            
            # Create image-specific subfolder (e.g., extracted_images/boot/ for boot.img)
            image_name = Path(image_path).stem  # Get filename without extension
            self.output_dir = str(Path(output_dir) / image_name)
        
        def cancel(self):
            self._cancelled = True
        
        def run(self):
            try:
                Path(self.output_dir).mkdir(parents=True, exist_ok=True)
                image_type = self.image_info.get('type', 'raw')
                image_name = Path(self.image_path).name
                
                self.log.emit(f"Extracting {image_name} ({image_type} image)...")
                self.log.emit(f"Output folder: {self.output_dir}")
                
                if image_type == 'sparse':
                    self._extract_sparse()
                elif image_type in ('boot', 'vendor_boot'):
                    self._extract_boot()
                elif image_type == 'super':
                    self._extract_super()
                elif image_type == 'fat':
                    self._extract_fat()
                elif image_type == 'ext4':
                    self._extract_ext4()
                elif image_type == 'erofs':
                    self._extract_erofs()
                elif image_type == 'lz4':
                    self._extract_lz4()
                elif image_type == 'elf':
                    self._extract_elf()
                elif image_type == 'vbmeta':
                    self._extract_vbmeta()
                elif image_type == 'bootloader':
                    self._extract_bootloader()
                elif image_type == 'nvram':
                    self._copy_nvram()
                else:
                    self._copy_raw()
                
                if not self._cancelled:
                    self.finished.emit(self.output_dir)
                    
            except Exception as e:
                self.error.emit(str(e))
        
        def _extract_sparse(self):
            if self.convert_sparse:
                self.progress.emit(0, 1, "Converting sparse image to raw...")
                self.log.emit("Converting sparse image to raw format...")
                
                converter = SparseImageConverter()
                output_path = Path(self.output_dir) / f"{Path(self.image_path).stem}_raw.img"
                converter.convert(self.image_path, str(output_path))
                
                self.log.emit(f"Converted to: {output_path}")
                self.progress.emit(1, 1, "Conversion complete")
            else:
                self._copy_raw()
        
        def _extract_boot(self):
            if self.extract_boot:
                self.progress.emit(0, 1, "Extracting boot image components...")
                self.log.emit("Extracting kernel, ramdisk, DTB...")
                
                extractor = BootImageExtractor()
                results = extractor.extract(self.image_path, self.output_dir)
                
                for name, path in results.items():
                    self.log.emit(f"  Extracted: {name} -> {path}")
                
                self.progress.emit(1, 1, "Boot extraction complete")
            else:
                self._copy_raw()
        
        def _extract_super(self):
            self.log.emit("Extracting partitions from super image...")
            
            extractor = SuperImageExtractor()
            partition_names = [item.get('name') for item in self.selected_items if item.get('name')]
            
            self.progress.emit(0, len(partition_names), "Extracting partitions...")
            
            try:
                results = extractor.extract(self.image_path, self.output_dir, partition_names)
                
                for name, path in results.items():
                    self.log.emit(f"  Extracted: {name} -> {path}")
                
                self.progress.emit(len(results), len(results), "Super extraction complete")
            except Exception as e:
                self.log.emit(f"  Error: {e}")
                raise
        
        def _extract_fat(self):
            self.log.emit("Extracting files from FAT filesystem image...")
            
            extractor = FatImageExtractor()
            file_names = [item.get('name') for item in self.selected_items if item.get('name')]
            
            total = len(file_names) if file_names else 1
            self.progress.emit(0, total, "Extracting files...")
            
            try:
                # Extract all files if none selected, otherwise only selected
                results = extractor.extract(
                    self.image_path, 
                    self.output_dir, 
                    file_names if file_names else None
                )
                
                for name, path in results.items():
                    self.log.emit(f"  Extracted: {name}")
                
                self.log.emit(f"\nExtracted {len(results)} file(s)")
                self.progress.emit(len(results), len(results), "FAT extraction complete")
            except Exception as e:
                self.log.emit(f"  Error: {e}")
                raise
        
        def _extract_ext4(self):
            self.log.emit("Extracting files from ext4 filesystem image...")
            
            extractor = Ext4ImageExtractor()
            file_names = [item.get('name') for item in self.selected_items if item.get('name')]
            
            total = len(file_names) if file_names else 1
            self.progress.emit(0, total, "Extracting files...")
            
            try:
                # Extract all files if none selected, otherwise only selected
                results = extractor.extract(
                    self.image_path, 
                    self.output_dir, 
                    file_names if file_names else None
                )
                
                for name, path in results.items():
                    self.log.emit(f"  Extracted: {name}")
                
                self.log.emit(f"\nExtracted {len(results)} file(s)")
                self.progress.emit(len(results), len(results), "ext4 extraction complete")
            except Exception as e:
                self.log.emit(f"  Error: {e}")
                raise
        
        def _extract_erofs(self):
            self.log.emit("Extracting files from EROFS filesystem image...")
            
            extractor = ErofsImageExtractor()
            file_names = [item.get('name') for item in self.selected_items if item.get('name')]
            
            total = len(file_names) if file_names else 1
            self.progress.emit(0, total, "Extracting files from EROFS...")
            
            try:
                # Extract all files if none selected, otherwise only selected
                results = extractor.extract(
                    self.image_path, 
                    self.output_dir, 
                    file_names if file_names else None
                )
                
                file_count = len(results.get('files', {}))
                method = results.get('method', 'unknown')
                
                for name in results.get('files', {}).keys():
                    self.log.emit(f"  Extracted: {name}")
                
                # Report any errors
                for err in results.get('errors', []):
                    self.log.emit(f"  Warning: {err}")
                
                self.log.emit(f"\nExtracted {file_count} file(s) using {method}")
                self.progress.emit(file_count, file_count, "EROFS extraction complete")
            except Exception as e:
                self.log.emit(f"  Error: {e}")
                raise
        
        def _extract_lz4(self):
            self.log.emit("Decompressing LZ4 compressed image...")
            
            self.progress.emit(0, 1, "Decompressing LZ4 file...")
            
            try:
                import lz4.frame  # type: ignore
                has_lz4 = True
            except ImportError:
                has_lz4 = False
            
            if not has_lz4:
                self.log.emit("Error: lz4 module not available")
                self.log.emit("Install with: pip install lz4")
                raise ImportError("lz4 module required for LZ4 decompression")
            
            try:
                # Determine output filename
                input_name = Path(self.image_path).name
                if input_name.endswith('.lz4'):
                    output_name = input_name[:-4]  # Remove .lz4 extension
                else:
                    output_name = f"{input_name}.decompressed"
                
                output_path = Path(self.output_dir) / output_name
                
                self.log.emit(f"Input: {input_name}")
                self.log.emit(f"Output: {output_name}")
                
                # Decompress the file
                with open(self.image_path, 'rb') as f_in:
                    with lz4.frame.open(f_in, mode='rb') as lz4_file:
                        with open(output_path, 'wb') as f_out:
                            # Read and write in chunks for memory efficiency
                            chunk_size = 16 * 1024 * 1024  # 16MB chunks
                            total_written = 0
                            while True:
                                chunk = lz4_file.read(chunk_size)
                                if not chunk:
                                    break
                                f_out.write(chunk)
                                total_written += len(chunk)
                
                # Check what the decompressed file is
                decompressed_type = detect_image_type(str(output_path))
                self.log.emit(f"\nDecompressed {total_written / (1024*1024):.2f} MB")
                self.log.emit(f"Detected inner format: {decompressed_type}")
                
                # Offer hint about next step
                if decompressed_type == 'erofs':
                    self.log.emit("Hint: The decompressed file is EROFS - load it to extract contents")
                elif decompressed_type == 'ext4':
                    self.log.emit("Hint: The decompressed file is ext4 - load it to extract contents")
                elif decompressed_type == 'sparse':
                    self.log.emit("Hint: The decompressed file is sparse - load it to convert/extract")
                
                self.progress.emit(1, 1, "LZ4 decompression complete")
            except Exception as e:
                self.log.emit(f"  Error: {e}")
                raise
        
        def _extract_elf(self):
            self.log.emit("Extracting segments from ELF file...")
            self.log.emit("ELF files contain program segments (code/data for firmware).")
            
            self.progress.emit(0, 1, "Extracting ELF segments...")
            
            try:
                extractor = ElfImageExtractor(
                    self.image_path, 
                    self.output_dir
                )
                success = extractor.extract()
                
                if success:
                    self.log.emit(f"\nELF Header Info:")
                    self.log.emit(f"  Class: {extractor.header.get('class', 'Unknown')}")
                    self.log.emit(f"  Type: {extractor.header.get('type_name', 'Unknown')}")
                    self.log.emit(f"  Machine: {extractor.header.get('machine_name', 'Unknown')}")
                    self.log.emit(f"\nExtracted {len(extractor.segments)} segment(s)")
                    self.log.emit(f"See elf_info.txt for detailed segment information")
                else:
                    self.log.emit("Failed to extract ELF segments")
                
                self.progress.emit(1, 1, "ELF extraction complete")
            except Exception as e:
                self.log.emit(f"  Error: {e}")
                raise
        
        def _extract_vbmeta(self):
            self.log.emit("Processing AVB vbmeta image...")
            self.log.emit("vbmeta contains cryptographic verification data for partitions.")
            
            # Check if patching is requested
            need_patch = self.disable_verity or self.disable_verification or self.reset_flags
            need_sign = self.signing_options is not None and CRYPTO_AVAILABLE
            
            if self.reset_flags:
                self.log.emit("\n🔄 RESET FLAGS requested:")
                self.log.emit("  - Will RESET all flags to 0x00 (stock behavior)")
                self.log.emit("  - This RE-ENABLES verity and verification!")
            elif need_patch:
                self.log.emit("\n⚠️ Patching requested:")
                if self.disable_verity:
                    self.log.emit("  - Will DISABLE dm-verity")
                if self.disable_verification:
                    self.log.emit("  - Will DISABLE AVB verification")
            
            if need_sign:
                self.log.emit("\n🔐 Re-signing requested:")
                if self.signing_options.get('mode') == 'generate':
                    key_size = self.signing_options.get('key_size', 4096)
                    self.log.emit(f"  - Will generate RSA-{key_size} key")
                    if self.signing_options.get('save_key'):
                        self.log.emit(f"  - Will save generated key")
                else:
                    self.log.emit(f"  - Will use existing key: {self.signing_options.get('key_path', 'Unknown')}")
            
            self.log.emit("")
            
            total_steps = 1
            if need_patch or need_sign:
                total_steps += 1
            if need_sign and self.signing_options.get('mode') == 'generate':
                total_steps += 1  # Key generation step
            
            self.progress.emit(0, total_steps, "Parsing vbmeta...")
            
            try:
                # First, parse and extract info
                extractor = VbmetaExtractor(
                    self.image_path, 
                    self.output_dir
                )
                success = extractor.extract()
                current_step = 1
                
                if success:
                    self.log.emit(f"\nAVB vbmeta Info:")
                    self.log.emit(f"  Version: {extractor.header.get('version_major', '?')}.{extractor.header.get('version_minor', '?')}")
                    self.log.emit(f"  Algorithm: {extractor.header.get('algorithm_name', 'Unknown')}")
                    self.log.emit(f"  Rollback Index: {extractor.header.get('rollback_index', 0)}")
                    self.log.emit(f"  Original Flags: {', '.join(extractor.header.get('flags_decoded', ['Unknown']))}")
                    self.log.emit(f"  Release: {extractor.header.get('release_string', 'Unknown')}")
                    
                    self.log.emit(f"\nDescriptors ({len(extractor.descriptors)}):")
                    for desc in extractor.descriptors:
                        part_name = desc.get('partition_name', '')
                        if part_name:
                            size = desc.get('image_size', 0)
                            self.log.emit(f"  - {part_name}: {desc['tag_name']} ({size/(1024*1024):.2f} MB)")
                        elif 'cmdline' in desc:
                            self.log.emit(f"  - Kernel cmdline: {desc['cmdline'][:50]}...")
                    
                    self.log.emit(f"\nSee vbmeta_info.txt for detailed information")
                    
                    # Apply patching/signing if requested
                    if need_patch or need_sign:
                        self.log.emit("\n" + "="*50)
                        
                        # Prepare signer if needed
                        signer = None
                        if need_sign:
                            self.log.emit("Preparing AVB signing key...")
                            signer = AvbSigner()
                            
                            if self.signing_options.get('mode') == 'generate':
                                key_size = self.signing_options.get('key_size', 4096)
                                current_step += 1
                                self.progress.emit(current_step, total_steps, f"Generating RSA-{key_size} key...")
                                self.log.emit(f"Generating RSA-{key_size} key pair...")
                                
                                if not signer.generate_key(key_size):
                                    self.log.emit("❌ Failed to generate key")
                                    signer = None
                                else:
                                    self.log.emit("✅ Key generated successfully")
                                    
                                    # Save key if requested
                                    if self.signing_options.get('save_key'):
                                        key_base = Path(self.output_dir) / "avb_custom_key"
                                        priv_path = str(key_base) + ".pem"
                                        pub_path = str(key_base) + "_pub.pem"
                                        
                                        signer.save_private_key(priv_path)
                                        signer.save_public_key(pub_path)
                                        self.log.emit(f"  Private key saved: {Path(priv_path).name}")
                                        self.log.emit(f"  Public key saved: {Path(pub_path).name}")
                            else:
                                # Load existing key
                                key_path = self.signing_options.get('key_path', '')
                                self.log.emit(f"Loading private key: {Path(key_path).name}")
                                if not signer.load_private_key(key_path):
                                    self.log.emit("❌ Failed to load private key")
                                    signer = None
                                else:
                                    self.log.emit(f"✅ Loaded RSA-{signer.key_bits} key")
                        
                        current_step += 1
                        self.progress.emit(current_step, total_steps, "Patching vbmeta...")
                        
                        if self.reset_flags:
                            self.log.emit("Resetting vbmeta flags to stock...")
                        elif need_patch:
                            self.log.emit("Applying vbmeta patches...")
                        if signer:
                            self.log.emit("Re-signing with custom key...")
                        
                        patcher = VbmetaPatcher(self.image_path)
                        output_name = Path(self.image_path).stem + "_patched.img"
                        output_path = Path(self.output_dir) / output_name
                        
                        patch_result = patcher.patch(
                            str(output_path),
                            disable_verity=self.disable_verity,
                            disable_verification=self.disable_verification,
                            reset_flags=self.reset_flags,
                            signer=signer
                        )
                        
                        # Handle tuple return (success, message)
                        if isinstance(patch_result, tuple):
                            patch_success, patch_message = patch_result
                        else:
                            # Backward compatibility
                            patch_success = patch_result
                            patch_message = ""
                        
                        if patch_message:
                            self.log.emit(f"\n{patch_message}")
                        
                        if patch_success:
                            self.log.emit(f"\n✅ Patched vbmeta saved to: {output_name}")
                            
                            # Show new flags
                            new_flags = VbmetaPatcher.get_current_flags(str(output_path))
                            if 'error' not in new_flags:
                                flag_list = []
                                if new_flags['verity_disabled']:
                                    flag_list.append("VERITY_DISABLED")
                                if new_flags['verification_disabled']:
                                    flag_list.append("VERIFICATION_DISABLED")
                                flag_display = ', '.join(flag_list) if flag_list else 'NONE (stock)'
                                self.log.emit(f"  New flags: 0x{new_flags['raw_flags']:08X} ({flag_display})")
                            
                            if self.reset_flags:
                                self.log.emit("\n🔄 Flags have been RESET to 0x00.")
                                if not signer:
                                    self.log.emit("   ⚠️ Signature is INVALID - bootloader will reject unless UNLOCKED!")
                                    self.log.emit("   To truly restore stock: flash original untouched vbmeta.img")
                            elif signer:
                                self.log.emit(f"\n🔐 Image re-signed with RSA-{signer.key_bits} key")
                                self.log.emit("   Note: This will only work with:")
                                self.log.emit("   - Unlocked bootloader")
                                self.log.emit("   - Custom AVB key enrolled in bootloader")
                                self.log.emit("   - Custom ROM/recovery that doesn't verify signatures")
                            else:
                                self.log.emit("\n⚠️ Warning: The patched vbmeta signature is now invalid.")
                                self.log.emit("   Your bootloader must be UNLOCKED to use this image.")
                        elif not patch_message:
                            # Only show generic failure if no specific message was provided
                            self.log.emit("❌ Failed to patch vbmeta")
                else:
                    self.log.emit("Failed to parse vbmeta")
                
                self.progress.emit(total_steps, total_steps, "vbmeta processing complete")
            except Exception as e:
                self.log.emit(f"  Error: {e}")
                raise
        
        def _extract_bootloader(self):
            self.log.emit("Analyzing bootloader image...")
            self.log.emit("Bootloader images contain firmware for device initialization.")
            
            self.progress.emit(0, 1, "Analyzing bootloader...")
            
            try:
                analyzer = BootloaderImageAnalyzer(
                    self.image_path, 
                    self.output_dir
                )
                success = analyzer.extract()
                
                if success:
                    info = analyzer.info
                    self.log.emit(f"\nBootloader Information:")
                    self.log.emit(f"  Format: {info.get('format', 'Unknown')}")
                    self.log.emit(f"  Type: {info.get('type', 'Unknown')}")
                    if 'description' in info:
                        self.log.emit(f"  Description: {info['description']}")
                    if 'machine' in info:
                        self.log.emit(f"  Architecture: {info['machine']}")
                    if 'elf_class' in info:
                        self.log.emit(f"  Class: {info['elf_class']}")
                    if 'entry_point' in info:
                        self.log.emit(f"  Entry Point: {info['entry_point']}")
                    
                    if info.get('is_signed') or info.get('qcom_signed'):
                        self.log.emit(f"\n🔒 This image is signed (secure boot protected)")
                    
                    if 'qc_version' in info:
                        self.log.emit(f"  QC Version: {info['qc_version']}")
                    if 'build_date' in info:
                        self.log.emit(f"  Build Date: {info['build_date']}")
                    if 'build_time' in info:
                        self.log.emit(f"  Build Time: {info['build_time']}")
                    
                    if analyzer.segments:
                        self.log.emit(f"\nExtracted {len(analyzer.segments)} segment(s)")
                    
                    self.log.emit(f"\nSee bootloader_info.txt for detailed information")
                    self.log.emit("\n⚠️ Warning: Modifying bootloader images can brick your device!")
                else:
                    self.log.emit("Failed to analyze bootloader")
                
                self.progress.emit(1, 1, "Bootloader analysis complete")
            except Exception as e:
                self.log.emit(f"  Error: {e}")
                raise
        
        def _copy_nvram(self):
            """Parse and extract NVRAM/calibration partition with deep analysis."""
            import shutil
            import re
            
            src_path = Path(self.image_path).resolve()
            
            self.progress.emit(0, 100, "Analyzing NVRAM partition...")
            self.log.emit("📱 NVRAM/Calibration Partition Analysis")
            self.log.emit("━" * 50)
            
            # Get file size
            file_size = os.path.getsize(self.image_path)
            self.log.emit(f"📦 Size: {file_size:,} bytes ({file_size / 1024:.1f} KB)")
            
            # Read the entire file for analysis
            with open(self.image_path, 'rb') as f:
                data = f.read()
            
            self.progress.emit(10, 100, "Extracting strings...")
            
            # Create output directory structure
            output_base = Path(self.output_dir)
            output_base.mkdir(parents=True, exist_ok=True)
            
            extracted_items = []
            
            # ===== 1. EXTRACT READABLE STRINGS =====
            self.log.emit("\n🔤 Extracting readable strings...")
            strings_found = []
            
            # Find ASCII strings (4+ chars)
            ascii_pattern = rb'[\x20-\x7e]{4,}'
            for match in re.finditer(ascii_pattern, data):
                s = match.group().decode('ascii', errors='ignore')
                if len(s) >= 4:
                    strings_found.append((match.start(), s))
            
            # Save strings to file
            if strings_found:
                strings_file = output_base / "strings.txt"
                with open(strings_file, 'w', encoding='utf-8') as f:
                    f.write(f"# Strings extracted from {Path(self.image_path).name}\n")
                    f.write(f"# Total: {len(strings_found)} strings\n\n")
                    for offset, s in strings_found:
                        f.write(f"0x{offset:08X}: {s}\n")
                self.log.emit(f"  ✓ Found {len(strings_found)} strings → strings.txt")
                extracted_items.append(("strings.txt", len(strings_found)))
            
            self.progress.emit(25, 100, "Scanning for MAC addresses...")
            
            # ===== 2. FIND MAC ADDRESSES =====
            self.log.emit("\n📡 Scanning for MAC addresses...")
            mac_addresses = []
            
            # Look for 6-byte sequences that could be MACs
            for i in range(len(data) - 6):
                # Check if it looks like a valid MAC (not all zeros or all FF)
                mac_bytes = data[i:i+6]
                if mac_bytes != b'\x00\x00\x00\x00\x00\x00' and mac_bytes != b'\xff\xff\xff\xff\xff\xff':
                    # Check if first byte indicates a known vendor or has proper structure
                    # MAC first byte LSB=0 for unicast, bit1 indicates local/global
                    first_byte = mac_bytes[0]
                    # Skip obviously invalid (like ASCII text)
                    if not all(32 <= b <= 126 for b in mac_bytes):
                        # Check for common patterns (MediaTek, Qualcomm, etc.)
                        mac_str = ':'.join(f'{b:02X}' for b in mac_bytes)
                        # Look for context clues nearby
                        context_start = max(0, i - 20)
                        context = data[context_start:i+26].lower()
                        if b'wifi' in context or b'wlan' in context or b'bt' in context or b'bluetooth' in context or b'mac' in context:
                            mac_addresses.append((i, mac_str, "contextual"))
                        # Also check for known OUI prefixes
                        elif mac_bytes[:3] in [b'\x00\x0c\xe7', b'\x94\x65\x2d', b'\xf8\x0f\x6f',  # MTK
                                                b'\x00\x26\x08', b'\xc0\xee\xfb',  # Samsung
                                                b'\x00\x1e\x3d', b'\x40\x4e\x36']:  # Common
                            mac_addresses.append((i, mac_str, "known OUI"))
            
            if mac_addresses:
                macs_file = output_base / "mac_addresses.txt"
                with open(macs_file, 'w', encoding='utf-8') as f:
                    f.write(f"# Potential MAC addresses from {Path(self.image_path).name}\n\n")
                    for offset, mac, reason in mac_addresses[:50]:  # Limit to 50
                        f.write(f"0x{offset:08X}: {mac} ({reason})\n")
                self.log.emit(f"  ✓ Found {len(mac_addresses)} potential MACs → mac_addresses.txt")
                extracted_items.append(("mac_addresses.txt", len(mac_addresses)))
            
            self.progress.emit(40, 100, "Looking for IMEI patterns...")
            
            # ===== 3. FIND IMEI PATTERNS =====
            self.log.emit("\n📱 Scanning for IMEI patterns...")
            imei_patterns = []
            
            # IMEI is 15 digits, often stored as ASCII or BCD
            # ASCII IMEI pattern
            imei_ascii = re.findall(rb'[0-9]{15}', data)
            for imei in imei_ascii:
                imei_str = imei.decode('ascii')
                # Validate with Luhn checksum
                if self._validate_imei(imei_str):
                    offset = data.find(imei)
                    imei_patterns.append((offset, imei_str, "ASCII (valid Luhn)"))
            
            # BCD encoded IMEI (common in NVRAM)
            for i in range(len(data) - 8):
                bcd_bytes = data[i:i+8]
                # Try to decode as BCD
                try:
                    imei_str = ''.join(f'{b:02X}' for b in bcd_bytes)[:15]
                    if imei_str.isdigit() and self._validate_imei(imei_str):
                        imei_patterns.append((i, imei_str, "BCD encoded"))
                except:
                    pass
            
            if imei_patterns:
                imei_file = output_base / "imei_candidates.txt"
                with open(imei_file, 'w', encoding='utf-8') as f:
                    f.write(f"# Potential IMEI numbers from {Path(self.image_path).name}\n")
                    f.write("# ⚠️ These are candidates - verify manually\n\n")
                    seen = set()
                    for offset, imei, method in imei_patterns:
                        if imei not in seen:
                            f.write(f"0x{offset:08X}: {imei} ({method})\n")
                            seen.add(imei)
                self.log.emit(f"  ✓ Found {len(set(p[1] for p in imei_patterns))} IMEI candidates → imei_candidates.txt")
                extracted_items.append(("imei_candidates.txt", len(imei_patterns)))
            
            self.progress.emit(55, 100, "Parsing MTK NVRAM structure...")
            
            # ===== 4. PARSE MTK NVRAM STRUCTURE =====
            self.log.emit("\n🔧 Parsing MTK NVRAM structure...")
            nvram_items = self._parse_mtk_nvram(data, output_base)
            if nvram_items:
                self.log.emit(f"  ✓ Extracted {len(nvram_items)} NVRAM items")
                extracted_items.extend(nvram_items)
            
            self.progress.emit(70, 100, "Creating hex dump...")
            
            # ===== 5. HEX DUMP =====
            self.log.emit("\n📋 Creating hex dump...")
            hex_file = output_base / "hexdump.txt"
            with open(hex_file, 'w', encoding='utf-8') as f:
                f.write(f"# Hex dump of {Path(self.image_path).name}\n")
                f.write(f"# Size: {file_size:,} bytes\n\n")
                
                # Dump first 4KB in detail
                for i in range(0, min(4096, len(data)), 16):
                    hex_part = ' '.join(f'{b:02X}' for b in data[i:i+16])
                    ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in data[i:i+16])
                    f.write(f"{i:08X}  {hex_part:<48}  |{ascii_part}|\n")
                
                if len(data) > 4096:
                    f.write(f"\n... ({len(data) - 4096} more bytes) ...\n")
                    f.write(f"\n# Last 1KB:\n")
                    start = len(data) - 1024
                    for i in range(start, len(data), 16):
                        hex_part = ' '.join(f'{b:02X}' for b in data[i:i+16])
                        ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in data[i:i+16])
                        f.write(f"{i:08X}  {hex_part:<48}  |{ascii_part}|\n")
            
            self.log.emit(f"  ✓ Created hex dump → hexdump.txt")
            extracted_items.append(("hexdump.txt", 1))
            
            self.progress.emit(85, 100, "Copying original...")
            
            # ===== 6. COPY ORIGINAL =====
            dst_path = output_base / Path(self.image_path).name
            if src_path != dst_path:
                shutil.copy2(self.image_path, dst_path)
                self.log.emit(f"\n📦 Original saved → {dst_path.name}")
            
            self.progress.emit(95, 100, "Generating report...")
            
            # ===== 7. SUMMARY REPORT =====
            report_file = output_base / "analysis_report.txt"
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write("=" * 60 + "\n")
                f.write("NVRAM PARTITION ANALYSIS REPORT\n")
                f.write("=" * 60 + "\n\n")
                f.write(f"Source: {self.image_path}\n")
                f.write(f"Size: {file_size:,} bytes\n")
                f.write(f"Extracted items: {len(extracted_items)}\n\n")
                
                f.write("Files created:\n")
                for name, count in extracted_items:
                    f.write(f"  • {name}: {count} items\n")
                
                f.write("\n" + "=" * 60 + "\n")
                f.write("NOTES:\n")
                f.write("=" * 60 + "\n")
                f.write("• NVRAM contains device-specific calibration data\n")
                f.write("• MAC addresses and IMEI are often encrypted/encoded\n")
                f.write("• Use mtkclient for proper NVRAM read/write operations\n")
                f.write("• Backup is crucial - NVRAM corruption can brick device\n")
            
            self.log.emit(f"\n📊 Analysis report → analysis_report.txt")
            
            # Final summary
            self.log.emit("\n" + "━" * 50)
            self.log.emit(f"✅ Extracted {len(extracted_items)} items to {output_base}")
            self.log.emit("━" * 50)
            
            self.progress.emit(100, 100, "NVRAM analysis complete")
        
        def _validate_imei(self, imei: str) -> bool:
            """Validate IMEI using Luhn checksum."""
            if len(imei) != 15 or not imei.isdigit():
                return False
            
            total = 0
            for i, digit in enumerate(imei[:-1]):
                d = int(digit)
                if i % 2 == 1:
                    d *= 2
                    if d > 9:
                        d -= 9
                total += d
            
            check = (10 - (total % 10)) % 10
            return check == int(imei[-1])
        
        def _parse_mtk_nvram(self, data: bytes, output_dir: Path) -> list:
            """Parse MediaTek NVRAM binary structure."""
            items = []
            nvram_dir = output_dir / "nvram_items"
            
            try:
                # MTK NVRAM has various structures depending on chip/version
                # Common patterns to look for:
                
                # 1. Look for file list markers (FILELIST)
                filelist_offset = data.find(b'FILELIST')
                if filelist_offset >= 0:
                    nvram_dir.mkdir(parents=True, exist_ok=True)
                    # Extract the file list region
                    filelist_data = data[filelist_offset:filelist_offset+4096]
                    fl_file = nvram_dir / "FILELIST.bin"
                    with open(fl_file, 'wb') as f:
                        f.write(filelist_data)
                    items.append(("nvram_items/FILELIST.bin", 1))
                    self.log.emit(f"    Found FILELIST at 0x{filelist_offset:X}")
                
                # 2. Look for NVD (NV Data) markers
                nvd_markers = [b'NVD_IMEI', b'NVD_DATA', b'CALIBRAT', b'APCFG']
                for marker in nvd_markers:
                    offset = 0
                    while True:
                        pos = data.find(marker, offset)
                        if pos < 0:
                            break
                        
                        nvram_dir.mkdir(parents=True, exist_ok=True)
                        # Extract region around marker
                        region_start = pos
                        region_end = min(pos + 512, len(data))
                        region_data = data[region_start:region_end]
                        
                        marker_name = marker.decode('ascii', errors='ignore')
                        region_file = nvram_dir / f"{marker_name}_0x{pos:X}.bin"
                        with open(region_file, 'wb') as f:
                            f.write(region_data)
                        items.append((f"nvram_items/{region_file.name}", 1))
                        self.log.emit(f"    Found {marker_name} at 0x{pos:X}")
                        
                        offset = pos + len(marker)
                
                # 3. Look for common MTK partition headers
                # MTK uses 4-byte magic + size + data pattern in some cases
                i = 0
                chunk_count = 0
                while i < len(data) - 8 and chunk_count < 100:
                    # Check for potential header pattern
                    # Many MTK NVRAM items have: [2-byte ID][2-byte size][data]
                    if i + 4 < len(data):
                        potential_size = struct.unpack('<H', data[i+2:i+4])[0]
                        # Valid if size is reasonable (1 to 64KB) and doesn't overflow
                        if 1 < potential_size < 65536 and i + 4 + potential_size <= len(data):
                            item_id = struct.unpack('<H', data[i:i+2])[0]
                            # Check if this looks like a valid item (not all zeros/FF)
                            item_data = data[i+4:i+4+potential_size]
                            if item_data and item_data != b'\x00' * potential_size and item_data != b'\xff' * potential_size:
                                # Check if it contains any non-null data
                                if any(b != 0 and b != 0xff for b in item_data[:min(32, len(item_data))]):
                                    nvram_dir.mkdir(parents=True, exist_ok=True)
                                    item_file = nvram_dir / f"item_{item_id:04X}_0x{i:X}.bin"
                                    with open(item_file, 'wb') as f:
                                        f.write(item_data)
                                    items.append((f"nvram_items/{item_file.name}", potential_size))
                                    chunk_count += 1
                                    i += 4 + potential_size
                                    continue
                    i += 1
                
                if chunk_count > 0:
                    self.log.emit(f"    Extracted {chunk_count} data chunks")
                    
            except Exception as e:
                self.log.emit(f"    Warning: MTK parse error: {e}")
            
            return items
        
        def _copy_raw(self):
            """Analyze and extract data from raw/proprietary partition images."""
            import shutil
            import re
            
            src_path = Path(self.image_path).resolve()
            partition_name = Path(self.image_path).stem
            
            self.progress.emit(0, 100, "Analyzing raw partition...")
            self.log.emit(f"🔍 Raw Partition Analysis: {partition_name}")
            self.log.emit("━" * 50)
            
            # Get file size
            file_size = os.path.getsize(self.image_path)
            self.log.emit(f"📦 Size: {file_size:,} bytes ({file_size / 1024 / 1024:.2f} MB)")
            
            # Read file for analysis (limit to 100MB for memory safety)
            max_read = min(file_size, 100 * 1024 * 1024)
            with open(self.image_path, 'rb') as f:
                data = f.read(max_read)
            
            # Create output directory
            output_base = Path(self.output_dir)
            output_base.mkdir(parents=True, exist_ok=True)
            
            extracted_items = []
            
            # ===== 1. MAGIC BYTE ANALYSIS =====
            self.progress.emit(5, 100, "Detecting structure...")
            self.log.emit("\n🔬 Header Analysis:")
            
            header = data[:64]
            magic_hex = ' '.join(f'{b:02X}' for b in header[:16])
            self.log.emit(f"  First 16 bytes: {magic_hex}")
            
            # Try to identify known structures
            detected_type = self._detect_raw_structure(data[:4096])
            if detected_type:
                self.log.emit(f"  Detected: {detected_type}")
            
            # ===== 2. ENTROPY ANALYSIS =====
            self.progress.emit(10, 100, "Analyzing entropy...")
            entropy = self._calculate_entropy(data[:65536] if len(data) > 65536 else data)
            self.log.emit(f"\n📊 Entropy: {entropy:.2f}/8.00")
            if entropy > 7.5:
                self.log.emit("  ⚠️ High entropy - likely encrypted or compressed")
            elif entropy > 6.0:
                self.log.emit("  📦 Moderate entropy - may be compressed data")
            else:
                self.log.emit("  📝 Low entropy - likely contains readable data")
            
            # ===== 3. STRING EXTRACTION =====
            self.progress.emit(20, 100, "Extracting strings...")
            self.log.emit("\n🔤 Extracting strings...")
            
            strings_found = []
            ascii_pattern = rb'[\x20-\x7e]{4,}'
            for match in re.finditer(ascii_pattern, data):
                s = match.group().decode('ascii', errors='ignore')
                if len(s) >= 4:
                    strings_found.append((match.start(), s))
            
            if strings_found:
                strings_file = output_base / "strings.txt"
                with open(strings_file, 'w', encoding='utf-8') as f:
                    f.write(f"# Strings from {partition_name}\n")
                    f.write(f"# Total: {len(strings_found)}\n\n")
                    for offset, s in strings_found:
                        f.write(f"0x{offset:08X}: {s}\n")
                self.log.emit(f"  ✓ {len(strings_found)} strings → strings.txt")
                extracted_items.append(("strings.txt", len(strings_found)))
                
                # Show interesting strings
                interesting = [s for _, s in strings_found if any(kw in s.lower() for kw in 
                    ['version', 'build', 'android', 'linux', 'qualcomm', 'mtk', 'error', 'copyright'])]
                if interesting[:5]:
                    self.log.emit("  Interesting strings found:")
                    for s in interesting[:5]:
                        self.log.emit(f"    • {s[:60]}{'...' if len(s) > 60 else ''}")
            
            # ===== 4. PATTERN SCANNING =====
            self.progress.emit(40, 100, "Scanning for patterns...")
            self.log.emit("\n🎯 Pattern scanning...")
            
            # Look for embedded files by magic
            embedded = self._find_embedded_files(data, output_base)
            if embedded:
                for name, count in embedded:
                    extracted_items.append((name, count))
            
            # ===== 5. DATA SECTIONS =====
            self.progress.emit(60, 100, "Finding data sections...")
            self.log.emit("\n📁 Data sections:")
            
            sections = self._find_data_sections(data)
            if sections:
                sections_file = output_base / "sections.txt"
                with open(sections_file, 'w', encoding='utf-8') as f:
                    f.write(f"# Data sections in {partition_name}\n\n")
                    for sec_type, start, end, desc in sections:
                        f.write(f"0x{start:08X} - 0x{end:08X}: {sec_type} ({desc})\n")
                        self.log.emit(f"  • 0x{start:08X}: {sec_type} - {desc}")
                extracted_items.append(("sections.txt", len(sections)))
            else:
                self.log.emit("  No distinct sections found")
            
            # ===== 6. HEX DUMP =====
            self.progress.emit(75, 100, "Creating hex dump...")
            self.log.emit("\n📋 Creating hex dump...")
            
            hex_file = output_base / "hexdump.txt"
            with open(hex_file, 'w', encoding='utf-8') as f:
                f.write(f"# Hex dump: {partition_name}\n")
                f.write(f"# Size: {file_size:,} bytes\n\n")
                
                # First 8KB
                dump_size = min(8192, len(data))
                for i in range(0, dump_size, 16):
                    hex_part = ' '.join(f'{b:02X}' for b in data[i:i+16])
                    ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in data[i:i+16])
                    f.write(f"{i:08X}  {hex_part:<48}  |{ascii_part}|\n")
                
                if len(data) > 8192:
                    f.write(f"\n... middle omitted ...\n\n")
                    # Last 2KB
                    start = len(data) - 2048
                    for i in range(start, len(data), 16):
                        hex_part = ' '.join(f'{b:02X}' for b in data[i:i+16])
                        ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in data[i:i+16])
                        f.write(f"{i:08X}  {hex_part:<48}  |{ascii_part}|\n")
            
            self.log.emit(f"  ✓ hexdump.txt")
            extracted_items.append(("hexdump.txt", 1))
            
            # ===== 7. COPY ORIGINAL =====
            self.progress.emit(90, 100, "Copying original...")
            dst_path = output_base / Path(self.image_path).name
            if src_path != dst_path:
                shutil.copy2(self.image_path, dst_path)
                self.log.emit(f"\n📦 Original saved → {dst_path.name}")
            
            # ===== 8. REPORT =====
            self.progress.emit(95, 100, "Generating report...")
            report_file = output_base / "analysis_report.txt"
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write("=" * 60 + "\n")
                f.write(f"RAW PARTITION ANALYSIS: {partition_name}\n")
                f.write("=" * 60 + "\n\n")
                f.write(f"Source: {self.image_path}\n")
                f.write(f"Size: {file_size:,} bytes\n")
                f.write(f"Entropy: {entropy:.2f}/8.00\n")
                if detected_type:
                    f.write(f"Detected type: {detected_type}\n")
                f.write(f"\nExtracted items: {len(extracted_items)}\n")
                for name, count in extracted_items:
                    f.write(f"  • {name}\n")
            
            # Final summary
            self.log.emit("\n" + "━" * 50)
            self.log.emit(f"✅ Analysis complete: {len(extracted_items)} items extracted")
            self.log.emit("━" * 50)
            
            self.progress.emit(100, 100, "Analysis complete")
        
        def _detect_raw_structure(self, header: bytes) -> str:
            """Try to detect the structure type from header."""
            detections = []
            
            # ELF executable
            if header[:4] == b'\x7fELF':
                return "ELF executable"
            
            # Android sparse
            if header[:4] == b'\x3a\xff\x26\xed':
                return "Android sparse image"
            
            # gzip
            if header[:2] == b'\x1f\x8b':
                return "gzip compressed"
            
            # LZ4
            if header[:4] == b'\x02\x21\x4c\x18':
                return "LZ4 compressed"
            
            # XZ
            if header[:6] == b'\xfd7zXZ\x00':
                return "XZ compressed"
            
            # ZIP
            if header[:4] == b'PK\x03\x04':
                return "ZIP archive"
            
            # PE executable
            if header[:2] == b'MZ':
                return "PE executable (Windows/UEFI)"
            
            # Qualcomm SBL
            if header[:4] == b'\xd1\xdc\x4b\x84':
                return "Qualcomm SBL image"
            
            # MTK bootloader
            if b'MTK_BLOADER' in header or header[:8] == b'BFBF\x01\x00\x00\x00':
                return "MTK bootloader"
            
            # Android boot
            if header[:8] == b'ANDROID!':
                return "Android boot image"
            
            # Check for mostly zeros/padding
            null_count = header[:256].count(0)
            ff_count = header[:256].count(0xff)
            if null_count > 240:
                return "Mostly empty (zeros)"
            if ff_count > 240:
                return "Erased/empty (0xFF)"
            
            return None
        
        def _calculate_entropy(self, data: bytes) -> float:
            """Calculate Shannon entropy of data."""
            import math
            if not data:
                return 0.0
            
            freq = {}
            for byte in data:
                freq[byte] = freq.get(byte, 0) + 1
            
            entropy = 0.0
            data_len = len(data)
            for count in freq.values():
                if count > 0:
                    p = count / data_len
                    entropy -= p * math.log2(p)
            
            return entropy
        
        def _find_embedded_files(self, data: bytes, output_dir: Path) -> list:
            """Find and extract embedded files by magic signatures."""
            items = []
            embedded_dir = output_dir / "embedded"
            
            # Magic signatures to look for
            signatures = [
                (b'\x89PNG\r\n\x1a\n', 'png', 'PNG image'),
                (b'\xff\xd8\xff', 'jpg', 'JPEG image'),
                (b'GIF89a', 'gif', 'GIF image'),
                (b'GIF87a', 'gif', 'GIF image'),
                (b'PK\x03\x04', 'zip', 'ZIP archive'),
                (b'\x1f\x8b', 'gz', 'gzip compressed'),
                (b'RIFF', 'wav', 'RIFF/WAV audio'),
                (b'\x7fELF', 'elf', 'ELF executable'),
                (b'dex\n', 'dex', 'Dalvik executable'),
                (b'<?xml', 'xml', 'XML document'),
            ]
            
            found_count = 0
            for magic, ext, desc in signatures:
                offset = 0
                while True:
                    pos = data.find(magic, offset)
                    if pos < 0 or pos > len(data) - 16:
                        break
                    
                    # Found embedded file
                    if found_count == 0:
                        embedded_dir.mkdir(parents=True, exist_ok=True)
                        self.log.emit(f"  Found embedded files:")
                    
                    # Extract a reasonable chunk (up to 1MB)
                    chunk_end = min(pos + 1024 * 1024, len(data))
                    chunk = data[pos:chunk_end]
                    
                    out_file = embedded_dir / f"embedded_{pos:08X}.{ext}"
                    with open(out_file, 'wb') as f:
                        f.write(chunk)
                    
                    self.log.emit(f"    • 0x{pos:08X}: {desc}")
                    items.append((f"embedded/{out_file.name}", 1))
                    found_count += 1
                    
                    offset = pos + len(magic)
                    if found_count >= 50:  # Limit
                        break
                
                if found_count >= 50:
                    break
            
            if found_count > 0:
                self.log.emit(f"  ✓ Extracted {found_count} embedded files")
            else:
                self.log.emit("  No embedded files found")
            
            return items
        
        def _find_data_sections(self, data: bytes) -> list:
            """Identify distinct data sections in the binary."""
            sections = []
            
            # Look for transitions between data types
            window_size = 4096
            prev_type = None
            section_start = 0
            
            for i in range(0, min(len(data), 1024*1024), window_size):
                window = data[i:i+window_size]
                if not window:
                    break
                
                # Classify window
                null_pct = window.count(0) / len(window)
                ff_pct = window.count(0xff) / len(window)
                printable = sum(1 for b in window if 32 <= b < 127) / len(window)
                
                if null_pct > 0.95:
                    curr_type = "padding_null"
                    desc = "Null padding"
                elif ff_pct > 0.95:
                    curr_type = "padding_ff"
                    desc = "Erased/empty"
                elif printable > 0.8:
                    curr_type = "text"
                    desc = "Text/ASCII data"
                else:
                    curr_type = "binary"
                    desc = "Binary data"
                
                if prev_type and curr_type != prev_type:
                    sections.append((prev_type, section_start, i, f"{(i-section_start)/1024:.1f} KB"))
                    section_start = i
                
                prev_type = curr_type
            
            # Add final section
            if prev_type:
                sections.append((prev_type, section_start, len(data), f"{(len(data)-section_start)/1024:.1f} KB"))
            
            return sections

    # =========================================================================
    # PLUGIN STORE API CLIENT
    # =========================================================================

    class PluginStoreAPI:
        """API client for the Image Anarchy Plugin Store."""
        
        def __init__(self, base_url: str = None):
            self.base_url = base_url or PLUGIN_STORE_URL
            self.token = None
            self.user = None
            self._load_auth()
        
        def _load_auth(self):
            """Load saved authentication from config."""
            try:
                config_file = os.path.join(get_app_dir(), 'plugin_store_auth.json')
                if os.path.exists(config_file):
                    with open(config_file, 'r') as f:
                        data = json.load(f)
                        self.token = data.get('token')
                        self.user = data.get('user')
            except Exception:
                pass
        
        def _save_auth(self):
            """Save authentication to config."""
            try:
                config_file = os.path.join(get_app_dir(), 'plugin_store_auth.json')
                with open(config_file, 'w') as f:
                    json.dump({'token': self.token, 'user': self.user}, f)
            except Exception:
                pass
        
        def _request(self, method: str, endpoint: str, data: dict = None, files: list = None) -> dict:
            """Make an API request.
            
            Args:
                method: HTTP method (GET, POST, etc.)
                endpoint: API endpoint
                data: Dictionary of form data
                files: List of tuples: [(field_name, filename, filedata), ...]
            """
            import urllib.request
            import urllib.error
            import urllib.parse
            import hashlib
            import time
            
            url = f"{self.base_url}{endpoint}"
            headers = {
                'Content-Type': 'application/json',
                'User-Agent': 'ImageAnarchy/2.0'
            }

            # Add Cloudflare Zero Trust headers
            cf_headers = get_cf_headers()
            headers.update(cf_headers)

            # Add request signature for security
            timestamp = str(int(time.time() * 1000))
            app_secret = 'ImageAnarchy-Plugin-Store-2026'
            hourly_key = int(timestamp) // (60 * 60 * 1000)
            sig_data = f"{app_secret}:{hourly_key}:{endpoint}"
            signature = hashlib.sha256(sig_data.encode()).hexdigest()[:16]
            headers['X-App-Signature'] = signature
            headers['X-App-Timestamp'] = timestamp
            
            if self.token:
                headers['Authorization'] = f'Bearer {self.token}'
            
            try:
                if files:
                    # Multipart form upload
                    import mimetypes
                    boundary = '----WebKitFormBoundary' + str(uuid.uuid4()).replace('-', '')[:16]
                    headers['Content-Type'] = f'multipart/form-data; boundary={boundary}'
                    
                    body = b''
                    for key, value in (data or {}).items():
                        body += f'--{boundary}\r\n'.encode()
                        body += f'Content-Disposition: form-data; name="{key}"\r\n\r\n'.encode()
                        # JSON serialize lists and dicts
                        if isinstance(value, (list, dict)):
                            value = json.dumps(value)
                        body += f'{value}\r\n'.encode()
                    
                    # Support multiple files with same field name
                    for field_name, filename, filedata in files:
                        mime_type = mimetypes.guess_type(filename)[0] or 'application/octet-stream'
                        body += f'--{boundary}\r\n'.encode()
                        body += f'Content-Disposition: form-data; name="{field_name}"; filename="{filename}"\r\n'.encode()
                        body += f'Content-Type: {mime_type}\r\n\r\n'.encode()
                        body += filedata + b'\r\n'
                    
                    body += f'--{boundary}--\r\n'.encode()
                    
                    req = urllib.request.Request(url, data=body, headers=headers, method=method)
                elif data:
                    body = json.dumps(data).encode('utf-8')
                    req = urllib.request.Request(url, data=body, headers=headers, method=method)
                else:
                    if method == 'GET':
                        headers.pop('Content-Type', None)
                    req = urllib.request.Request(url, headers=headers, method=method)
                
                # Use longer timeout for uploads and admin operations
                # 10 minutes for approval (virus scanning can be slow with many binaries)
                # 5 minutes for uploads
                # 2 minutes for other admin operations
                # 30 seconds for normal API calls
                if '/admin/approve' in endpoint:
                    request_timeout = 600  # 10 minutes for approval with virus scanning
                elif files:
                    request_timeout = 300  # 5 minutes for uploads
                elif '/admin/' in endpoint:
                    request_timeout = 120  # 2 minutes for admin operations
                else:
                    request_timeout = 30   # 30 seconds for normal API calls
                    
                with urllib.request.urlopen(req, timeout=request_timeout) as response:
                    return json.loads(response.read().decode('utf-8'))
                    
            except urllib.error.HTTPError as e:
                try:
                    error_body = json.loads(e.read().decode('utf-8'))
                    return {'error': error_body.get('error', str(e))}
                except:
                    return {'error': str(e)}
            except urllib.error.URLError as e:
                return {'error': f'Connection failed: {e.reason}'}
            except Exception as e:
                return {'error': str(e)}
        
        def get_plugins(self, category: str = None, search: str = None) -> list:
            """Get list of approved plugins from the store."""
            endpoint = '/api/plugins'
            if search:
                endpoint = f'/api/search?q={urllib.parse.quote(search)}'
            elif category:
                endpoint = f'/api/plugins?category={urllib.parse.quote(category)}'
            
            result = self._request('GET', endpoint)
            if 'error' in result:
                return []
            return result.get('plugins', result) if isinstance(result, dict) else result
        
        def get_plugin(self, plugin_id: str) -> dict:
            """Get plugin details."""
            return self._request('GET', f'/api/plugins/{plugin_id}')
        
        def get_categories(self) -> list:
            """Get list of categories."""
            result = self._request('GET', '/api/categories')
            return result.get('categories', []) if isinstance(result, dict) else []
        
        def download_plugin(self, plugin_id: str, save_path: str) -> tuple:
            """Download a plugin zip file.
            
            Returns:
                tuple: (success: bool, message: str)
            """
            import urllib.request
            import urllib.error
            
            url = f"{self.base_url}/api/plugins/{plugin_id}/download"
            
            try:
                req = urllib.request.Request(url)
                req.add_header('User-Agent', 'ImageAnarchy/2.0')
                # Add Cloudflare Zero Trust headers
                for key, value in get_cf_headers().items():
                    req.add_header(key, value)
                with urllib.request.urlopen(req, timeout=60) as response:
                    with open(save_path, 'wb') as f:
                        f.write(response.read())
                return True, save_path
            except Exception as e:
                return False, str(e)
        
        def register(self, username: str, email: str, password: str) -> dict:
            """Register a new developer account."""
            result = self._request('POST', '/api/auth/register', {
                'username': username,
                'email': email,
                'password': password
            })
            
            if 'token' in result:
                self.token = result['token']
                self.user = result.get('user', {'username': username})
                self._save_auth()
            
            return result
        
        def login(self, username: str, password: str) -> dict:
            """Login to developer account."""
            result = self._request('POST', '/api/auth/login', {
                'username': username,
                'password': password
            })
            
            if 'token' in result:
                self.token = result['token']
                self.user = result.get('user', {'username': username})
                self._save_auth()
            
            return result
        
        def logout(self):
            """Logout and clear saved auth."""
            self.token = None
            self.user = None
            try:
                config_file = os.path.join(get_app_dir(), 'plugin_store_auth.json')
                if os.path.exists(config_file):
                    os.remove(config_file)
            except Exception:
                pass
        
        def is_logged_in(self) -> bool:
            """Check if user is logged in."""
            return self.token is not None
        
        def submit_plugin(self, manifest: dict, zip_path: str, screenshots: list = None) -> dict:
            """Submit a plugin to the store with optional screenshots."""
            if not self.token:
                return {'error': 'Not logged in'}
            
            with open(zip_path, 'rb') as f:
                zip_data = f.read()
            
            # Build files list: [(field_name, filename, data), ...]
            files = [('plugin', os.path.basename(zip_path), zip_data)]
            
            # Add screenshots
            if screenshots:
                for ss_path in screenshots:
                    if os.path.exists(ss_path):
                        with open(ss_path, 'rb') as ss_file:
                            ss_data = ss_file.read()
                            files.append(('screenshots', os.path.basename(ss_path), ss_data))
            
            result = self._request('POST', '/api/plugins/submit', manifest, files)
            
            # Return screenshot count and external deps count in result
            if 'error' not in result:
                result['screenshots'] = len(screenshots) if screenshots else 0
                result['external_deps'] = len(manifest.get('external_dependencies', []))
            
            return result
        
        # =====================================================================
        # Feedback, Rating & Bug Report API Methods
        # =====================================================================
        
        def get_feedback(self, plugin_id: str) -> dict:
            """Get feedback and ratings for a plugin."""
            return self._request('GET', f'/api/plugins/{plugin_id}/feedback')
        
        def submit_rating(self, plugin_id: str, rating: int, comment: str = None) -> dict:
            """Submit a rating for a plugin (requires login)."""
            if not self.token:
                return {'error': 'Not logged in'}
            data = {'rating': rating}
            if comment:
                data['comment'] = comment
            return self._request('POST', f'/api/plugins/{plugin_id}/rate', data)
        
        def submit_feedback(self, plugin_id: str, content: str) -> dict:
            """Submit feedback for a plugin (requires login)."""
            if not self.token:
                return {'error': 'Not logged in'}
            return self._request('POST', f'/api/plugins/{plugin_id}/feedback', {'content': content})
        
        def submit_bug_report(self, plugin_id: str, content: str, email: str = None, 
                              name: str = None, captcha_answer: str = None) -> dict:
            """Submit a bug report for a plugin (no login required)."""
            data = {
                'content': content,
                'captchaAnswer': captcha_answer or ''
            }
            if email:
                data['email'] = email
            if name:
                data['name'] = name
            return self._request('POST', f'/api/plugins/{plugin_id}/bug-report', data)
        
        def get_bug_reports(self, plugin_id: str) -> dict:
            """Get bug reports for a plugin (plugin author only)."""
            if not self.token:
                return {'error': 'Not logged in'}
            return self._request('GET', f'/api/plugins/{plugin_id}/bugs')
        
        def respond_to_bug(self, bug_id: int, response: str, status: str = 'in-progress') -> dict:
            """Respond to a bug report (plugin author only)."""
            if not self.token:
                return {'error': 'Not logged in'}
            return self._request('POST', f'/api/bugs/{bug_id}/respond', {
                'response': response,
                'status': status
            })
        
        # =====================================================================
        # Admin API Methods
        # =====================================================================
        
        def get_pending_plugins(self) -> dict:
            """Get list of pending plugins (admin only)."""
            return self._request('GET', '/api/admin/pending')
        
        def get_all_admin_plugins(self) -> dict:
            """Get all plugins for admin view."""
            return self._request('GET', '/api/admin/plugins')
        
        def approve_plugin(self, plugin_id: str) -> dict:
            """Approve a pending plugin (admin only)."""
            return self._request('POST', f'/api/admin/approve/{plugin_id}')
        
        def get_approve_progress(self, plugin_id: str) -> dict:
            """Get approval progress for a plugin (admin only)."""
            return self._request('GET', f'/api/admin/approve-progress/{plugin_id}')
        
        def reject_plugin(self, plugin_id: str, reason: str = "") -> dict:
            """Reject a pending plugin (admin only)."""
            return self._request('POST', f'/api/admin/reject/{plugin_id}', {'reason': reason})
        
        def delete_plugin(self, plugin_id: str) -> dict:
            """Delete a plugin (admin only)."""
            return self._request('DELETE', f'/api/admin/plugins/{plugin_id}')
        
        def get_plugin_review_details(self, plugin_id: str) -> dict:
            """Get detailed plugin info for admin review (admin only)."""
            return self._request('GET', f'/api/admin/review/{plugin_id}')
        
        # =====================================================================
        # Security Admin API Methods
        # =====================================================================
        
        def get_security_logs(self, limit: int = 100, offset: int = 0, event_type: str = None) -> dict:
            """Get security event logs (admin only)."""
            endpoint = f'/api/admin/security/logs?limit={limit}&offset={offset}'
            if event_type:
                endpoint += f'&type={event_type}'
            return self._request('GET', endpoint)
        
        def get_security_scans(self, limit: int = 100, threats_only: bool = False) -> dict:
            """Get scan results (admin only)."""
            endpoint = f'/api/admin/security/scans?limit={limit}'
            if threats_only:
                endpoint += '&threats=true'
            return self._request('GET', endpoint)
        
        def get_quarantine_files(self) -> dict:
            """Get list of quarantined files (admin only)."""
            return self._request('GET', '/api/admin/security/quarantine')
        
        def delete_quarantine_file(self, filename: str) -> dict:
            """Delete a quarantined file (admin only)."""
            return self._request('DELETE', f'/api/admin/security/quarantine/{filename}')
        
        def trigger_security_scan(self, plugin_id: str) -> dict:
            """Manually trigger a security scan on a plugin (admin only)."""
            return self._request('POST', f'/api/admin/security/scan/{plugin_id}')
        
        def get_security_status(self) -> dict:
            """Get security configuration status (admin only)."""
            return self._request('GET', '/api/admin/security/status')
        
        # =====================================================================
        # IP Banning Admin API Methods
        # =====================================================================
        
        def get_banned_ips(self) -> dict:
            """Get list of banned and suspicious IPs (admin only)."""
            return self._request('GET', '/api/admin/banned-ips')
        
        def ban_ip(self, ip: str, reason: str = "Banned by admin", permanent: bool = False) -> dict:
            """Ban an IP address (admin only)."""
            return self._request('POST', '/api/admin/ban-ip', {
                'ip': ip,
                'reason': reason,
                'permanent': permanent
            })
        
        def unban_ip(self, ip: str) -> dict:
            """Unban an IP address (admin only)."""
            return self._request('POST', '/api/admin/unban-ip', {'ip': ip})
        
        # =====================================================================
        # App Updates Admin API Methods
        # =====================================================================
        
        def get_app_versions(self) -> dict:
            """Get list of published app versions (admin only)."""
            return self._request('GET', '/api/admin/updates/list')
        
        def publish_app_update(self, version: str, changelog: str, file_data: bytes, 
                               filename: str, is_critical: bool = False,
                               progress_callback=None) -> dict:
            """Publish a new app update (admin only) with chunked upload for large files.
            
            Due to Cloudflare Zero Trust limits (~100MB per request), files larger than 
            45MB are uploaded in chunks and reassembled server-side.
            """
            import hashlib
            
            CHUNK_SIZE = 45 * 1024 * 1024  # 45MB chunks (under CF limit)
            file_size = len(file_data)
            
            # If file is small enough, use single request
            if file_size <= CHUNK_SIZE:
                if progress_callback:
                    progress_callback(50, "Uploading file...")
                data = {
                    'version': version,
                    'changelog': changelog,
                    'is_critical': is_critical
                }
                files = [('file', filename, file_data)]
                result = self._request('POST', '/api/admin/updates/publish', data, files)
                if progress_callback:
                    progress_callback(100, "Complete")
                return result
            
            # Large file: use chunked upload
            total_chunks = (file_size + CHUNK_SIZE - 1) // CHUNK_SIZE
            
            if progress_callback:
                progress_callback(2, f"Initializing chunked upload ({total_chunks} chunks)...")
            
            # Step 1: Initialize upload session
            init_result = self._request(
                'POST',
                '/api/admin/updates/upload/init',
                data={
                    'filename': filename,
                    'fileSize': str(file_size),
                    'totalChunks': str(total_chunks),
                    'version': version,
                    'changelog': changelog,
                    'is_critical': 'true' if is_critical else 'false',
                    'platform': 'windows'
                }
            )
            
            if 'error' in init_result:
                return {'error': f"Init failed: {init_result['error']}"}
            
            upload_id = init_result.get('uploadId')
            if not upload_id:
                return {'error': 'Server did not return uploadId'}
            
            if progress_callback:
                progress_callback(5, f"Upload session started: {upload_id[:8]}...")
            
            # Step 2: Upload each chunk
            for chunk_num in range(total_chunks):
                start = chunk_num * CHUNK_SIZE
                end = min(start + CHUNK_SIZE, file_size)
                chunk_data = file_data[start:end]
                
                if progress_callback:
                    pct = 5 + int((chunk_num / total_chunks) * 85)  # 5-90%
                    progress_callback(pct, f"Uploading chunk {chunk_num + 1}/{total_chunks}...")
                
                # Upload this chunk - server expects 'chunkIndex' (0-based) and 'uploadId'
                chunk_result = self._request(
                    'POST', 
                    '/api/admin/updates/upload/chunk',
                    data={
                        'uploadId': upload_id,
                        'chunkIndex': str(chunk_num)
                    },
                    files=[('chunk', f'chunk_{chunk_num}', chunk_data)]
                )
                
                if 'error' in chunk_result:
                    return {'error': f"Chunk {chunk_num + 1} failed: {chunk_result['error']}"}
            
            if progress_callback:
                progress_callback(92, "Finalizing upload...")
            
            # Step 3: Complete - tell server to reassemble chunks and publish
            complete_result = self._request(
                'POST',
                '/api/admin/updates/upload/complete',
                data={
                    'uploadId': upload_id
                }
            )
            
            if progress_callback:
                progress_callback(100, "Complete")
            
            return complete_result
        
        def toggle_version_publish(self, version: str, publish: bool) -> dict:
            """Toggle publish status of an app version (admin only)."""
            action = 'publish' if publish else 'unpublish'
            return self._request('POST', f'/api/admin/updates/{action}/{version}')
        
        def delete_app_version(self, version: str) -> dict:
            """Delete an app version (admin only)."""
            return self._request('DELETE', f'/api/admin/updates/{version}')
        
        def get_update_stats(self) -> dict:
            """Get update statistics (admin only)."""
            return self._request('GET', '/api/admin/updates/stats')
        
        def get_update_logs(self, limit: int = 100, event_type: str = None) -> dict:
            """Get update logs (admin only)."""
            endpoint = f'/api/admin/updates/logs?limit={limit}'
            if event_type:
                endpoint += f'&event_type={event_type}'
            return self._request('GET', endpoint)
        
        def clear_old_logs(self, older_than_days: int) -> dict:
            """Clear logs older than specified days (admin only)."""
            return self._request('DELETE', f'/api/admin/updates/logs?older_than_days={older_than_days}')
    
    # Global plugin store API instance
    plugin_store_api = PluginStoreAPI()

    # =========================================================================
    # VISUAL PLUGIN MAKER - TOOL DETECTION & DRAGGABLE BLOCK CLASSES
    # =========================================================================

    class ToolDetector:
        """Scans environment for available tools, plugins, and capabilities."""

        _instance = None
        _cache = None
        _cache_time = 0

        def __new__(cls):
            if cls._instance is None:
                cls._instance = super().__new__(cls)
            return cls._instance

        def scan(self, force_refresh: bool = False) -> dict:
            """Scan for available tools and return availability dict."""
            import time
            import sys
            # Cache for 30 seconds
            if not force_refresh and self._cache and (time.time() - self._cache_time) < 30:
                return self._cache

            # Handle PyInstaller frozen exe - tools are next to exe, not in _MEIPASS
            if getattr(sys, 'frozen', False):
                app_dir = os.path.dirname(sys.executable)
            else:
                app_dir = os.path.dirname(os.path.abspath(__file__))
            tools_dir = os.path.join(app_dir, 'tools')
            plugins_dir = os.path.join(app_dir, 'plugins')

            availability = {
                # Built-in (always available)
                'payload_extract': True,
                'payload_repack': True,
                'super_extract': True,
                'boot_analyze': True,
                'oppo_decrypt': True,

                # Tools folder
                'erofs_extract': os.path.exists(os.path.join(tools_dir, 'extract.erofs.exe')),
                'erofs_create': os.path.exists(os.path.join(tools_dir, 'mkfs.erofs.exe')),
                'erofs_fsck': os.path.exists(os.path.join(tools_dir, 'fsck.erofs.exe')),
                'allwinner_unpack': os.path.exists(os.path.join(tools_dir, 'Allwinner', 'imgRePacker.exe')),
                'allwinner_repack': os.path.exists(os.path.join(tools_dir, 'Allwinner', 'imgRePacker.exe')),
                'rockchip_unpack': os.path.exists(os.path.join(tools_dir, 'Rockchip', 'imgRePackerRK.exe')),
                'rockchip_repack': os.path.exists(os.path.join(tools_dir, 'Rockchip', 'imgRePackerRK.exe')),

                # Installed plugins
                'adb_toolkit': os.path.exists(os.path.join(plugins_dir, 'adb_toolkit', 'manifest.json')),
                'fastboot_toolkit': os.path.exists(os.path.join(plugins_dir, 'fastboot_toolkit', 'manifest.json')),
                'mtk_toolkit': os.path.exists(os.path.join(plugins_dir, 'mtk_toolkit', 'manifest.json')),
                'scrcpy_toolkit': os.path.exists(os.path.join(plugins_dir, 'scrcpy_toolkit', 'manifest.json')),
            }

            self._cache = availability
            self._cache_time = time.time()
            return availability

        def is_available(self, tool_id: str) -> bool:
            """Check if a specific tool is available."""
            return self.scan().get(tool_id, False)

        def get_install_hint(self, tool_id: str) -> str:
            """Get hint for how to install a missing tool."""
            hints = {
                'erofs_extract': 'EROFS tools bundled with Image Anarchy',
                'erofs_create': 'EROFS tools bundled with Image Anarchy',
                'allwinner_unpack': 'Allwinner tools in tools/Allwinner/',
                'rockchip_unpack': 'Rockchip tools in tools/Rockchip/',
                'adb_toolkit': 'Install from Plugin Store',
                'fastboot_toolkit': 'Install from Plugin Store',
                'mtk_toolkit': 'Install from Plugin Store',
                'scrcpy_toolkit': 'Install from Plugin Store',
            }
            return hints.get(tool_id, 'Check tools/ folder or Plugin Store')

    # Global detector instance
    tool_detector = ToolDetector()


    class PluginBlock(QFrame):
        """Base class for draggable plugin building blocks."""

        block_selected = pyqtSignal(object)  # Emitted when block is selected
        block_deleted = pyqtSignal(object)   # Emitted when block is deleted
        block_changed = pyqtSignal()         # Emitted when block data changes

        # Block categories for organization
        BLOCK_CATEGORIES = {
            'dependencies': ('📦 Dependencies', 'Setup requirements for your plugin'),
            'builtin': ('🔧 Built-in Tools', 'Core Image Anarchy functions'),
            'tools': ('🛠️ External Tools', 'Tools from tools/ folder'),
            'plugins': ('🔌 Plugin Tools', 'Functions from installed plugins'),
            'ui': ('🖥️ UI Elements', 'Visual components for your plugin'),
        }

        # Extended block types: (icon, name, color, tooltip, category, requires_tool)
        BLOCK_TYPES = {
            # === DEPENDENCIES ===
            'pip': ('📦', 'Pip Package', '#4caf50', 'Install a Python package from PyPI', 'dependencies', None),
            'git': ('📥', 'Git Clone', '#2196f3', 'Clone a Git repository', 'dependencies', None),
            'binary': ('⬇️', 'Binary Download', '#ff9800', 'Download a binary file from URL', 'dependencies', None),
            'command': ('⚙️', 'Setup Command', '#9c27b0', 'Run a command after installation', 'dependencies', None),
            'driver': ('🔌', 'Driver Install', '#f44336', 'Install a driver (Windows)', 'dependencies', None),

            # === BUILT-IN TOOLS (always available) ===
            'extract_payload': ('📤', 'Extract Payload', '#8bc34a', 'Extract payload.bin from OTA', 'builtin', 'payload_extract'),
            'repack_payload': ('📥', 'Repack Payload', '#689f38', 'Create payload.bin from images', 'builtin', 'payload_repack'),
            'extract_super': ('💿', 'Extract Super', '#03a9f4', 'Extract super.img partitions', 'builtin', 'super_extract'),
            'analyze_boot': ('🔍', 'Analyze Boot', '#00bcd4', 'Analyze boot/recovery image', 'builtin', 'boot_analyze'),
            'decrypt_oppo': ('🔓', 'OPPO Decrypt', '#ff5722', 'Decrypt OPPO/OnePlus firmware', 'builtin', 'oppo_decrypt'),

            # === EXTERNAL TOOLS ===
            'erofs_extract': ('📂', 'EROFS Extract', '#7c4dff', 'Extract EROFS filesystem', 'tools', 'erofs_extract'),
            'erofs_create': ('💾', 'EROFS Create', '#651fff', 'Create EROFS filesystem', 'tools', 'erofs_create'),
            'allwinner_unpack': ('🌞', 'Allwinner Unpack', '#ffc107', 'Unpack Allwinner firmware', 'tools', 'allwinner_unpack'),
            'allwinner_repack': ('🌞', 'Allwinner Repack', '#ffb300', 'Repack Allwinner firmware', 'tools', 'allwinner_repack'),
            'rockchip_unpack': ('🪨', 'Rockchip Unpack', '#795548', 'Unpack Rockchip firmware', 'tools', 'rockchip_unpack'),
            'rockchip_repack': ('🪨', 'Rockchip Repack', '#6d4c41', 'Repack Rockchip firmware', 'tools', 'rockchip_repack'),

            # === PLUGIN TOOLS ===
            'adb_command': ('📱', 'ADB Command', '#4caf50', 'Run ADB shell command', 'plugins', 'adb_toolkit'),
            'adb_pull': ('📥', 'ADB Pull', '#388e3c', 'Pull file from device', 'plugins', 'adb_toolkit'),
            'adb_push': ('📤', 'ADB Push', '#2e7d32', 'Push file to device', 'plugins', 'adb_toolkit'),
            'adb_install': ('📲', 'ADB Install', '#1b5e20', 'Install APK on device', 'plugins', 'adb_toolkit'),
            'fastboot_flash': ('⚡', 'Fastboot Flash', '#ff9800', 'Flash partition via fastboot', 'plugins', 'fastboot_toolkit'),
            'fastboot_boot': ('🚀', 'Fastboot Boot', '#f57c00', 'Boot image via fastboot', 'plugins', 'fastboot_toolkit'),
            'fastboot_erase': ('🗑️', 'Fastboot Erase', '#ef6c00', 'Erase partition via fastboot', 'plugins', 'fastboot_toolkit'),
            'mtk_read': ('📖', 'MTK Read', '#9c27b0', 'Read partition from MTK device', 'plugins', 'mtk_toolkit'),
            'mtk_write': ('✏️', 'MTK Write', '#7b1fa2', 'Write partition to MTK device', 'plugins', 'mtk_toolkit'),
            'mtk_erase': ('🧹', 'MTK Erase', '#6a1b9a', 'Erase partition on MTK device', 'plugins', 'mtk_toolkit'),
            'scrcpy_mirror': ('📺', 'Scrcpy Mirror', '#2196f3', 'Mirror device screen', 'plugins', 'scrcpy_toolkit'),
            'scrcpy_record': ('🎬', 'Scrcpy Record', '#1976d2', 'Record device screen', 'plugins', 'scrcpy_toolkit'),

            # === UI ELEMENTS - Basic ===
            'button': ('🔘', 'Button', '#e91e63', 'Add a clickable button', 'ui', None),
            'label': ('🏷️', 'Label', '#00bcd4', 'Add a text label', 'ui', None),
            'input': ('📝', 'Text Input', '#795548', 'Add a text input field', 'ui', None),
            'text_area': ('📄', 'Text Area', '#8d6e63', 'Multi-line text input', 'ui', None),
            'dropdown': ('📋', 'Dropdown', '#607d8b', 'Add a dropdown selector', 'ui', None),
            'file_picker': ('📁', 'File Picker', '#9e9e9e', 'Add a file selection button', 'ui', None),
            'folder_picker': ('📂', 'Folder Picker', '#757575', 'Add a folder selection button', 'ui', None),
            'log_output': ('📜', 'Log Output', '#455a64', 'Add a log/output text area', 'ui', None),
            'progress_bar': ('📊', 'Progress Bar', '#546e7a', 'Add a progress indicator', 'ui', None),

            # === UI ELEMENTS - Controls ===
            'checkbox': ('☑️', 'Checkbox', '#4caf50', 'Add a checkbox toggle', 'ui', None),
            'radio': ('🔘', 'Radio Button', '#2196f3', 'Add a radio button option', 'ui', None),
            'spinbox': ('🔢', 'Number Input', '#ff9800', 'Add a numeric spinner', 'ui', None),
            'slider': ('🎚️', 'Slider', '#9c27b0', 'Add a value slider', 'ui', None),
            'switch': ('🔀', 'Toggle Switch', '#00bcd4', 'Add an on/off toggle', 'ui', None),

            # === UI ELEMENTS - Containers ===
            'group_box': ('📦', 'Group Box', '#3f51b5', 'Group related controls', 'ui', None),
            'tab_panel': ('📑', 'Tab Panel', '#673ab7', 'Add tabbed sections', 'ui', None),
            'scroll_area': ('📜', 'Scroll Area', '#009688', 'Scrollable container', 'ui', None),
            'splitter': ('↔️', 'Splitter', '#795548', 'Resizable split view', 'ui', None),

            # === UI ELEMENTS - Data Display ===
            'table': ('📊', 'Table', '#ff5722', 'Add a data table', 'ui', None),
            'tree': ('🌳', 'Tree View', '#8bc34a', 'Hierarchical data view', 'ui', None),
            'list_widget': ('📋', 'List View', '#03a9f4', 'Simple list display', 'ui', None),
            'image_display': ('🖼️', 'Image Display', '#e91e63', 'Show an image', 'ui', None),

            # === UI ELEMENTS - Layout ===
            'separator': ('➖', 'Separator', '#616161', 'Visual divider line', 'ui', None),
            'spacer': ('⬜', 'Spacer', '#9e9e9e', 'Add empty space', 'ui', None),
            'horizontal_layout': ('↔️', 'Horizontal Layout', '#607d8b', 'Arrange items horizontally', 'ui', None),
            'vertical_layout': ('↕️', 'Vertical Layout', '#546e7a', 'Arrange items vertically', 'ui', None),
        }

        @classmethod
        def get_blocks_by_category(cls, category: str) -> list:
            """Get all block types in a category."""
            return [bt for bt, info in cls.BLOCK_TYPES.items() if info[4] == category]

        @classmethod
        def is_block_available(cls, block_type: str) -> bool:
            """Check if a block type is available based on tool requirements."""
            info = cls.BLOCK_TYPES.get(block_type)
            if not info:
                return False
            requires = info[5]  # requires_tool field
            if requires is None:
                return True
            return tool_detector.is_available(requires)

        def __init__(self, block_type: str, parent=None, check_availability: bool = True):
            super().__init__(parent)
            self.block_type = block_type
            self.block_data = {}
            self._selected = False

            info = self.BLOCK_TYPES.get(block_type, ('❓', 'Unknown', '#666', '', 'ui', None))
            self.icon = info[0]
            self.display_name = info[1]
            self.color = info[2]
            self.tooltip = info[3]
            self.category = info[4]
            self.requires_tool = info[5]

            # Check availability
            self._available = True
            if check_availability and self.requires_tool:
                self._available = tool_detector.is_available(self.requires_tool)
                if not self._available:
                    hint = tool_detector.get_install_hint(self.requires_tool)
                    self.tooltip = f"🔒 {self.tooltip}\n\n⚠️ Requires: {hint}"

            self._setup_ui()
            self.setToolTip(self.tooltip)

        def _setup_ui(self):
            self.setFixedHeight(44)
            self.setMinimumWidth(160)

            if self._available:
                self.setCursor(Qt.CursorShape.OpenHandCursor)
            else:
                self.setCursor(Qt.CursorShape.ForbiddenCursor)

            self._update_style()

            layout = QHBoxLayout(self)
            layout.setContentsMargins(10, 6, 10, 6)
            layout.setSpacing(8)

            # Lock icon for unavailable blocks
            if not self._available:
                lock_label = QLabel("🔒")
                lock_label.setStyleSheet("font-size: 12px; background: transparent;")
                layout.addWidget(lock_label)

            icon_label = QLabel(self.icon)
            icon_label.setStyleSheet("font-size: 16px; background: transparent;")
            layout.addWidget(icon_label)

            self.name_label = QLabel(self.display_name)
            text_color = "white" if self._available else "#888"
            self.name_label.setStyleSheet(f"font-weight: bold; color: {text_color}; background: transparent;")
            layout.addWidget(self.name_label)

            layout.addStretch()

            # Delete button (only in canvas, not palette)
            self.delete_btn = QPushButton("×")
            self.delete_btn.setFixedSize(20, 20)
            self.delete_btn.setStyleSheet("""
                QPushButton { background: rgba(255,255,255,0.2); color: white; border-radius: 10px; font-weight: bold; }
                QPushButton:hover { background: #f44336; }
            """)
            self.delete_btn.clicked.connect(lambda: self.block_deleted.emit(self))
            self.delete_btn.hide()  # Hidden by default
            layout.addWidget(self.delete_btn)

        def _update_style(self):
            border = "2px solid #e91e63" if self._selected else "1px solid rgba(255,255,255,0.2)"
            if self._available:
                bg_color = self.color
                opacity = "dd"
            else:
                bg_color = "#444"
                opacity = "88"
            self.setStyleSheet(f"""
                PluginBlock {{
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 {bg_color}, stop:1 {bg_color}{opacity});
                    border: {border};
                    border-radius: 8px;
                }}
            """)

        def set_selected(self, selected: bool):
            self._selected = selected
            self._update_style()

        def show_delete_button(self, show: bool):
            self.delete_btn.setVisible(show)

        def set_display_text(self, text: str):
            self.name_label.setText(text)

        def mousePressEvent(self, event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.block_selected.emit(self)
                self.setCursor(Qt.CursorShape.ClosedHandCursor)
            super().mousePressEvent(event)

        def mouseReleaseEvent(self, event):
            self.setCursor(Qt.CursorShape.OpenHandCursor)
            super().mouseReleaseEvent(event)

        def mouseMoveEvent(self, event):
            if event.buttons() == Qt.MouseButton.LeftButton and self._available:
                drag = QDrag(self)
                mime = QMimeData()
                mime.setData('application/x-plugin-block', self.block_type.encode())
                drag.setMimeData(mime)

                # Create pixmap of the block
                pixmap = QPixmap(self.size())
                pixmap.fill(Qt.GlobalColor.transparent)
                self.render(pixmap)
                drag.setPixmap(pixmap)
                drag.setHotSpot(event.position().toPoint())

                drag.exec(Qt.DropAction.CopyAction)
            super().mouseMoveEvent(event)

        def to_manifest_dict(self) -> dict:
            """Convert block to manifest.json representation."""
            return self.block_data.copy()

        def clone(self) -> 'PluginBlock':
            """Create a copy of this block for the canvas."""
            new_block = PluginBlock(self.block_type)
            new_block.block_data = self.block_data.copy()
            new_block.show_delete_button(True)
            return new_block


    class ScrollableBlockList(QScrollArea):
        """A scrollable list for blocks within a tab."""

        block_deleted = pyqtSignal(object)
        block_selected = pyqtSignal(object)
        block_changed = pyqtSignal()

        def __init__(self, placeholder_text: str, parent=None):
            super().__init__(parent)
            self.blocks: list = []
            self.setAcceptDrops(True)
            self.setWidgetResizable(True)
            self.setFrameShape(QFrame.Shape.NoFrame)
            self.setStyleSheet("""
                QScrollArea { background: transparent; border: none; }
                QScrollBar:vertical { background: #2a2a2a; width: 10px; border-radius: 5px; }
                QScrollBar::handle:vertical { background: #555; border-radius: 5px; min-height: 30px; }
                QScrollBar::handle:vertical:hover { background: #e91e63; }
            """)

            # Container widget
            self.container = QWidget()
            self.container.setStyleSheet("background: #1a1a1a; border-radius: 6px;")
            self.container_layout = QVBoxLayout(self.container)
            self.container_layout.setContentsMargins(8, 8, 8, 8)
            self.container_layout.setSpacing(6)
            self.container_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

            # Placeholder
            self.placeholder = QLabel(placeholder_text)
            self.placeholder.setStyleSheet("color: #666; font-size: 12px; padding: 20px;")
            self.placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.placeholder.setWordWrap(True)
            self.container_layout.addWidget(self.placeholder)
            self.container_layout.addStretch()

            self.setWidget(self.container)

        def _update_placeholder(self):
            self.placeholder.setVisible(len(self.blocks) == 0)

        def add_block(self, block: PluginBlock):
            """Add a block to this list."""
            block.show_delete_button(True)
            block.block_deleted.connect(lambda b: self._on_block_deleted(b))
            block.block_selected.connect(lambda b: self.block_selected.emit(b))
            block.block_changed.connect(self.block_changed.emit)
            block.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)

            # Insert before stretch
            insert_idx = max(0, self.container_layout.count() - 1)
            self.container_layout.insertWidget(insert_idx, block)
            self.blocks.append(block)
            self._update_placeholder()
            self.block_changed.emit()

        def _on_block_deleted(self, block: PluginBlock):
            if block in self.blocks:
                self.blocks.remove(block)
                self.container_layout.removeWidget(block)
                block.deleteLater()
                self._update_placeholder()
                self.block_deleted.emit(block)
                self.block_changed.emit()

        def clear_blocks(self):
            """Clear all blocks."""
            for block in self.blocks[:]:
                self.container_layout.removeWidget(block)
                block.deleteLater()
            self.blocks = []
            self._update_placeholder()

        def dragEnterEvent(self, event):
            if event.mimeData().hasFormat('application/x-plugin-block'):
                event.acceptProposedAction()
                self.container.setStyleSheet("background: #252525; border: 2px solid #e91e63; border-radius: 6px;")

        def dragLeaveEvent(self, event):
            self.container.setStyleSheet("background: #1a1a1a; border-radius: 6px;")

        def dropEvent(self, event):
            self.container.setStyleSheet("background: #1a1a1a; border-radius: 6px;")
            if event.mimeData().hasFormat('application/x-plugin-block'):
                block_type = event.mimeData().data('application/x-plugin-block').data().decode()
                new_block = PluginBlock(block_type)
                # Mark as user-added (not from import)
                new_block.block_data['_is_new'] = True
                self.add_block(new_block)
                event.acceptProposedAction()

    class BlockCanvas(QFrame):
        """Canvas with tabs for Setup (manifest.json) and GUI (plugin.py) blocks."""

        blocks_changed = pyqtSignal()  # Emitted when blocks are added/removed/modified
        block_selected = pyqtSignal(object)  # Emitted when a block is selected

        # Block categories for routing
        SETUP_CATEGORIES = ('dependencies',)  # pip, git, binary, command, driver
        GUI_CATEGORIES = ('ui', 'builtin', 'tools', 'plugins')  # buttons, inputs, tools

        def __init__(self, parent=None):
            super().__init__(parent)
            self.setMinimumHeight(300)
            self._setup_ui()

        def _setup_ui(self):
            self.setStyleSheet("BlockCanvas { background: transparent; border: none; }")

            layout = QVBoxLayout(self)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setSpacing(0)

            # Tab widget for Setup vs GUI
            self.tabs = QTabWidget()
            self.tabs.setStyleSheet("""
                QTabWidget::pane { border: 1px solid #444; border-radius: 6px; background: #1a1a1a; }
                QTabBar::tab {
                    background: #2a2a2a; color: #888; padding: 8px 20px;
                    border: 1px solid #444; border-bottom: none; border-radius: 6px 6px 0 0;
                    margin-right: 2px;
                }
                QTabBar::tab:selected { background: #e91e63; color: white; }
                QTabBar::tab:hover:!selected { background: #3a3a3a; color: white; }
            """)

            # Setup tab (manifest.json blocks)
            self.setup_list = ScrollableBlockList(
                "📦 Setup Blocks (manifest.json)\n\n"
                "Drop here:\n"
                "• Pip Packages\n"
                "• Git Clone\n"
                "• Binary Downloads\n"
                "• Setup Commands\n"
                "• Driver Installs"
            )
            self.setup_list.block_selected.connect(lambda b: self.block_selected.emit(b))
            self.setup_list.block_changed.connect(self.blocks_changed.emit)
            self.tabs.addTab(self.setup_list, "📦 Setup (manifest.json)")

            # GUI tab (plugin.py blocks)
            self.gui_list = ScrollableBlockList(
                "🖥️ GUI Blocks (plugin.py)\n\n"
                "Drop here:\n"
                "• Buttons, Labels, Inputs\n"
                "• Dropdowns, File Pickers\n"
                "• Progress Bars, Log Output\n"
                "• Built-in Tools\n"
                "• Plugin Actions"
            )
            self.gui_list.block_selected.connect(lambda b: self.block_selected.emit(b))
            self.gui_list.block_changed.connect(self.blocks_changed.emit)
            self.tabs.addTab(self.gui_list, "🖥️ GUI (plugin.py)")

            layout.addWidget(self.tabs)

        @property
        def blocks(self) -> list:
            """Get all blocks from both tabs."""
            return self.setup_list.blocks + self.gui_list.blocks

        def add_block(self, block: PluginBlock):
            """Add a block to the appropriate tab based on its category."""
            if block.category in self.SETUP_CATEGORIES:
                self.setup_list.add_block(block)
                self.tabs.setCurrentIndex(0)  # Switch to setup tab
            else:
                self.gui_list.add_block(block)
                self.tabs.setCurrentIndex(1)  # Switch to GUI tab
            self.blocks_changed.emit()

        def clear_blocks(self):
            """Clear all blocks from both tabs."""
            self.setup_list.clear_blocks()
            self.gui_list.clear_blocks()
            self.blocks_changed.emit()

        def _on_block_deleted(self, block: PluginBlock):
            """Handle block deletion (called by child lists)."""
            self.blocks_changed.emit()

        def get_manifest_data(self) -> dict:
            """Generate manifest.json content from blocks."""
            manifest = {
                'requirements': [],
                'bundled_binaries': [],
                'setup_commands': [],
                'post_install': []
            }

            for block in self.blocks:
                data = block.block_data
                if block.block_type == 'pip' and data.get('package'):
                    manifest['requirements'].append(data['package'])

                elif block.block_type == 'git' and data.get('repo'):
                    git_clone = {
                        'repo': data['repo'],
                        'target': data.get('target', '')
                    }
                    # Include branch if specified
                    if data.get('branch'):
                        git_clone['branch'] = data['branch']
                    # Include depth if specified
                    depth = data.get('depth', '')
                    if depth:
                        # Parse depth value
                        if depth.startswith('1'):
                            git_clone['depth'] = 1
                        elif depth.isdigit():
                            git_clone['depth'] = int(depth)
                        elif 'Full' not in depth:
                            try:
                                git_clone['depth'] = int(depth.split()[0])
                            except ValueError:
                                pass
                    manifest['git_clone'] = git_clone

                elif block.block_type == 'binary':
                    source_type = data.get('source_type', 'url')
                    if source_type == 'local' and data.get('local_path'):
                        # Local file - just store the relative path, will be copied on export
                        local_path = data['local_path']
                        filename = os.path.basename(local_path)
                        target = data.get('target_path', filename)
                        # Store full path for export, relative path for manifest
                        binary_entry = target  # Simple string reference
                        manifest['bundled_binaries'].append(binary_entry)
                        # Mark for copy during export
                        if '_local_files' not in manifest:
                            manifest['_local_files'] = []
                        manifest['_local_files'].append({
                            'source': local_path,
                            'target': target
                        })
                    elif source_type == 'url' and data.get('url'):
                        binary_entry = {'url': data['url']}
                        if data.get('target_path'):
                            binary_entry['target_path'] = data['target_path']
                        if data.get('sha256'):
                            binary_entry['sha256'] = data['sha256']
                        manifest['bundled_binaries'].append(binary_entry)

                elif block.block_type == 'command' and data.get('command'):
                    manifest['setup_commands'].append(data['command'])

                elif block.block_type == 'driver':
                    # Prefer dropdown selection, fall back to custom path
                    driver_file = data.get('file', '')
                    custom_path = data.get('custom_driver_path', '')

                    if custom_path and os.path.exists(custom_path):
                        # Custom driver - will need to be copied
                        driver_file = os.path.basename(custom_path)
                        if '_custom_drivers' not in manifest:
                            manifest['_custom_drivers'] = []
                        manifest['_custom_drivers'].append({
                            'source': custom_path,
                            'filename': driver_file
                        })

                    if driver_file:
                        driver_entry = {
                            'type': 'driver',
                            'file': driver_file
                        }
                        if data.get('optional', True):
                            driver_entry['optional'] = True
                        manifest['post_install'].append(driver_entry)

            # Clean empty lists
            return {k: v for k, v in manifest.items() if v}

        def get_ui_blocks(self) -> list:
            """Get UI-related blocks for plugin.py generation."""
            ui_types = (
                # Basic UI
                'button', 'label', 'input', 'text_area', 'dropdown',
                'file_picker', 'folder_picker', 'log_output', 'progress_bar', 'action',
                # Controls
                'checkbox', 'radio', 'spinbox', 'slider', 'switch',
                # Containers
                'group_box', 'tab_panel', 'scroll_area', 'splitter',
                # Data Display
                'table', 'tree', 'list_widget', 'image_display',
                # Layout
                'separator', 'spacer', 'horizontal_layout', 'vertical_layout'
            )
            return [b for b in self.blocks if b.block_type in ui_types]

        def get_tool_blocks(self) -> list:
            """Get tool/action blocks that generate functional code."""
            tool_types = (
                # Built-in tools
                'extract_payload', 'repack_payload', 'extract_super', 'analyze_boot', 'decrypt_oppo',
                # External tools
                'erofs_extract', 'erofs_create', 'allwinner_unpack', 'allwinner_repack', 'rockchip_unpack', 'rockchip_repack',
                # Plugin tools
                'adb_command', 'adb_pull', 'adb_push', 'adb_install',
                'fastboot_flash', 'fastboot_boot', 'fastboot_erase',
                'mtk_read', 'mtk_write', 'mtk_erase',
                'scrcpy_mirror', 'scrcpy_record'
            )
            return [b for b in self.blocks if b.block_type in tool_types]


    class BlockPropertiesPanel(QFrame):
        """Properties editor for selected block."""

        properties_changed = pyqtSignal()

        def __init__(self, parent=None):
            super().__init__(parent)
            self.current_block: Optional[PluginBlock] = None
            self._setup_ui()

        def _setup_ui(self):
            self.setStyleSheet("""
                BlockPropertiesPanel {
                    background: #252525;
                    border: 1px solid #444;
                    border-radius: 8px;
                }
            """)
            self.setMinimumWidth(250)

            layout = QVBoxLayout(self)
            layout.setContentsMargins(12, 12, 12, 12)
            layout.setSpacing(10)

            title = QLabel("⚙️ Properties")
            title.setStyleSheet("font-weight: bold; font-size: 14px; color: #e91e63;")
            title.setToolTip("Click a block on the canvas to edit its properties here.\n💡 Tip: Fill in all required fields for each block.")
            layout.addWidget(title)

            # Content area that changes based on selected block
            self.content_widget = QWidget()
            self.content_layout = QVBoxLayout(self.content_widget)
            self.content_layout.setContentsMargins(0, 0, 0, 0)
            self.content_layout.setSpacing(8)

            self.placeholder = QLabel("Select a block to edit its properties")
            self.placeholder.setStyleSheet("color: #666; font-size: 11px;")
            self.placeholder.setWordWrap(True)
            self.content_layout.addWidget(self.placeholder)

            layout.addWidget(self.content_widget)
            layout.addStretch()

        def _clear_content(self):
            while self.content_layout.count():
                item = self.content_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        def _add_field(self, label_text: str, field_key: str, placeholder: str = "", multiline: bool = False):
            """Add a labeled input field."""
            label = QLabel(label_text)
            label.setStyleSheet("color: #aaa; font-size: 11px;")
            self.content_layout.addWidget(label)

            if multiline:
                field = QTextEdit()
                field.setMaximumHeight(60)
                field.setPlaceholderText(placeholder)
                if self.current_block and field_key in self.current_block.block_data:
                    field.setPlainText(str(self.current_block.block_data[field_key]))
                field.textChanged.connect(lambda: self._on_field_changed(field_key, field.toPlainText()))
            else:
                field = QLineEdit()
                field.setPlaceholderText(placeholder)
                if self.current_block and field_key in self.current_block.block_data:
                    field.setText(str(self.current_block.block_data[field_key]))
                field.textChanged.connect(lambda text: self._on_field_changed(field_key, text))

            field.setStyleSheet("""
                QLineEdit, QTextEdit {
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 6px;
                    color: white;
                }
                QLineEdit:focus, QTextEdit:focus { border-color: #e91e63; }
            """)
            self.content_layout.addWidget(field)
            return field

        def _on_field_changed(self, key: str, value):
            if self.current_block:
                self.current_block.block_data[key] = value
                # Update block display text
                if key == 'package' and value:
                    self.current_block.set_display_text(f"📦 {value}")
                elif key == 'repo' and value:
                    repo_name = value.rstrip('/').split('/')[-1].replace('.git', '')
                    self.current_block.set_display_text(f"📥 {repo_name}")
                elif key == 'command' and value:
                    short = str(value)[:20] + '...' if len(str(value)) > 20 else str(value)
                    self.current_block.set_display_text(f"⚙️ {short}")
                elif key == 'text' and value:
                    self.current_block.set_display_text(f"🏷️ {str(value)[:15]}")
                elif key == 'label' and value:
                    self.current_block.set_display_text(f"🔘 {str(value)[:15]}")
                elif key == 'url' and value:
                    filename = os.path.basename(str(value).split('?')[0])
                    self.current_block.set_display_text(f"⬇️ {filename[:20]}")
                elif key == 'local_path' and value:
                    filename = os.path.basename(str(value))
                    self.current_block.set_display_text(f"📁 {filename[:20]}")
                elif key == 'file' and value and self.current_block.block_type == 'driver':
                    self.current_block.set_display_text(f"🔌 {str(value)[:20]}")

                # If source_type changed for binary block, refresh the panel
                if key == 'source_type' and self.current_block.block_type == 'binary':
                    # Schedule a refresh after current event processing
                    QTimer.singleShot(0, lambda: self.show_block_properties(self.current_block))

                self.current_block.block_changed.emit()
                self.properties_changed.emit()

        def _add_field_with_browse(self, label_text: str, field_key: str, placeholder: str = "",
                                    file_filter: str = "All Files (*.*)", is_folder: bool = False,
                                    initial_dir: str = "") -> QLineEdit:
            """Add a labeled input field with a browse button."""
            label = QLabel(label_text)
            label.setStyleSheet("color: #aaa; font-size: 11px;")
            self.content_layout.addWidget(label)

            row = QHBoxLayout()
            row.setSpacing(4)

            field = QLineEdit()
            field.setPlaceholderText(placeholder)
            if self.current_block and field_key in self.current_block.block_data:
                field.setText(str(self.current_block.block_data[field_key]))
            field.textChanged.connect(lambda text: self._on_field_changed(field_key, text))
            field.setStyleSheet("""
                QLineEdit {
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 6px;
                    color: white;
                }
                QLineEdit:focus { border-color: #e91e63; }
            """)
            row.addWidget(field, 1)

            browse_btn = QPushButton("📁")
            browse_btn.setFixedWidth(32)
            browse_btn.setToolTip("Browse...")
            browse_btn.setStyleSheet("""
                QPushButton { background: #444; border: 1px solid #555; border-radius: 4px; padding: 5px; }
                QPushButton:hover { background: #555; }
            """)

            def do_browse():
                start_dir = initial_dir or get_app_dir()
                if is_folder:
                    path = QFileDialog.getExistingDirectory(self, "Select Folder", start_dir)
                else:
                    path, _ = QFileDialog.getOpenFileName(self, "Select File", start_dir, file_filter)
                if path:
                    field.setText(path)

            browse_btn.clicked.connect(do_browse)
            row.addWidget(browse_btn)

            container = QWidget()
            container.setLayout(row)
            self.content_layout.addWidget(container)
            return field

        def _add_dropdown(self, label_text: str, field_key: str, options: list,
                          allow_custom: bool = False, placeholder: str = "") -> QComboBox:
            """Add a labeled dropdown selector."""
            label = QLabel(label_text)
            label.setStyleSheet("color: #aaa; font-size: 11px;")
            self.content_layout.addWidget(label)

            if allow_custom:
                combo = QComboBox()
                combo.setEditable(True)
                combo.lineEdit().setPlaceholderText(placeholder)
            else:
                combo = QComboBox()

            combo.addItems(options)
            combo.setStyleSheet("""
                QComboBox {
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 6px;
                    color: white;
                }
                QComboBox:focus { border-color: #e91e63; }
                QComboBox::drop-down { border: none; width: 20px; }
                QComboBox::down-arrow { image: none; border-left: 4px solid transparent; border-right: 4px solid transparent; border-top: 6px solid #888; }
                QComboBox QAbstractItemView { background: #1a1a1a; color: white; selection-background-color: #e91e63; }
            """)

            # Set current value if exists
            if self.current_block and field_key in self.current_block.block_data:
                current = self.current_block.block_data[field_key]
                idx = combo.findText(current)
                if idx >= 0:
                    combo.setCurrentIndex(idx)
                elif allow_custom:
                    combo.setCurrentText(current)

            if allow_custom:
                combo.currentTextChanged.connect(lambda t: self._on_field_changed(field_key, t))
            else:
                combo.currentTextChanged.connect(lambda t: self._on_field_changed(field_key, t))

            self.content_layout.addWidget(combo)
            return combo

        def _add_radio_group(self, label_text: str, field_key: str, options: list) -> QButtonGroup:
            """Add a radio button group for mutually exclusive options."""
            label = QLabel(label_text)
            label.setStyleSheet("color: #aaa; font-size: 11px;")
            self.content_layout.addWidget(label)

            group = QButtonGroup(self)
            row = QHBoxLayout()
            row.setSpacing(12)

            current_value = ""
            if self.current_block and field_key in self.current_block.block_data:
                current_value = self.current_block.block_data[field_key]

            for i, (value, display) in enumerate(options):
                radio = QRadioButton(display)
                radio.setStyleSheet("color: #ccc; font-size: 11px;")
                if value == current_value or (i == 0 and not current_value):
                    radio.setChecked(True)
                    if not current_value:
                        self._on_field_changed(field_key, value)
                group.addButton(radio, i)
                row.addWidget(radio)
                radio.toggled.connect(lambda checked, v=value: checked and self._on_field_changed(field_key, v))

            row.addStretch()
            container = QWidget()
            container.setLayout(row)
            self.content_layout.addWidget(container)
            return group

        def _get_available_drivers(self) -> list:
            """Get list of driver files in the drivers/ folder."""
            drivers_dir = os.path.join(get_app_dir(), 'drivers')
            drivers = []
            if os.path.exists(drivers_dir):
                for f in os.listdir(drivers_dir):
                    if f.endswith(('.msi', '.exe', '.inf')):
                        drivers.append(f)
            return sorted(drivers)

        def _get_common_pip_packages(self) -> list:
            """Get list of commonly used pip packages for autocomplete."""
            return [
                "requests", "pillow", "numpy", "pyusb", "pyserial",
                "pycryptodome", "pycryptodomex", "colorama", "tqdm",
                "aiohttp", "beautifulsoup4", "lxml", "paramiko",
                "protobuf", "grpcio", "flask", "fastapi"
            ]

        def show_block_properties(self, block: Optional[PluginBlock]):
            self._clear_content()
            self.current_block = block

            if not block:
                self.placeholder = QLabel("Select a block to edit its properties")
                self.placeholder.setStyleSheet("color: #666; font-size: 11px;")
                self.placeholder.setWordWrap(True)
                self.content_layout.addWidget(self.placeholder)
                return

            # Block type header
            header = QLabel(f"{block.icon} {block.display_name}")
            header.setStyleSheet(f"font-weight: bold; color: {block.color};")
            self.content_layout.addWidget(header)

            # Add fields based on block type
            if block.block_type == 'pip':
                # Dropdown with common packages + custom entry
                common_pkgs = [""] + self._get_common_pip_packages()
                self._add_dropdown("Package Name:", "package", common_pkgs,
                                   allow_custom=True, placeholder="e.g., requests, pillow>=9.0")
                # Hint text
                hint = QLabel("💡 Type custom package or select from common ones")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'git':
                self._add_field("Repository URL:", "repo", "https://github.com/user/repo.git")
                self._add_field("Target Directory:", "target", "folder name (optional)")
                # New: Branch selection
                self._add_field("Branch:", "branch", "main (leave empty for default)")
                # New: Shallow clone depth
                depth_options = ["", "1 (shallow)", "10", "50", "Full clone"]
                self._add_dropdown("Clone Depth:", "depth", depth_options, allow_custom=True,
                                   placeholder="1 for shallow clone")
                hint = QLabel("💡 Shallow clone (depth=1) is faster and uses less space")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'binary':
                # Source type toggle: URL or Local File
                self._add_radio_group("Source Type:", "source_type", [
                    ("url", "🌐 Download URL"),
                    ("local", "📁 Local File")
                ])

                # Conditional fields based on source type
                source_type = block.block_data.get('source_type', 'url')

                if source_type == 'local':
                    self._add_field_with_browse("Local File:", "local_path",
                                                 placeholder="Select file to bundle...",
                                                 file_filter="All Files (*.*);;Executables (*.exe *.dll *.msi)")
                    hint = QLabel("💡 This file will be copied into your plugin folder")
                    hint.setStyleSheet("color: #666; font-size: 9px;")
                    self.content_layout.addWidget(hint)
                else:
                    self._add_field("Download URL:", "url", "https://example.com/file.exe")
                    self._add_field("SHA256 Hash:", "sha256", "For verification (optional)")

                self._add_field("Save As:", "target_path", "path/to/file.exe (optional)")

            elif block.block_type == 'command':
                # Template dropdown for common commands
                templates = [
                    "",
                    "pip install .",
                    "pip install -r requirements.txt",
                    "python setup.py install",
                    "npm install",
                    "chmod +x *.sh"
                ]
                self._add_dropdown("Command Template:", "command", templates,
                                   allow_custom=True, placeholder="Enter custom command...")
                hint = QLabel("💡 Select template or type custom command")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'driver':
                # Dropdown with available drivers from drivers/ folder
                available_drivers = self._get_available_drivers()
                if available_drivers:
                    options = [""] + available_drivers
                    self._add_dropdown("Select Driver:", "file", options,
                                       allow_custom=True, placeholder="Select or type filename...")
                    hint = QLabel(f"💡 {len(available_drivers)} drivers found in drivers/ folder")
                    hint.setStyleSheet("color: #4caf50; font-size: 9px;")
                    self.content_layout.addWidget(hint)
                else:
                    self._add_field("Driver File:", "file", "driver.msi or setup.exe")
                    hint = QLabel("⚠️ No drivers found in drivers/ folder")
                    hint.setStyleSheet("color: #ff9800; font-size: 9px;")
                    self.content_layout.addWidget(hint)

                # Optional: add a browse button for custom drivers
                self._add_field_with_browse("Or browse custom driver:", "custom_driver_path",
                                            placeholder="Browse for custom driver...",
                                            file_filter="Installers (*.msi *.exe);;All Files (*.*)",
                                            initial_dir=os.path.join(get_app_dir(), 'drivers'))

                # Driver options
                optional_check = QCheckBox("Optional (skip if not found)")
                optional_check.setStyleSheet("color: #aaa; font-size: 11px;")
                optional_check.setChecked(block.block_data.get('optional', True))
                optional_check.toggled.connect(lambda c: self._on_field_changed('optional', c))
                self.content_layout.addWidget(optional_check)

            elif block.block_type == 'button':
                self._add_field("Button Label:", "label", "Click Me")
                self._add_field("Variable Name:", "var_name", "my_button")

                # Action code - show in a larger multiline field
                action_label = QLabel("Action Code:")
                action_label.setStyleSheet("color: #aaa; font-size: 11px;")
                self.content_layout.addWidget(action_label)

                action_field = QTextEdit()
                action_field.setMinimumHeight(120)
                action_field.setMaximumHeight(200)
                action_field.setPlaceholderText("# Python code to run when clicked\nprint('Button clicked!')")
                action_field.setStyleSheet("""
                    QTextEdit {
                        background: #1a1a1a;
                        border: 1px solid #444;
                        border-radius: 4px;
                        padding: 6px;
                        color: #4fc3f7;
                        font-family: 'Consolas', 'Monaco', monospace;
                        font-size: 11px;
                    }
                    QTextEdit:focus { border-color: #e91e63; }
                """)
                if block.block_data.get('action_code'):
                    action_field.setPlainText(str(block.block_data['action_code']))
                action_field.textChanged.connect(lambda: self._on_field_changed('action_code', action_field.toPlainText()))
                self.content_layout.addWidget(action_field)

                hint = QLabel("💡 Code that runs when the button is clicked")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'label':
                self._add_field("Label Text:", "text", "Your text here")

            elif block.block_type == 'input':
                self._add_field("Placeholder:", "placeholder", "Enter value...")
                self._add_field("Variable Name:", "var_name", "my_input")

            elif block.block_type == 'dropdown':
                self._add_field("Options (comma separated):", "options", "Option 1, Option 2, Option 3")
                self._add_field("Variable Name:", "var_name", "my_dropdown")

            elif block.block_type == 'action':
                # Pre-built action selector
                label = QLabel("Action Type:")
                label.setStyleSheet("color: #aaa; font-size: 11px;")
                self.content_layout.addWidget(label)

                combo = QComboBox()
                combo.addItems([
                    "Run ADB Command",
                    "Run Fastboot Command",
                    "Extract Payload",
                    "Pack Payload",
                    "Extract Super Image",
                    "Flash Partition",
                    "Custom Code"
                ])
                combo.setStyleSheet("""
                    QComboBox {
                        background: #1a1a1a;
                        border: 1px solid #444;
                        border-radius: 4px;
                        padding: 6px;
                        color: white;
                    }
                """)
                if block.block_data.get('action_type'):
                    idx = combo.findText(block.block_data['action_type'])
                    if idx >= 0:
                        combo.setCurrentIndex(idx)
                combo.currentTextChanged.connect(lambda t: self._on_field_changed('action_type', t))
                self.content_layout.addWidget(combo)

                self._add_field("Parameters:", "params", "Additional parameters", multiline=True)

            # === NEW UI ELEMENT PROPERTIES ===
            elif block.block_type == 'file_picker':
                self._add_field("Button Label:", "label", "Select File...")
                self._add_field("Variable Name:", "var_name", "selected_file")
                self._add_field("File Filter:", "filter", "All Files (*.*);;Images (*.img)")
                # Initial directory options
                init_dir_options = [
                    "",
                    "Home directory",
                    "Downloads folder",
                    "Last used directory",
                    "Plugin directory",
                    "Custom path..."
                ]
                self._add_dropdown("Initial Directory:", "initial_dir", init_dir_options,
                                   allow_custom=True, placeholder="Where to start browsing")
                hint = QLabel("💡 Where the file dialog opens initially")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'folder_picker':
                self._add_field("Button Label:", "label", "Select Folder...")
                self._add_field("Variable Name:", "var_name", "selected_folder")
                # Initial directory options
                init_dir_options = [
                    "",
                    "Home directory",
                    "Downloads folder",
                    "Last used directory",
                    "Plugin directory",
                    "Custom path..."
                ]
                self._add_dropdown("Initial Directory:", "initial_dir", init_dir_options,
                                   allow_custom=True, placeholder="Where to start browsing")
                hint = QLabel("💡 Where the folder dialog opens initially")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'log_output':
                self._add_field("Variable Name:", "var_name", "log_output")
                self._add_field("Initial Text:", "initial", "Ready...")

            elif block.block_type == 'progress_bar':
                self._add_field("Variable Name:", "var_name", "progress")
                self._add_field("Minimum Value:", "min_val", "0")
                self._add_field("Maximum Value:", "max_val", "100")

            # === NEW UI ELEMENT PROPERTIES ===
            elif block.block_type == 'text_area':
                self._add_field("Variable Name:", "var_name", "text_area")
                self._add_field("Placeholder:", "placeholder", "Enter text here...")
                self._add_field("Initial Text:", "initial", "")

            elif block.block_type == 'checkbox':
                self._add_field("Label:", "label", "Enable feature")
                self._add_field("Variable Name:", "var_name", "checkbox")
                checked_options = ["Unchecked", "Checked"]
                self._add_dropdown("Default State:", "default", checked_options)

            elif block.block_type == 'radio':
                self._add_field("Label:", "label", "Option A")
                self._add_field("Group Name:", "group", "options")
                self._add_field("Variable Name:", "var_name", "radio_option")

            elif block.block_type == 'spinbox':
                self._add_field("Variable Name:", "var_name", "number_input")
                self._add_field("Minimum:", "min_val", "0")
                self._add_field("Maximum:", "max_val", "100")
                self._add_field("Default Value:", "default", "0")
                self._add_field("Step:", "step", "1")

            elif block.block_type == 'slider':
                self._add_field("Variable Name:", "var_name", "slider")
                self._add_field("Minimum:", "min_val", "0")
                self._add_field("Maximum:", "max_val", "100")
                self._add_field("Default Value:", "default", "50")
                orientation_options = ["Horizontal", "Vertical"]
                self._add_dropdown("Orientation:", "orientation", orientation_options)

            elif block.block_type == 'switch':
                self._add_field("Label:", "label", "Enable feature")
                self._add_field("Variable Name:", "var_name", "toggle")
                state_options = ["Off", "On"]
                self._add_dropdown("Default State:", "default", state_options)

            elif block.block_type == 'group_box':
                self._add_field("Title:", "title", "Settings")
                self._add_field("Variable Name:", "var_name", "group")
                hint = QLabel("💡 Add child elements inside this group")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'tab_panel':
                self._add_field("Variable Name:", "var_name", "tabs")
                self._add_field("Tab Names (comma separated):", "tabs", "Tab 1, Tab 2, Tab 3")
                hint = QLabel("💡 Each tab can contain child elements")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'scroll_area':
                self._add_field("Variable Name:", "var_name", "scroll")
                self._add_field("Max Height:", "max_height", "400")

            elif block.block_type == 'splitter':
                self._add_field("Variable Name:", "var_name", "splitter")
                orientation_options = ["Horizontal", "Vertical"]
                self._add_dropdown("Orientation:", "orientation", orientation_options)

            elif block.block_type == 'table':
                self._add_field("Variable Name:", "var_name", "table")
                self._add_field("Columns (comma separated):", "columns", "Name, Value, Status")
                self._add_field("Rows:", "rows", "5")

            elif block.block_type == 'tree':
                self._add_field("Variable Name:", "var_name", "tree")
                self._add_field("Columns (comma separated):", "columns", "Name, Type")

            elif block.block_type == 'list_widget':
                self._add_field("Variable Name:", "var_name", "list")
                self._add_field("Items (comma separated):", "items", "Item 1, Item 2, Item 3")

            elif block.block_type == 'image_display':
                self._add_field("Variable Name:", "var_name", "image")
                self._add_field_with_browse("Image File:", "image_path",
                                            placeholder="Select image...",
                                            file_filter="Images (*.png *.jpg *.gif *.svg);;All Files (*.*)")
                self._add_field("Width:", "width", "auto")
                self._add_field("Height:", "height", "auto")

            elif block.block_type == 'separator':
                orientation_options = ["Horizontal", "Vertical"]
                self._add_dropdown("Orientation:", "orientation", orientation_options)
                hint = QLabel("💡 Adds a visual divider line")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'spacer':
                self._add_field("Size (pixels):", "size", "20")
                orientation_options = ["Horizontal", "Vertical"]
                self._add_dropdown("Direction:", "orientation", orientation_options)

            elif block.block_type == 'horizontal_layout':
                self._add_field("Variable Name:", "var_name", "h_layout")
                self._add_field("Spacing:", "spacing", "6")
                hint = QLabel("💡 Child elements arranged side by side")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            elif block.block_type == 'vertical_layout':
                self._add_field("Variable Name:", "var_name", "v_layout")
                self._add_field("Spacing:", "spacing", "6")
                hint = QLabel("💡 Child elements stacked vertically")
                hint.setStyleSheet("color: #666; font-size: 9px;")
                self.content_layout.addWidget(hint)

            # === BUILT-IN TOOL PROPERTIES ===
            elif block.block_type == 'extract_payload':
                self._add_field("Input File Variable:", "input_var", "payload_file")
                self._add_field("Output Dir Variable:", "output_var", "output_dir")

            elif block.block_type == 'repack_payload':
                self._add_field("Images Dir Variable:", "input_var", "images_dir")
                self._add_field("Output File Variable:", "output_var", "payload_file")

            elif block.block_type == 'extract_super':
                self._add_field("Super Image Variable:", "input_var", "super_file")
                self._add_field("Output Dir Variable:", "output_var", "output_dir")

            elif block.block_type == 'analyze_boot':
                self._add_field("Boot Image Variable:", "input_var", "boot_file")

            elif block.block_type == 'decrypt_oppo':
                self._add_field("Input File Variable:", "input_var", "encrypted_file")
                self._add_field("Output Dir Variable:", "output_var", "output_dir")

            # === EXTERNAL TOOL PROPERTIES ===
            elif block.block_type in ('erofs_extract', 'erofs_create'):
                self._add_field("Input Variable:", "input_var", "input_path")
                self._add_field("Output Variable:", "output_var", "output_path")

            elif block.block_type in ('allwinner_unpack', 'allwinner_repack', 'rockchip_unpack', 'rockchip_repack'):
                self._add_field("Input Variable:", "input_var", "firmware_file")
                self._add_field("Output Variable:", "output_var", "output_dir")

            # === PLUGIN TOOL PROPERTIES ===
            elif block.block_type == 'adb_command':
                self._add_field("Command:", "command", "shell ls /sdcard")
                self._add_field("Output Variable:", "output_var", "adb_result")

            elif block.block_type == 'adb_pull':
                self._add_field("Remote Path:", "remote", "/sdcard/file.txt")
                self._add_field("Local Path Variable:", "local_var", "local_path")

            elif block.block_type == 'adb_push':
                self._add_field("Local Path Variable:", "local_var", "local_path")
                self._add_field("Remote Path:", "remote", "/sdcard/")

            elif block.block_type == 'adb_install':
                self._add_field("APK Path Variable:", "apk_var", "apk_path")

            elif block.block_type == 'fastboot_flash':
                self._add_field("Partition Name:", "partition", "boot")
                self._add_field("Image Path Variable:", "image_var", "image_path")

            elif block.block_type == 'fastboot_boot':
                self._add_field("Image Path Variable:", "image_var", "boot_image")

            elif block.block_type == 'fastboot_erase':
                self._add_field("Partition Name:", "partition", "userdata")

            elif block.block_type == 'mtk_read':
                self._add_field("Partition Name:", "partition", "boot")
                self._add_field("Output Path Variable:", "output_var", "output_path")

            elif block.block_type == 'mtk_write':
                self._add_field("Partition Name:", "partition", "boot")
                self._add_field("Image Path Variable:", "image_var", "image_path")

            elif block.block_type == 'mtk_erase':
                self._add_field("Partition Name:", "partition", "frp")

            elif block.block_type == 'scrcpy_mirror':
                self._add_field("Window Title:", "title", "Device Screen")
                self._add_field("Max Size:", "max_size", "1024")

            elif block.block_type == 'scrcpy_record':
                self._add_field("Output File Variable:", "output_var", "recording_file")
                self._add_field("Max Size:", "max_size", "1024")


    # =========================================================================
    # COMMUNITY CHAT WIDGET - Real-time Socket.IO Chat for Plugin Store
    # =========================================================================
    
    class CommunityChatWidget(QWidget):
        """Real-time community chat widget using Socket.IO.
        
        Server events (server -> client):
            - user_joined: {user_id, username, is_admin}
            - user_left: {user_id, username}
            - online_users: {count, users: [{username, is_admin}]}
            - online_count: {count}
            - new_message: {id, user_id, username, is_admin, message, message_type, attachment_url, room_id, created_at}
            - user_typing: {username, room_id}
            - message_deleted: {id, deleted_by}
            - invite_received: {invite_id, room_id, room_name, inviter}
            - pending_invites: {invites: [...]}
            - banned: {room_id, reason, expires_at}
            - muted: {room_id, expires_at}
            - kicked: {room_id}
            - error: {message}
            
        Client events (client -> server):
            - message: {message, room_id, message_type, attachment_url, attachment_name}
            - typing: {room_id}
            - join_room: {room_id}
            - leave_room: {room_id}
            - delete_message: {message_id}
        """
        
        message_received = pyqtSignal(dict)  # message data
        connection_changed = pyqtSignal(bool, str)  # connected, status_text
        user_count_updated = pyqtSignal(int)  # online user count
        invite_received = pyqtSignal(dict)  # invite data
        message_deleted = pyqtSignal(int)  # message id
        system_message = pyqtSignal(str)  # system message text - for thread-safe UI updates
        rooms_loaded = pyqtSignal(list)  # rooms list - for thread-safe UI updates
        invites_updated = pyqtSignal()  # signal to update invites badge
        room_created = pyqtSignal(dict)  # room data - for thread-safe room creation callback
        invite_accepted = pyqtSignal()  # signal when invite is accepted
        undock_requested = pyqtSignal()  # signal to undock into floating window
        dock_requested = pyqtSignal()  # signal to dock back into main window
        
        def __init__(self, parent=None):
            super().__init__(parent)
            self.sio = None
            self.connected = False
            self.username = None
            self.user_id = None
            self.is_admin = False
            self.token = None
            self.reconnect_timer = None
            self.current_room = 'general'
            self.pending_invites = []
            self._setup_ui()
            self._setup_signals()
            
        def _setup_ui(self):
            layout = QVBoxLayout(self)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setSpacing(4)
            
            # Chat header
            header = QHBoxLayout()
            header.setSpacing(8)
            
            self.status_indicator = QLabel("●")
            self.status_indicator.setStyleSheet("color: #666; font-size: 14px;")
            header.addWidget(self.status_indicator)
            
            title = QLabel("Community Chat")
            title.setStyleSheet("font-weight: bold; font-size: 13px;")
            header.addWidget(title)
            
            header.addStretch()
            
            self.online_count = QLabel("• 0 online")
            self.online_count.setStyleSheet("color: #4fc3f7; font-size: 11px;")
            header.addWidget(self.online_count)
            
            self.connection_status = QLabel("Disconnected")
            self.connection_status.setStyleSheet("color: #888; font-size: 10px;")
            header.addWidget(self.connection_status)
            
            layout.addLayout(header)
            
            # Chat messages area
            self.chat_area = QScrollArea()
            self.chat_area.setWidgetResizable(True)
            self.chat_area.setFrameShape(QFrame.Shape.NoFrame)
            self.chat_area.setStyleSheet("""
                QScrollArea {
                    background-color: #1a1a2a;
                    border: 1px solid #2a2a3a;
                    border-radius: 8px;
                }
            """)
            
            self.messages_widget = QWidget()
            self.messages_layout = QVBoxLayout(self.messages_widget)
            self.messages_layout.setContentsMargins(8, 8, 8, 8)
            self.messages_layout.setSpacing(4)
            self.messages_layout.addStretch()
            
            self.chat_area.setWidget(self.messages_widget)
            layout.addWidget(self.chat_area, 1)
            
            # Room selector and controls
            room_layout = QHBoxLayout()
            room_layout.setSpacing(4)
            
            self.room_selector = QComboBox()
            self.room_selector.addItem("🌐 General", "general")
            self.room_selector.setStyleSheet("""
                QComboBox {
                    background-color: #2a2a3a;
                    border: 1px solid #3a3a4a;
                    border-radius: 4px;
                    padding: 4px 8px;
                    color: #fff;
                    min-width: 120px;
                }
            """)
            self.room_selector.currentIndexChanged.connect(self._on_room_changed)
            room_layout.addWidget(self.room_selector)
            
            self.create_room_btn = QPushButton("➕")
            self.create_room_btn.setToolTip("Create Room")
            self.create_room_btn.setFixedWidth(28)
            self.create_room_btn.setStyleSheet("QPushButton { background: #333; border: 1px solid #555; border-radius: 4px; }")
            self.create_room_btn.clicked.connect(self._show_create_room_dialog)
            room_layout.addWidget(self.create_room_btn)
            
            self.invite_btn = QPushButton("📨")
            self.invite_btn.setToolTip("Invite to Room")
            self.invite_btn.setFixedWidth(28)
            self.invite_btn.setStyleSheet("QPushButton { background: #333; border: 1px solid #555; border-radius: 4px; }")
            self.invite_btn.clicked.connect(self._show_invite_dialog)
            room_layout.addWidget(self.invite_btn)
            
            room_layout.addStretch()
            
            # Invites notification badge
            self.invites_btn = QPushButton("🔔")
            self.invites_btn.setToolTip("Pending Invites")
            self.invites_btn.setFixedWidth(28)
            self.invites_btn.setStyleSheet("QPushButton { background: #333; border: 1px solid #555; border-radius: 4px; }")
            self.invites_btn.clicked.connect(self._show_invites_dialog)
            self.invites_btn.setVisible(False)  # Hidden until invites arrive
            room_layout.addWidget(self.invites_btn)
            
            layout.addLayout(room_layout)
            
            # Message input area
            input_layout = QHBoxLayout()
            input_layout.setSpacing(4)
            
            # Attachment button
            self.attach_btn = QPushButton("📎")
            self.attach_btn.setToolTip("Attach file/image")
            self.attach_btn.setFixedWidth(32)
            self.attach_btn.setEnabled(False)
            self.attach_btn.setStyleSheet("""
                QPushButton { background: #333; border: 1px solid #555; border-radius: 8px; font-size: 14px; }
                QPushButton:hover { background: #444; }
                QPushButton:disabled { color: #666; }
            """)
            self.attach_btn.clicked.connect(self._attach_file)
            input_layout.addWidget(self.attach_btn)
            
            self.message_input = QLineEdit()
            self.message_input.setPlaceholderText("Type a message... (Enter to send)")
            self.message_input.setEnabled(False)
            self.message_input.setStyleSheet("""
                QLineEdit {
                    background-color: #2a2a3a;
                    border: 1px solid #3a3a4a;
                    border-radius: 8px;
                    padding: 8px 12px;
                    color: #fff;
                    font-size: 12px;
                }
                QLineEdit:focus {
                    border-color: #4fc3f7;
                }
                QLineEdit:disabled {
                    background-color: #1a1a2a;
                    color: #666;
                }
            """)
            self.message_input.returnPressed.connect(self._send_message)
            input_layout.addWidget(self.message_input, 1)
            
            self.send_btn = QPushButton("Send")
            self.send_btn.setEnabled(False)
            self.send_btn.setStyleSheet("""
                QPushButton {
                    background-color: #4fc3f7;
                    color: #000;
                    font-weight: bold;
                    padding: 8px 16px;
                    border-radius: 8px;
                    border: none;
                }
                QPushButton:hover {
                    background-color: #81d4fa;
                }
                QPushButton:disabled {
                    background-color: #3a3a4a;
                    color: #666;
                }
            """)
            self.send_btn.clicked.connect(self._send_message)
            input_layout.addWidget(self.send_btn)
            
            layout.addLayout(input_layout)
            
        def _setup_signals(self):
            self.message_received.connect(self._on_message_received)
            self.connection_changed.connect(self._on_connection_changed)
            self.user_count_updated.connect(self._on_user_count_updated)
            self.system_message.connect(self._add_system_message)
            self.rooms_loaded.connect(self._do_update_rooms_list)
            self.invites_updated.connect(self._update_invites_badge)
            self.room_created.connect(self._on_room_created)
            self.message_deleted.connect(self._on_message_deleted_from_server)
            self.invite_accepted.connect(self._on_invite_accepted)
            self.invite_received.connect(self._on_invite_received_inline)
            
        def connect_chat(self, username: str):
            """Connect to the chat server with JWT token authentication."""
            if self.connected:
                return
                
            self.username = username
            
            # Get the JWT token from the plugin store API
            if not plugin_store_api.is_logged_in() or not plugin_store_api.token:
                self._add_system_message("Login required to use chat")
                return
            
            # Store token for API calls
            self.token = plugin_store_api.token
            
            # Import socketio here to avoid issues if not installed
            try:
                import socketio
            except ImportError:
                self._add_system_message("Error: python-socketio not installed. Install with: pip install python-socketio[client]")
                return
            
            # Try curl_cffi first (bypasses Cloudflare TLS fingerprinting), fall back to requests
            http_session = None
            try:
                from curl_cffi.requests import Session as CurlSession
                http_session = CurlSession()
                http_session.headers.update({
                    'User-Agent': f'ImageAnarchy/{APP_VERSION}',
                    'CF-Access-Client-Id': CF_ACCESS_CLIENT_ID,
                    'CF-Access-Client-Secret': CF_ACCESS_CLIENT_SECRET
                })
            except ImportError:
                # Fall back to requests - may have issues with Cloudflare but often works
                try:
                    import requests
                    http_session = requests.Session()
                    http_session.headers.update({
                        'User-Agent': f'ImageAnarchy/{APP_VERSION}',
                        'CF-Access-Client-Id': CF_ACCESS_CLIENT_ID,
                        'CF-Access-Client-Secret': CF_ACCESS_CLIENT_SECRET
                    })
                except ImportError:
                    self._add_system_message("Error: No HTTP library available. Install: pip install curl_cffi")
                    return
            
            # Create socket.io client with the pre-configured http session
            # Using more aggressive reconnection settings for reliability with polling transport
            self.sio = socketio.Client(
                reconnection=True,
                reconnection_attempts=0,  # 0 = infinite reconnection attempts
                reconnection_delay=1,
                reconnection_delay_max=10,
                logger=False,  # Disable verbose logging
                engineio_logger=False,  # Disable engine.io logging
                http_session=http_session  # Use curl_cffi session to bypass CF fingerprinting
            )
            
            # Reference to self for nested functions
            chat_widget = self
            
            # Setup event handlers matching server.js
            @self.sio.event
            def connect():
                logger.debug("[CHAT] Socket.IO connected event fired")
                chat_widget.connected = True
                chat_widget.connection_changed.emit(True, "Connected")
                chat_widget._load_chat_history()
                
            @self.sio.event
            def disconnect():
                logger.debug("[CHAT] Socket.IO disconnected event fired")
                chat_widget.connected = False
                chat_widget.connection_changed.emit(False, "Disconnected")
                
            @self.sio.event
            def connect_error(data):
                logger.error(f"[CHAT] Socket.IO connect_error: {data}")
                chat_widget.connected = False
                error_msg = str(data) if data else "Connection failed"
                chat_widget.connection_changed.emit(False, "Connection error")
                chat_widget.system_message.emit(f"⚠️ {error_msg}")
                
            # Server event: new_message
            @self.sio.on('new_message')
            def on_new_message(data):
                chat_widget.message_received.emit(data)
                
            # Server event: user_joined
            @self.sio.on('user_joined')
            def on_user_joined(data):
                username = data.get('username', 'Someone')
                # Store own user info if this is us
                if data.get('is_self'):
                    chat_widget.user_id = data.get('user_id')
                    chat_widget.username = username
                    chat_widget.is_admin = data.get('is_admin', False)
                chat_widget.system_message.emit(f"• {username} joined the chat")
                    
            # Server event: user_left  
            @self.sio.on('user_left')
            def on_user_left(data):
                username = data.get('username', 'Someone')
                chat_widget.system_message.emit(f"• {username} left the chat")
                    
            # Server event: online_users (sent on connect)
            @self.sio.on('online_users')
            def on_online_users(data):
                count = data.get('count', 0)
                # Get own user info from the users list
                users = data.get('users', [])
                for user in users:
                    if user.get('is_self'):
                        chat_widget.user_id = user.get('user_id')
                        chat_widget.username = user.get('username')
                        chat_widget.is_admin = user.get('is_admin', False)
                        break
                chat_widget.user_count_updated.emit(count)
                
            # Server event: online_count (sent on user leave)
            @self.sio.on('online_count')
            def on_online_count(data):
                count = data.get('count', 0)
                chat_widget.user_count_updated.emit(count)
                
            # Server event: user_typing
            @self.sio.on('user_typing')
            def on_user_typing(data):
                # Could show typing indicator, for now just ignore
                pass
                
            # Server event: room_joined (confirmation from server)
            @self.sio.on('room_joined')
            def on_room_joined(data):
                room_id = data.get('room_id')
                room_name = data.get('room_name', 'Unknown')
                if room_id and hasattr(chat_widget, '_pending_room_id') and chat_widget._pending_room_id == room_id:
                    chat_widget.current_room = room_id
                    chat_widget._pending_room_id = None
                    chat_widget.system_message.emit(f"• Joined {room_name}")
            
            # Server event: error
            @self.sio.on('error')
            def on_error(data):
                msg = data.get('message', 'Unknown error')
                chat_widget.system_message.emit(f"⚠️ {msg}")
                # If we had a pending room join that failed, revert selector
                if hasattr(chat_widget, '_pending_room_id') and chat_widget._pending_room_id:
                    chat_widget._pending_room_id = None
                    # Revert to previous room in selector
                    if chat_widget.current_room:
                        idx = chat_widget.room_selector.findData(chat_widget.current_room)
                        if idx >= 0:
                            chat_widget.room_selector.blockSignals(True)
                            chat_widget.room_selector.setCurrentIndex(idx)
                            chat_widget.room_selector.blockSignals(False)
                
            # Server event: invite_received
            @self.sio.on('invite_received')
            def on_invite_received(data):
                # Normalize real-time event keys to match DB row shape
                # Server sends: invite_id, inviter — DB rows have: id, inviter_username
                if 'invite_id' in data and 'id' not in data:
                    data['id'] = data['invite_id']
                if 'inviter' in data and 'inviter_username' not in data:
                    data['inviter_username'] = data['inviter']
                chat_widget.pending_invites.append(data)
                chat_widget.invites_updated.emit()
                # Show actionable inline notification in main thread
                chat_widget.invite_received.emit(data)
                    
            # Server event: pending_invites (sent on connect)
            @self.sio.on('pending_invites')
            def on_pending_invites(data):
                chat_widget.pending_invites = data.get('invites', [])
                chat_widget.invites_updated.emit()
                # Show inline notification for each pending invite
                for inv in chat_widget.pending_invites:
                    chat_widget.invite_received.emit(inv)
                
            # Server event: message_deleted
            @self.sio.on('message_deleted')
            def on_message_deleted(data):
                msg_id = data.get('id')
                # Only emit signal - UI update handled in main thread by _on_message_deleted_from_server
                chat_widget.message_deleted.emit(msg_id)
                            
            # Server event: banned
            @self.sio.on('banned')
            def on_banned(data):
                reason = data.get('reason', 'No reason given')
                expires = data.get('expires_at')
                msg = f"🚫 You have been banned"
                if expires:
                    msg += f" until {expires[:10]}"
                msg += f" - {reason}"
                chat_widget.system_message.emit(msg)
                
            # Server event: muted
            @self.sio.on('muted')
            def on_muted(data):
                expires = data.get('expires_at', 'unknown')
                chat_widget.system_message.emit(f"🔇 You have been muted until {expires[:16]}")
                
            # Server event: kicked
            @self.sio.on('kicked')
            def on_kicked(data):
                room_id = data.get('room_id')
                chat_widget.system_message.emit(f"👢 You have been kicked from the room")
                # Switch back to general - emit signal to handle in main thread
                if chat_widget.current_room == room_id:
                    chat_widget.invite_accepted.emit()  # Reuse this signal to trigger room refresh
            
            # Connect in background thread with JWT auth
            def do_connect():
                try:
                    # Chat connects to the main server URL (socket.io path)
                    chat_url = PLUGIN_STORE_URL
                    
                    logger.debug(f"[CHAT] Connecting to {chat_url}")
                    logger.debug(f"[CHAT] Token present: {bool(plugin_store_api.token)}")
                    logger.debug(f"[CHAT] Token length: {len(plugin_store_api.token) if plugin_store_api.token else 0}")
                    
                    # Socket.IO auth - pass JWT token
                    # Use polling transport only - websocket-client library has different
                    # TLS fingerprint that gets blocked by Cloudflare. curl_cffi handles
                    # the polling transport and bypasses Cloudflare's TLS fingerprinting.
                    chat_widget.sio.connect(
                        chat_url,
                        auth={'token': plugin_store_api.token},
                        headers=get_cf_headers(),
                        transports=['polling']  # Polling only - bypasses CF fingerprinting
                    )
                    logger.debug(f"[CHAT] Connection successful")
                except Exception as e:
                    logger.error(f"[CHAT] Connection failed: {str(e)}")
                    import traceback
                    logger.error(f"[CHAT] Traceback: {traceback.format_exc()}")
                    chat_widget.connection_changed.emit(False, "Failed to connect")
                    chat_widget.system_message.emit(f"⚠️ Connection failed: {str(e)[:100]}")
                    
            import threading
            thread = threading.Thread(target=do_connect, daemon=True)
            thread.start()
            
        def _load_chat_history(self):
            """Load recent chat history from REST API."""
            def fetch_history():
                try:
                    import urllib.request
                    import json
                    
                    url = f"{PLUGIN_STORE_URL}/api/chat/messages?limit=50"
                    headers = {
                        'User-Agent': f'ImageAnarchy/{APP_VERSION}',
                        'Authorization': f'Bearer {plugin_store_api.token}'
                    }
                    headers.update(get_cf_headers())
                    
                    req = urllib.request.Request(url, headers=headers)
                    with urllib.request.urlopen(req, timeout=10) as response:
                        data = json.loads(response.read().decode())
                        messages = data.get('messages', [])
                        
                        # Add messages to chat (they come in chronological order)
                        for msg in messages:
                            self.message_received.emit(msg)
                except Exception as e:
                    pass  # Silently fail - history is optional
                    
            import threading
            thread = threading.Thread(target=fetch_history, daemon=True)
            thread.start()
            
        def disconnect_chat(self):
            """Disconnect from the chat server."""
            if self.sio and self.connected:
                try:
                    self.sio.disconnect()
                except:
                    pass
            self.connected = False
            self.username = None
            self._on_connection_changed(False, "Disconnected")
            
        def _send_message(self):
            """Send a chat message."""
            if not self.connected or not self.sio:
                return
                
            message = self.message_input.text().strip()
            if not message:
                return
                
            self.message_input.clear()
            
            # Send to server with room_id
            try:
                self.sio.emit('message', {
                    'message': message,
                    'room_id': self.current_room
                })
            except Exception as e:
                self._add_system_message(f"⚠️ Failed to send message")
                
        def _on_message_received(self, data: dict):
            """Handle received chat message from server.
            
            Server sends: {id, user_id, username, is_admin, message, created_at, message_type, attachment_url, attachment_name}
            """
            username = data.get('username', 'Anonymous')
            message = data.get('message', '')
            created_at = data.get('created_at', '')
            is_admin = data.get('is_admin', False)
            message_id = data.get('id')
            sender_user_id = data.get('user_id')
            message_type = data.get('message_type', 'text')
            attachment_url = data.get('attachment_url')
            attachment_name = data.get('attachment_name')
            
            # Show toast notification if chat is not visible or minimized
            # Don't notify for own messages
            if username != self.username:
                # Check if chat panel is visible and app is focused
                is_chat_visible = self.isVisible() and not self.isMinimized()
                main_window = self.window()
                is_app_focused = main_window.isActiveWindow() if main_window else False
                
                # Show toast if chat isn't visible or app isn't focused
                if not is_chat_visible or not is_app_focused:
                    # Find the main window to show toast
                    if main_window and hasattr(main_window, '_show_toast'):
                        toast_msg = f"💬 {username}: {message[:50]}{'...' if len(message) > 50 else ''}"
                        main_window._show_toast(toast_msg, 'info')
            
            # Parse timestamp
            timestamp = ''
            if created_at:
                try:
                    from datetime import datetime
                    dt = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                    timestamp = dt.strftime('%H:%M')
                except:
                    timestamp = created_at[:5] if len(created_at) >= 5 else ''
            
            # Create message widget
            msg_widget = QWidget()
            msg_widget.setProperty('message_id', message_id)
            msg_widget.setProperty('sender_user_id', sender_user_id)
            msg_widget.setProperty('sender_username', username)
            msg_layout = QVBoxLayout(msg_widget)
            msg_layout.setContentsMargins(4, 2, 4, 2)
            msg_layout.setSpacing(1)
            
            # Username and timestamp
            header = QHBoxLayout()
            header.setSpacing(6)
            
            name_label = QLabel(username)
            name_color = "#ff9800" if is_admin else "#4fc3f7" if username == self.username else "#9c27b0"
            name_label.setStyleSheet(f"color: {name_color}; font-weight: bold; font-size: 11px;")
            header.addWidget(name_label)
            
            if is_admin:
                admin_badge = QLabel("admin")
                admin_badge.setStyleSheet("color: #fff; background-color: #ff9800; padding: 1px 4px; border-radius: 3px; font-size: 9px;")
                header.addWidget(admin_badge)
            
            header.addStretch()
            
            if timestamp:
                time_label = QLabel(timestamp)
                time_label.setStyleSheet("color: #666; font-size: 9px;")
                header.addWidget(time_label)
            
            msg_layout.addLayout(header)
            
            # Handle different message types
            if message_type == 'image' and attachment_url:
                # Show image thumbnail
                img_label = QLabel(f"🖼️ {attachment_name or 'Image'}")
                img_label.setStyleSheet("color: #4fc3f7; font-size: 12px; text-decoration: underline;")
                img_label.setCursor(Qt.CursorShape.PointingHandCursor)
                img_label.setProperty('url', attachment_url)
                img_label.mousePressEvent = lambda e, url=attachment_url: self._open_attachment(url)
                msg_layout.addWidget(img_label)
            elif message_type == 'file' and attachment_url:
                # Show file link
                file_label = QLabel(f"📎 {attachment_name or 'File'}")
                file_label.setStyleSheet("color: #81d4fa; font-size: 12px; text-decoration: underline;")
                file_label.setCursor(Qt.CursorShape.PointingHandCursor)
                file_label.mousePressEvent = lambda e, url=attachment_url: self._open_attachment(url)
                msg_layout.addWidget(file_label)
            else:
                # Regular text message
                msg_label = QLabel(message)
                msg_label.setWordWrap(True)
                msg_label.setStyleSheet("color: #ddd; font-size: 12px;")
                msg_layout.addWidget(msg_label)
            
            # Enable context menu for message deletion
            msg_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            msg_widget.customContextMenuRequested.connect(
                lambda pos, w=msg_widget: self._show_message_context_menu(pos, w)
            )
            
            # Insert before the stretch
            self.messages_layout.insertWidget(self.messages_layout.count() - 1, msg_widget)
            
            # Auto-scroll to bottom
            QTimer.singleShot(50, lambda: self.chat_area.verticalScrollBar().setValue(
                self.chat_area.verticalScrollBar().maximum()
            ))
            
        def _open_attachment(self, url: str):
            """Open attachment URL in browser."""
            import webbrowser
            webbrowser.open(url)
            
        def _show_message_context_menu(self, pos, msg_widget: QWidget):
            """Show context menu for a message."""
            message_id = msg_widget.property('message_id')
            sender_user_id = msg_widget.property('sender_user_id')
            sender_username = msg_widget.property('sender_username')
            
            if not message_id:
                return
                
            menu = QMenu(self)
            menu.setStyleSheet("""
                QMenu {
                    background-color: #2a2a3a;
                    border: 1px solid #444;
                    padding: 4px;
                }
                QMenu::item {
                    padding: 6px 20px;
                    color: #ddd;
                }
                QMenu::item:selected {
                    background-color: #3a3a4a;
                }
            """)
            
            # Delete option - only for own messages or admins
            can_delete = (sender_user_id == self.user_id) or self.is_admin
            if can_delete:
                delete_action = menu.addAction("🗑️ Delete Message")
                delete_action.triggered.connect(lambda: self._delete_message(message_id, msg_widget))
                
            # Admin moderation options
            if self.is_admin and sender_user_id != self.user_id:
                menu.addSeparator()
                
                mute_action = menu.addAction(f"🔇 Mute {sender_username}")
                mute_action.triggered.connect(lambda: self._mute_user(sender_user_id, sender_username))
                
                kick_action = menu.addAction(f"👢 Kick {sender_username}")
                kick_action.triggered.connect(lambda: self._kick_user(sender_user_id, sender_username))
                
                ban_action = menu.addAction(f"🚫 Ban {sender_username}")
                ban_action.triggered.connect(lambda: self._ban_user(sender_user_id, sender_username))
                
            if menu.actions():
                menu.exec(msg_widget.mapToGlobal(pos))
                
        def _delete_message(self, message_id: int, msg_widget: QWidget):
            """Delete a chat message."""
            if not self.token or not message_id:
                return
                
            def do_delete():
                try:
                    http_requests = get_http_requests()
                    if not http_requests:
                        self.system_message.emit("⚠️ HTTP library not available")
                        return
                    headers = {'Authorization': f'Bearer {self.token}'}
                    headers.update(get_cf_headers())
                    resp = http_requests.delete(
                        f'{PLUGIN_STORE_URL}/api/chat/messages/{message_id}',
                        headers=headers,
                        timeout=10
                    )
                    if resp.status_code == 200:
                        self.message_deleted.emit(message_id)
                    else:
                        self.system_message.emit("⚠️ Failed to delete message")
                except:
                    self.system_message.emit("⚠️ Error deleting message")
            
            import threading
            threading.Thread(target=do_delete, daemon=True).start()
            
        def _mute_user(self, user_id: int, username: str):
            """Mute a user (admin only)."""
            self._moderate_user('mute', user_id, username, "5 minutes")
            
        def _kick_user(self, user_id: int, username: str):
            """Kick a user from the room (admin only)."""
            self._moderate_user('kick', user_id, username)
            
        def _ban_user(self, user_id: int, username: str):
            """Ban a user (admin only)."""
            # Show duration dialog
            duration, ok = QInputDialog.getItem(
                self, "Ban Duration", f"Ban {username} for:",
                ["1 hour", "24 hours", "7 days", "30 days", "Permanent"],
                0, False
            )
            if ok and duration:
                self._moderate_user('ban', user_id, username, duration)
                
        def _moderate_user(self, action: str, user_id: int, username: str, duration: str = None):
            """Send moderation action to server."""
            if not self.token or not self.is_admin:
                return
                
            def do_moderate():
                try:
                    http_requests = get_http_requests()
                    if not http_requests:
                        self.system_message.emit("⚠️ HTTP library not available")
                        return
                    import hashlib
                    import time
                    
                    # Build headers with CF headers and app signature
                    endpoint = f'/api/chat/{action}'
                    timestamp = str(int(time.time() * 1000))
                    app_secret = 'ImageAnarchy-Plugin-Store-2026'
                    hourly_key = int(timestamp) // (60 * 60 * 1000)
                    sig_data = f"{app_secret}:{hourly_key}:{endpoint}"
                    signature = hashlib.sha256(sig_data.encode()).hexdigest()[:16]
                    
                    headers = {
                        'Authorization': f'Bearer {self.token}',
                        'Content-Type': 'application/json',
                        'X-App-Signature': signature,
                        'X-App-Timestamp': timestamp
                    }
                    headers.update(get_cf_headers())
                    data = {'user_id': user_id}
                    if self.current_room and self.current_room != 'general':
                        data['room_id'] = self.current_room
                    if duration:
                        data['duration'] = duration
                        
                    resp = http_requests.post(
                        f'{PLUGIN_STORE_URL}{endpoint}',
                        json=data,
                        headers=headers,
                        timeout=10
                    )
                    if resp.status_code == 200:
                        action_name = {'mute': 'muted', 'kick': 'kicked', 'ban': 'banned'}[action]
                        self.system_message.emit(f"✅ {username} has been {action_name}")
                    else:
                        self.system_message.emit(f"⚠️ Failed to {action} user")
                except:
                    self.system_message.emit(f"⚠️ Error with moderation action")
            
            import threading
            threading.Thread(target=do_moderate, daemon=True).start()
            
        def _add_system_message(self, text: str):
            """Add a system message to the chat."""
            label = QLabel(text)
            label.setStyleSheet("color: #888; font-size: 11px; font-style: italic;")
            label.setWordWrap(True)
            self.messages_layout.insertWidget(self.messages_layout.count() - 1, label)
            
            # Auto-scroll
            QTimer.singleShot(50, lambda: self.chat_area.verticalScrollBar().setValue(
                self.chat_area.verticalScrollBar().maximum()
            ))
            
        def _on_invite_received_inline(self, data: dict):
            """Show an actionable inline invite notification in the chat area."""
            invite_id = data.get('id')
            inviter = data.get('inviter_username', 'Someone')
            room_name = data.get('room_name', 'a room')
            
            # Don't duplicate — check if we already have an inline widget for this invite
            for i in range(self.messages_layout.count()):
                item = self.messages_layout.itemAt(i)
                if item and item.widget() and item.widget().property('invite_id') == invite_id:
                    return
            
            # Build the inline widget
            container = QWidget()
            container.setProperty('invite_id', invite_id)
            container.setStyleSheet(
                "QWidget { background: #1a2a1a; border: 1px solid #4CAF50; border-radius: 6px; margin: 2px 4px; }"
            )
            row = QHBoxLayout(container)
            row.setContentsMargins(8, 6, 8, 6)
            row.setSpacing(8)
            
            label = QLabel(f"📨 <b>{inviter}</b> invited you to <b>'{room_name}'</b>")
            label.setStyleSheet("color: #ccc; font-size: 12px; border: none; background: transparent;")
            label.setWordWrap(True)
            row.addWidget(label, 1)
            
            accept_btn = QPushButton("✓ Accept")
            accept_btn.setFixedHeight(26)
            accept_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            accept_btn.setStyleSheet(
                "QPushButton { background: #4CAF50; color: #fff; font-weight: bold; font-size: 11px;"
                "  border-radius: 4px; padding: 2px 10px; border: none; }"
                "QPushButton:hover { background: #66BB6A; }"
            )
            row.addWidget(accept_btn)
            
            decline_btn = QPushButton("✗")
            decline_btn.setFixedWidth(28)
            decline_btn.setFixedHeight(26)
            decline_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            decline_btn.setStyleSheet(
                "QPushButton { background: #555; color: #ccc; font-size: 11px;"
                "  border-radius: 4px; border: none; }"
                "QPushButton:hover { background: #f44336; color: #fff; }"
            )
            row.addWidget(decline_btn)
            
            def on_accept():
                accept_btn.setEnabled(False)
                decline_btn.setEnabled(False)
                accept_btn.setText("Accepting...")
                self._respond_to_invite_inline(invite_id, True, container)
            
            def on_decline():
                accept_btn.setEnabled(False)
                decline_btn.setEnabled(False)
                self._respond_to_invite_inline(invite_id, False, container)
            
            accept_btn.clicked.connect(on_accept)
            decline_btn.clicked.connect(on_decline)
            
            self.messages_layout.insertWidget(self.messages_layout.count() - 1, container)
            QTimer.singleShot(50, lambda: self.chat_area.verticalScrollBar().setValue(
                self.chat_area.verticalScrollBar().maximum()
            ))
        
        def _respond_to_invite_inline(self, invite_id: str, accept: bool, widget: QWidget):
            """Accept or decline an invite from the inline chat widget."""
            if not self.token:
                return
            
            def do_respond():
                try:
                    http_requests = get_http_requests()
                    if not http_requests:
                        self.system_message.emit("⚠️ HTTP library not available")
                        return
                    import hashlib
                    import time
                    
                    action = 'accept' if accept else 'decline'
                    endpoint = f'/api/chat/invites/{invite_id}/{action}'
                    timestamp = str(int(time.time() * 1000))
                    app_secret = 'ImageAnarchy-Plugin-Store-2026'
                    hourly_key = int(timestamp) // (60 * 60 * 1000)
                    sig_data = f"{app_secret}:{hourly_key}:{endpoint}"
                    signature = hashlib.sha256(sig_data.encode()).hexdigest()[:16]
                    
                    headers = {
                        'Authorization': f'Bearer {self.token}',
                        'X-App-Signature': signature,
                        'X-App-Timestamp': timestamp
                    }
                    headers.update(get_cf_headers())
                    
                    resp = http_requests.post(
                        f'{PLUGIN_STORE_URL}{endpoint}',
                        headers=headers,
                        timeout=10
                    )
                    if resp.status_code == 200:
                        self.pending_invites = [i for i in self.pending_invites if i.get('id') != invite_id]
                        if accept:
                            self.system_message.emit("✅ Invite accepted! Refreshing rooms...")
                            self.invite_accepted.emit()
                        else:
                            self.system_message.emit("Invite declined")
                        self.invites_updated.emit()
                        # Remove the inline widget in main thread
                        QTimer.singleShot(0, widget.deleteLater)
                    else:
                        try:
                            err = resp.json().get('error', f'Failed ({resp.status_code})')
                        except Exception:
                            err = f'Server error ({resp.status_code})'
                        self.system_message.emit(f"⚠️ {err}")
                        # Re-enable buttons
                        QTimer.singleShot(0, lambda: self._reenable_invite_widget(widget, accept))
                except Exception as e:
                    logger.error(f"[CHAT] Invite respond error: {e}")
                    self.system_message.emit(f"⚠️ Error: {str(e)[:60]}")
                    QTimer.singleShot(0, lambda: self._reenable_invite_widget(widget, accept))
            
            import threading
            threading.Thread(target=do_respond, daemon=True).start()
        
        def _reenable_invite_widget(self, widget: QWidget, was_accept: bool):
            """Re-enable buttons on an inline invite widget after failure."""
            try:
                layout = widget.layout()
                if layout:
                    for i in range(layout.count()):
                        item = layout.itemAt(i)
                        if item and item.widget() and isinstance(item.widget(), QPushButton):
                            btn = item.widget()
                            btn.setEnabled(True)
                            if '✓' in btn.text() or 'Accept' in btn.text():
                                btn.setText("✓ Accept")
            except Exception:
                pass
        
        def _remove_inline_invite(self, invite_id: str):
            """Remove an inline invite widget by invite_id (called from dialog accept too)."""
            try:
                for i in range(self.messages_layout.count()):
                    item = self.messages_layout.itemAt(i)
                    if item and item.widget() and item.widget().property('invite_id') == invite_id:
                        item.widget().deleteLater()
                        break
            except Exception:
                pass
        
        def _on_message_deleted_from_server(self, message_id: int):
            """Handle message deletion - find and remove the widget."""
            for i in range(self.messages_layout.count()):
                item = self.messages_layout.itemAt(i)
                if item and item.widget():
                    widget = item.widget()
                    if widget.property('message_id') == message_id:
                        widget.deleteLater()
                        break
                        
        def _on_invite_accepted(self):
            """Handle invite accepted - reload rooms."""
            self._load_rooms()
            
        def _on_connection_changed(self, connected: bool, status: str):
            """Handle connection status change."""
            self.status_indicator.setStyleSheet(
                f"color: {'#4CAF50' if connected else '#666'}; font-size: 14px;"
            )
            self.connection_status.setText(status)
            self.message_input.setEnabled(connected)
            self.send_btn.setEnabled(connected)
            self.attach_btn.setEnabled(connected)
            
            if connected:
                self._add_system_message("• Connected to chat")
                self._load_rooms()  # Load available rooms
            else:
                self._add_system_message("• Disconnected from chat")
                
        def _on_user_count_updated(self, count: int):
            """Update online user count."""
            self.online_count.setText(f"• {count} online")
            
        def _on_room_changed(self, index: int):
            """Handle room selection change."""
            if index < 0 or not self.connected:
                return
                
            room_id = self.room_selector.currentData()
            if room_id and room_id != self.current_room:
                meta = getattr(self, '_room_meta', {}).get(room_id, {})
                
                # Password-protected room the user hasn't joined yet
                if meta.get('has_password') and not meta.get('is_member'):
                    self._prompt_room_password(room_id)
                else:
                    self._join_room(room_id)
        
        def _prompt_room_password(self, room_id: str):
            """Show password dialog for a locked room, then join via REST API."""
            room_name = self.room_selector.currentText()
            
            dialog = QDialog(self)
            dialog.setWindowTitle("🔒 Room Password Required")
            dialog.setFixedWidth(320)
            dialog.setStyleSheet(
                "QDialog { background: #1e1e2e; }"
                "QLabel { color: #ddd; font-size: 12px; }"
            )
            layout = QVBoxLayout(dialog)
            layout.setSpacing(10)
            
            header = QLabel(f"Enter password for {room_name}:")
            header.setStyleSheet("font-weight: bold; color: #4fc3f7; font-size: 13px;")
            layout.addWidget(header)
            
            pw_input = QLineEdit()
            pw_input.setEchoMode(QLineEdit.EchoMode.Password)
            pw_input.setPlaceholderText("Room password")
            pw_input.setStyleSheet(
                "background: #2a2a3a; border: 1px solid #555; border-radius: 4px;"
                "padding: 8px; color: #fff; font-size: 13px;"
            )
            layout.addWidget(pw_input)
            
            error_label = QLabel("")
            error_label.setStyleSheet("color: #f44336; font-size: 11px;")
            error_label.setVisible(False)
            layout.addWidget(error_label)
            
            btn_layout = QHBoxLayout()
            cancel_btn = QPushButton("Cancel")
            cancel_btn.setAutoDefault(False)
            cancel_btn.setDefault(False)
            cancel_btn.setStyleSheet("padding: 6px 16px; background: #333; color: #ccc; border-radius: 4px;")
            join_btn = QPushButton("Join")
            join_btn.setAutoDefault(True)
            join_btn.setDefault(True)
            join_btn.setStyleSheet(
                "padding: 6px 16px; background: qlineargradient(x1:0,y1:0,x2:1,y2:0,"
                "stop:0 #e53935, stop:1 #ff5252); color: white; font-weight: bold; border-radius: 4px;"
            )
            btn_layout.addWidget(cancel_btn)
            btn_layout.addWidget(join_btn)
            layout.addLayout(btn_layout)
            
            def do_join():
                password = pw_input.text()
                if not password:
                    error_label.setText("Password is required")
                    error_label.setVisible(True)
                    return
                
                join_btn.setEnabled(False)
                join_btn.setText("Joining...")
                error_label.setVisible(False)
                QApplication.processEvents()
                
                # Synchronous call — dialog is modal so brief block is fine
                try:
                    http_requests = get_http_requests()
                    if not http_requests:
                        raise Exception('No HTTP library available')
                    
                    import hashlib, time as _time
                    endpoint = f'/api/chat/rooms/{room_id}/join'
                    timestamp = str(int(_time.time() * 1000))
                    app_secret = 'ImageAnarchy-Plugin-Store-2026'
                    hourly_key = int(timestamp) // (60 * 60 * 1000)
                    sig_data = f"{app_secret}:{hourly_key}:{endpoint}"
                    signature = hashlib.sha256(sig_data.encode()).hexdigest()[:16]
                    
                    headers = {
                        'Authorization': f'Bearer {self.token}',
                        'Content-Type': 'application/json',
                        'X-App-Signature': signature,
                        'X-App-Timestamp': timestamp,
                    }
                    headers.update(get_cf_headers())
                    
                    resp = http_requests.post(
                        f'{PLUGIN_STORE_URL}{endpoint}',
                        json={'password': password},
                        headers=headers,
                        timeout=10,
                    )
                    result = resp.json() if resp.status_code in (200, 401, 403, 429) else {'error': f'Server error {resp.status_code}'}
                except Exception as e:
                    result = {'error': str(e)}
                
                if result.get('success'):
                    # Mark as member locally
                    if hasattr(self, '_room_meta') and room_id in self._room_meta:
                        self._room_meta[room_id]['is_member'] = True
                    # Update icon in selector
                    idx = self.room_selector.findData(room_id)
                    if idx >= 0:
                        name = self.room_selector.itemText(idx)
                        self.room_selector.setItemText(idx, name.replace('🔒', '🔓', 1))
                    dialog.accept()
                    self._join_room(room_id)
                else:
                    error_msg = result.get('error', 'Failed to join room')
                    error_label.setText(error_msg)
                    error_label.setVisible(True)
                    join_btn.setEnabled(True)
                    join_btn.setText("Join")
            
            join_btn.clicked.connect(do_join)
            pw_input.returnPressed.connect(do_join)
            cancel_btn.clicked.connect(dialog.reject)
            
            if dialog.exec() == QDialog.DialogCode.Rejected:
                # Revert selector to previous room
                if self.current_room:
                    idx = self.room_selector.findData(self.current_room)
                    if idx >= 0:
                        self.room_selector.blockSignals(True)
                        self.room_selector.setCurrentIndex(idx)
                        self.room_selector.blockSignals(False)
                
        def _join_room(self, room_id: str, password: str = None):
            """Join a chat room via Socket.IO (must already be a member for private rooms)."""
            if not self.sio:
                return
                
            try:
                # Leave current room first
                if self.current_room:
                    self.sio.emit('leave_room', {'room_id': self.current_room})
                    
                # Store pending join — confirmed when server sends 'room_joined'
                self._pending_room_id = room_id
                
                # Join new room
                data = {'room_id': room_id}
                if password:
                    data['password'] = password
                self.sio.emit('join_room', data)
                
                # Clear messages and show connecting message
                self._clear_messages()
                self._add_system_message("• Connecting to room...")
            except Exception as e:
                self._add_system_message(f"⚠️ Failed to join room")
                
        def _clear_messages(self):
            """Clear all messages from the chat area."""
            while self.messages_layout.count() > 1:  # Keep the stretch
                item = self.messages_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
                    
        def _load_rooms(self):
            """Load available rooms from server."""
            if not self.token:
                return
                
            def fetch_rooms():
                try:
                    http_requests = get_http_requests()

                    if not http_requests:

                        return

                    headers = {'Authorization': f'Bearer {self.token}'}
                    headers.update(get_cf_headers())
                    resp = http_requests.get(
                        f'{PLUGIN_STORE_URL}/api/chat/rooms',
                        headers=headers,
                        timeout=10
                    )
                    if resp.status_code == 200:
                        return resp.json().get('rooms', [])
                except:
                    pass
                return []
            
            def do_fetch():
                rooms = fetch_rooms()
                self.rooms_loaded.emit(rooms)
                
            # Run in background thread
            import threading
            thread = threading.Thread(target=do_fetch, daemon=True)
            thread.start()
            
        def _do_update_rooms_list(self, rooms: list):
            """Actually update the rooms list in UI thread."""
            current = self.room_selector.currentData()
            self.room_selector.blockSignals(True)
            self.room_selector.clear()
            self.room_selector.addItem("🌐 General", "general")
            
            # Store room metadata for password prompt logic
            if not hasattr(self, '_room_meta'):
                self._room_meta = {}
            self._room_meta = {'general': {'has_password': False, 'is_member': True}}
            
            for room in rooms:
                has_pw = bool(room.get('has_password'))
                is_member = bool(room.get('is_member'))
                room_id = room.get('id')
                name = room.get('name', 'Unknown')
                
                # Icon: locked if password-protected and not a member yet
                if has_pw and not is_member:
                    icon = "🔒"
                elif has_pw and is_member:
                    icon = "🔓"  # Unlocked — already a member
                elif room.get('is_private'):
                    icon = "🔒"
                else:
                    icon = "💬"
                
                self.room_selector.addItem(f"{icon} {name}", room_id)
                self._room_meta[room_id] = {'has_password': has_pw, 'is_member': is_member}
                
            # Restore selection if possible
            if current:
                idx = self.room_selector.findData(current)
                if idx >= 0:
                    self.room_selector.setCurrentIndex(idx)
            self.room_selector.blockSignals(False)
            
        def _show_create_room_dialog(self):
            """Show dialog to create a new room."""
            if not self.connected:
                return
                
            dialog = QDialog(self)
            dialog.setWindowTitle("Create Room")
            dialog.setFixedWidth(300)
            dialog.setStyleSheet("QDialog { background: #1e1e1e; } QLabel { color: #ddd; }")
            
            layout = QVBoxLayout(dialog)
            
            # Room name
            layout.addWidget(QLabel("Room Name:"))
            name_input = QLineEdit()
            name_input.setPlaceholderText("Enter room name")
            name_input.setStyleSheet("background: #2a2a2a; border: 1px solid #444; padding: 6px; color: #fff;")
            layout.addWidget(name_input)
            
            # Private checkbox
            private_cb = QCheckBox("Private Room (password required)")
            private_cb.setStyleSheet("color: #ddd;")
            layout.addWidget(private_cb)
            
            # Password (shown when private is checked)
            pw_label = QLabel("Password:")
            pw_input = QLineEdit()
            pw_input.setEchoMode(QLineEdit.EchoMode.Password)
            pw_input.setPlaceholderText("Room password")
            pw_input.setStyleSheet("background: #2a2a2a; border: 1px solid #444; padding: 6px; color: #fff;")
            pw_label.setVisible(False)
            pw_input.setVisible(False)
            layout.addWidget(pw_label)
            layout.addWidget(pw_input)
            
            private_cb.toggled.connect(lambda checked: (pw_label.setVisible(checked), pw_input.setVisible(checked)))
            
            # Buttons
            btn_layout = QHBoxLayout()
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            create_btn = QPushButton("Create")
            create_btn.setStyleSheet("background: #4fc3f7; color: #000; font-weight: bold;")
            btn_layout.addWidget(cancel_btn)
            btn_layout.addWidget(create_btn)
            layout.addLayout(btn_layout)
            
            def create_room():
                name = name_input.text().strip()
                if not name:
                    return
                password = pw_input.text() if private_cb.isChecked() else None
                self._create_room(name, private_cb.isChecked(), password)
                dialog.accept()
                
            create_btn.clicked.connect(create_room)
            dialog.exec()
            
        def _create_room(self, name: str, is_private: bool, password: str = None):
            """Create a new room on the server."""
            if not self.token:
                return
                
            def do_create():
                try:
                    http_requests = get_http_requests()
                    if not http_requests:
                        return
                    import hashlib
                    import time
                    
                    # Build headers with CF headers and app signature
                    endpoint = '/api/chat/rooms'
                    timestamp = str(int(time.time() * 1000))
                    app_secret = 'ImageAnarchy-Plugin-Store-2026'
                    hourly_key = int(timestamp) // (60 * 60 * 1000)
                    sig_data = f"{app_secret}:{hourly_key}:{endpoint}"
                    signature = hashlib.sha256(sig_data.encode()).hexdigest()[:16]
                    
                    headers = {
                        'Authorization': f'Bearer {self.token}',
                        'Content-Type': 'application/json',
                        'X-App-Signature': signature,
                        'X-App-Timestamp': timestamp
                    }
                    headers.update(get_cf_headers())
                    data = {'name': name, 'is_private': is_private}
                    if password:
                        data['password'] = password
                    resp = http_requests.post(
                        f'{PLUGIN_STORE_URL}{endpoint}',
                        json=data,
                        headers=headers,
                        timeout=10
                    )
                    # Server returns 200 with success:true, not 201
                    if resp.status_code == 200:
                        result = resp.json()
                        if result.get('success'):
                            room = result.get('room', {})
                            self.room_created.emit(room)
                        else:
                            error_msg = result.get('error', 'Failed to create room')
                            self.system_message.emit(f"⚠️ {error_msg}")
                    else:
                        try:
                            error_msg = resp.json().get('error', f'Server error {resp.status_code}')
                        except:
                            error_msg = f'Server error {resp.status_code}'
                        self.system_message.emit(f"⚠️ {error_msg}")
                except Exception as e:
                    logger.error(f"[CHAT] Error creating room: {e}")
                    self.system_message.emit(f"⚠️ Error: {str(e)[:80]}")
            
            import threading
            threading.Thread(target=do_create, daemon=True).start()
            
        def _on_room_created(self, room: dict):
            """Handle successful room creation."""
            self._add_system_message(f"✅ Room '{room.get('name')}' created!")
            self._load_rooms()
            
        def _show_invite_dialog(self):
            """Show dialog to invite users to current room."""
            if not self.connected or self.current_room == 'general':
                self._add_system_message("⚠️ Select a room to invite users")
                return
                
            dialog = QDialog(self)
            dialog.setWindowTitle("Invite to Room")
            dialog.setFixedWidth(300)
            dialog.setStyleSheet("QDialog { background: #1e1e1e; } QLabel { color: #ddd; }")
            
            layout = QVBoxLayout(dialog)
            layout.addWidget(QLabel("Enter username or email:"))
            
            invitee_input = QLineEdit()
            invitee_input.setPlaceholderText("username or email@example.com")
            invitee_input.setStyleSheet("background: #2a2a2a; border: 1px solid #444; padding: 6px; color: #fff;")
            layout.addWidget(invitee_input)
            
            # Buttons
            btn_layout = QHBoxLayout()
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            invite_btn = QPushButton("Send Invite")
            invite_btn.setStyleSheet("background: #4fc3f7; color: #000; font-weight: bold;")
            btn_layout.addWidget(cancel_btn)
            btn_layout.addWidget(invite_btn)
            layout.addLayout(btn_layout)
            
            def send_invite():
                invitee = invitee_input.text().strip()
                if not invitee:
                    return
                self._send_invite(invitee)
                dialog.accept()
                
            invite_btn.clicked.connect(send_invite)
            dialog.exec()
            
        def _send_invite(self, invitee: str):
            """Send room invite to user."""
            if not self.token or not self.current_room:
                return
                
            def do_invite():
                try:
                    http_requests = get_http_requests()
                    if not http_requests:
                        return
                    import hashlib
                    import time
                    
                    # Build headers with CF headers and app signature
                    endpoint = '/api/chat/invites'
                    timestamp = str(int(time.time() * 1000))
                    app_secret = 'ImageAnarchy-Plugin-Store-2026'
                    hourly_key = int(timestamp) // (60 * 60 * 1000)
                    sig_data = f"{app_secret}:{hourly_key}:{endpoint}"
                    signature = hashlib.sha256(sig_data.encode()).hexdigest()[:16]
                    
                    logger.debug(f"[CHAT] Invite signature: {signature}, timestamp: {timestamp}")
                    
                    headers = {
                        'Authorization': f'Bearer {self.token}',
                        'Content-Type': 'application/json',
                        'X-App-Signature': signature,
                        'X-App-Timestamp': timestamp
                    }
                    headers.update(get_cf_headers())
                    
                    # Check if it's an email or username
                    is_email = '@' in invitee
                    data = {
                        'room_id': self.current_room,
                        'email' if is_email else 'username': invitee
                    }
                    resp = http_requests.post(
                        f'{PLUGIN_STORE_URL}{endpoint}',
                        json=data,
                        headers=headers,
                        timeout=10
                    )
                    if resp.status_code in (200, 201):
                        result = resp.json()
                        if result.get('is_new_user'):
                            self.system_message.emit(f"✅ Invite email sent to {invitee} (signup link included)")
                        else:
                            self.system_message.emit(f"✅ Invite sent to {invitee}")
                    else:
                        try:
                            msg = resp.json().get('error', f'Failed ({resp.status_code})')
                        except:
                            msg = f'Server error ({resp.status_code})'
                        self.system_message.emit(f"⚠️ {msg}")
                except Exception as e:
                    logger.error(f"[CHAT] Invite error: {e}")
                    self.system_message.emit(f"⚠️ Invite error: {str(e)[:50]}")
            
            import threading
            threading.Thread(target=do_invite, daemon=True).start()
            
        def _show_invites_dialog(self):
            """Show pending invites dialog."""
            if not self.pending_invites:
                QMessageBox.information(self, "Room Invitations", "📨 No pending invitations.\n\nWhen someone invites you to a room, it will appear here and in the chat.")
                return
                
            dialog = QDialog(self)
            dialog.setWindowTitle("Pending Invites")
            dialog.setFixedWidth(350)
            dialog.setStyleSheet("QDialog { background: #1e1e1e; } QLabel { color: #ddd; }")
            
            layout = QVBoxLayout(dialog)
            
            for invite in self.pending_invites:
                invite_widget = QWidget()
                invite_layout = QHBoxLayout(invite_widget)
                
                room_name = invite.get('room_name', 'Unknown Room')
                inviter = invite.get('inviter_username', 'Someone')
                invite_id = invite.get('id')
                
                label = QLabel(f"📨 {inviter} invited you to '{room_name}'")
                label.setWordWrap(True)
                invite_layout.addWidget(label, 1)
                
                accept_btn = QPushButton("✓")
                accept_btn.setFixedWidth(30)
                accept_btn.setStyleSheet("background: #4CAF50; color: #fff;")
                accept_btn.clicked.connect(lambda _, iid=invite_id: self._respond_to_invite(iid, True, dialog))
                invite_layout.addWidget(accept_btn)
                
                decline_btn = QPushButton("✗")
                decline_btn.setFixedWidth(30)
                decline_btn.setStyleSheet("background: #f44336; color: #fff;")
                decline_btn.clicked.connect(lambda _, iid=invite_id: self._respond_to_invite(iid, False, dialog))
                invite_layout.addWidget(decline_btn)
                
                layout.addWidget(invite_widget)
                
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(dialog.accept)
            layout.addWidget(close_btn)
            
            dialog.exec()
            
        def _respond_to_invite(self, invite_id: str, accept: bool, dialog: QDialog):
            """Accept or decline an invite."""
            if not self.token:
                return
                
            def do_respond():
                try:
                    http_requests = get_http_requests()
                    if not http_requests:
                        self.system_message.emit("⚠️ HTTP library not available")
                        return
                    import hashlib
                    import time
                    
                    # Build headers with CF headers and app signature
                    action = 'accept' if accept else 'decline'
                    endpoint = f'/api/chat/invites/{invite_id}/{action}'
                    timestamp = str(int(time.time() * 1000))
                    app_secret = 'ImageAnarchy-Plugin-Store-2026'
                    hourly_key = int(timestamp) // (60 * 60 * 1000)
                    sig_data = f"{app_secret}:{hourly_key}:{endpoint}"
                    signature = hashlib.sha256(sig_data.encode()).hexdigest()[:16]
                    
                    headers = {
                        'Authorization': f'Bearer {self.token}',
                        'X-App-Signature': signature,
                        'X-App-Timestamp': timestamp
                    }
                    headers.update(get_cf_headers())
                    
                    resp = http_requests.post(
                        f'{PLUGIN_STORE_URL}{endpoint}',
                        headers=headers,
                        timeout=10
                    )
                    if resp.status_code == 200:
                        # Remove from pending
                        self.pending_invites = [i for i in self.pending_invites if i.get('id') != invite_id]
                        if accept:
                            self.system_message.emit("✅ Invite accepted! Refreshing rooms...")
                            self.invite_accepted.emit()
                        else:
                            self.system_message.emit("Invite declined")
                        # Update badge
                        self.invites_updated.emit()
                        # Also remove any inline invite widget for this invite
                        QTimer.singleShot(0, lambda: self._remove_inline_invite(invite_id))
                    else:
                        try:
                            err = resp.json().get('error', f'Failed ({resp.status_code})')
                        except Exception:
                            err = f'Server error ({resp.status_code})'
                        self.system_message.emit(f"⚠️ {err}")
                except Exception as e:
                    logger.error(f"[CHAT] Invite respond error: {e}")
                    self.system_message.emit(f"⚠️ Error responding to invite: {str(e)[:50]}")
            
            import threading
            threading.Thread(target=do_respond, daemon=True).start()
            dialog.accept()
            
        def _update_invites_badge(self):
            """Update the invites button visibility based on pending count."""
            has_invites = len(self.pending_invites) > 0
            self.invites_btn.setVisible(has_invites)
            if has_invites:
                self.invites_btn.setText(f"🔔 {len(self.pending_invites)}")
                # Flash the button to draw attention
                self.invites_btn.setStyleSheet(
                    "QPushButton { background: #ff9800; border: 1px solid #ff9800; border-radius: 4px;"
                    "  color: #000; font-weight: bold; }"
                )
                # Reset style after 2 seconds
                QTimer.singleShot(2000, lambda: self.invites_btn.setStyleSheet(
                    "QPushButton { background: #333; border: 1px solid #555; border-radius: 4px; }"
                ) if self.invites_btn.isVisible() else None)
            else:
                self.invites_btn.setStyleSheet(
                    "QPushButton { background: #333; border: 1px solid #555; border-radius: 4px; }"
                )
                
        def _attach_file(self):
            """Open file dialog to attach a file or image."""
            if not self.connected or not self.token:
                return
                
            file_filter = "Images & Files (*.png *.jpg *.jpeg *.gif *.webp *.zip *.txt *.log);;All Files (*.*)"
            file_path, _ = QFileDialog.getOpenFileName(self, "Attach File", "", file_filter)
            
            if not file_path:
                return
                
            # Check file size (10MB max)
            import os
            file_size = os.path.getsize(file_path)
            if file_size > 10 * 1024 * 1024:
                self._add_system_message("⚠️ File too large (max 10MB)")
                return
                
            self._upload_file(file_path)
            
        def _upload_file(self, file_path: str):
            """Upload file to server and send as message."""
            self._add_system_message(f"📤 Uploading {os.path.basename(file_path)}...")
            
            def do_upload():
                mp = None
                try:
                    import os
                    import hashlib
                    import time
                    import mimetypes
                    
                    # Build headers with CF headers and app signature
                    endpoint = '/api/chat/upload'
                    timestamp = str(int(time.time() * 1000))
                    app_secret = 'ImageAnarchy-Plugin-Store-2026'
                    hourly_key = int(timestamp) // (60 * 60 * 1000)
                    sig_data = f"{app_secret}:{hourly_key}:{endpoint}"
                    signature = hashlib.sha256(sig_data.encode()).hexdigest()[:16]
                    
                    headers = {
                        'Authorization': f'Bearer {self.token}',
                        'X-App-Signature': signature,
                        'X-App-Timestamp': timestamp
                    }
                    headers.update(get_cf_headers())
                    
                    filename = os.path.basename(file_path)
                    content_type = mimetypes.guess_type(file_path)[0] or 'application/octet-stream'
                    
                    # Try curl_cffi first (better CF bypass), fall back to requests
                    try:
                        from curl_cffi import requests as curl_requests, CurlMime
                        # Use CurlMime for multipart upload
                        mp = CurlMime()
                        mp.addpart(
                            name="file",
                            content_type=content_type,
                            filename=filename,
                            local_path=file_path
                        )
                        resp = curl_requests.post(
                            f'{PLUGIN_STORE_URL}{endpoint}',
                            multipart=mp,
                            headers=headers,
                            timeout=60
                        )
                    except ImportError:
                        # Fall back to standard requests
                        import requests
                        with open(file_path, 'rb') as f:
                            files = {'file': (filename, f, content_type)}
                            resp = requests.post(
                                f'{PLUGIN_STORE_URL}{endpoint}',
                                files=files,
                                headers=headers,
                                timeout=60
                            )
                        
                    if resp.status_code == 200:
                        data = resp.json()
                        # Send message with attachment
                        attachment_url = data.get('url')
                        attachment_name = data.get('filename')
                        message_type = 'image' if any(attachment_name.lower().endswith(ext) for ext in ['.png', '.jpg', '.jpeg', '.gif', '.webp']) else 'file'
                        
                        if self.sio:
                            self.sio.emit('message', {
                                'message': f"📎 {attachment_name}",
                                'room_id': self.current_room,
                                'message_type': message_type,
                                'attachment_url': attachment_url,
                                'attachment_name': attachment_name
                            })
                        self.system_message.emit("✅ File sent!")
                    else:
                        try:
                            msg = resp.json().get('error', f'Upload failed ({resp.status_code})')
                        except:
                            msg = f'Upload failed ({resp.status_code})'
                        logger.error(f"[CHAT] Upload failed: {msg}")
                        self.system_message.emit(f"⚠️ {msg}")
                except Exception as e:
                    logger.error(f"[CHAT] Upload error: {e}")
                    self.system_message.emit(f"⚠️ Upload error: {str(e)[:50]}")
                finally:
                    # Clean up CurlMime to free memory
                    if mp:
                        mp.close()
            
            import threading
            threading.Thread(target=do_upload, daemon=True).start()


    # =========================================================================
    # REMOTE DEVICE CONTROL - Host/Professional System
    # =========================================================================
    # The Remote Play system has two roles:
    #   HOST         = User with a device that needs repair/modification
    #   PROFESSIONAL = Technician who connects and operates tools remotely
    #
    # The Host's installed plugins determine what the Professional can use.
    # Each plugin declares its capabilities via get_remote_operations() and
    # get_command_prefixes(). The Professional also has a Master Console
    # where they can type raw commands (adb, fastboot, mtk, etc.) that
    # auto-route to the correct plugin on the Host side.

    # Global blocked operations — NEVER allowed remotely regardless of plugin
    REMOTE_BLOCKED_OPS = {
        'write_flash', 'write_full_flash', 'erase_rpmb',
        'poke_memory', 'load_custom_payload',
    }

    class DeviceShareSession(QObject):
        """Host-side remote device sharing session (generalized for all plugins).
        
        Connects to the remote control relay server via Socket.IO through
        Cloudflare tunnel. Receives commands from Professionals, shows approval
        dialogs, dispatches to the correct plugin handler, and streams results back.
        
        Supports:
        - Plugin-specific operations (Professional clicks a button)
        - Master console raw commands (Professional types raw adb/fastboot/mtk commands)
        - Real-time log streaming during execution
        - Trust mode (auto-approve READ operations)
        
        Lifecycle:
            1. Host clicks "Share Device" → start_sharing()
            2. System scans installed plugins → builds capabilities list
            3. Server creates session, room members see device + capabilities
            4. Professional sends command → server routes to Host
            5. Host sees approval dialog (or auto-approves in trust mode)
            6. Command dispatched to correct plugin handler
            7. Log lines streamed back in real-time
            8. Final result sent back to Professional
            9. Host clicks "Stop Sharing" → stop_sharing()
        """

        # Signals for thread-safe UI updates
        connected_changed = pyqtSignal(bool, str)   # connected, status
        session_started = pyqtSignal(str)            # session_id
        session_stopped = pyqtSignal()
        command_received = pyqtSignal(dict)          # command data (for approval dialog)
        command_executing = pyqtSignal(str, str)     # command_id, operation
        command_completed = pyqtSignal(str, bool)    # command_id, success
        log_message = pyqtSignal(str)                # status/info log
        professional_joined_signal = pyqtSignal(str)  # professional_name
        trust_changed = pyqtSignal(bool)             # trust_mode state
        error_signal = pyqtSignal(str)               # error message
        capabilities_changed = pyqtSignal(list)      # updated capabilities list
        # Screen share signals
        screen_share_requested = pyqtSignal(dict)    # {screen_session_id, professional_name}
        screen_share_ended_signal = pyqtSignal(str)  # reason

        def __init__(self, parent=None):
            super().__init__(parent)
            self.sio = None
            self.connected = False
            self.session_id = None
            self.room_id = None
            self.trust_mode = False
            self._executing_command = None      # Currently executing command_id
            self._log_lines = []                # Captured log lines for current cmd
            
            # Plugin-agnostic: registered plugins and their handlers
            self._plugins = {}                  # plugin_id → plugin instance
            self._plugin_handlers = {}          # plugin_id → device handler (if applicable)
            self._capabilities = []             # [{id, name, icon, version, operations, prefixes}]
            self._prefix_map = {}               # command_prefix → plugin_id (for master console routing)
            
            # Screen share state (zero-persistence: all RAM-only)
            self._screen_capture = None          # ScreenCaptureService instance
            self._screen_session_id = None       # Active screen share session ID
            self._screen_permissions = {}        # {view, touch, keyboard}

        def register_plugin(self, plugin_id: str, plugin_instance, handler=None):
            """Register a plugin for remote access.
            
            Args:
                plugin_id:       Plugin identifier (e.g. 'adb_toolkit', 'mtk_toolkit')
                plugin_instance: The Plugin class instance (has get_remote_operations, etc.)
                handler:         Optional device handler (e.g. MtkDeviceHandler) for log capture
            """
            self._plugins[plugin_id] = plugin_instance
            if handler:
                self._plugin_handlers[plugin_id] = handler
            
            # Register command prefixes for master console routing
            prefixes = []
            if hasattr(plugin_instance, 'get_command_prefixes'):
                prefixes = plugin_instance.get_command_prefixes()
            for prefix in prefixes:
                self._prefix_map[prefix.lower()] = plugin_id
            
            self.log_message.emit(f"🔌 Registered plugin: {plugin_id} (prefixes: {prefixes})")

        def build_capabilities(self) -> list:
            """Build capabilities list from all registered plugins.
            
            Returns list of dicts describing each plugin and what it can do,
            sent to the relay server for the Professional to see.
            """
            self._capabilities = []
            for plugin_id, plugin in self._plugins.items():
                manifest = getattr(plugin, 'manifest', None)
                operations = []
                prefixes = []
                
                if hasattr(plugin, 'get_remote_operations'):
                    try:
                        operations = plugin.get_remote_operations()
                    except Exception:
                        operations = []
                
                if hasattr(plugin, 'get_command_prefixes'):
                    try:
                        prefixes = plugin.get_command_prefixes()
                    except Exception:
                        prefixes = []
                
                cap = {
                    'id': plugin_id,
                    'name': manifest.name if manifest else plugin_id,
                    'icon': manifest.icon if manifest else '🔌',
                    'version': manifest.version if manifest else '?',
                    'operations': operations,
                    'prefixes': prefixes,
                }
                self._capabilities.append(cap)
            
            self.capabilities_changed.emit(self._capabilities)
            return self._capabilities

        def start_sharing(self, room_id: str, device_info: dict):
            """Connect to remote control server and start sharing device."""
            if self.connected and self.session_id:
                self.log_message.emit("⚠️ Already sharing device")
                return

            self.room_id = room_id
            
            # Build capabilities from registered plugins
            capabilities = self.build_capabilities()

            try:
                import socketio
            except ImportError:
                self.error_signal.emit("python-socketio not installed")
                return

            # Build HTTP session with CF auth (curl_cffi for Cloudflare bypass)
            http_session = None
            try:
                from curl_cffi.requests import Session as CurlSession
                http_session = CurlSession()
                http_session.headers.update(get_rc_cf_headers())
            except ImportError:
                try:
                    import requests
                    http_session = requests.Session()
                    http_session.headers.update(get_rc_cf_headers())
                except ImportError:
                    self.error_signal.emit("No HTTP library (need curl_cffi or requests)")
                    return

            self.sio = socketio.Client(
                reconnection=True,
                reconnection_attempts=10,
                reconnection_delay=2,
                reconnection_delay_max=15,
                logger=False,
                engineio_logger=False,
                http_session=http_session,
            )

            session = self  # Reference for closures

            @self.sio.event
            def connect():
                session.connected = True
                session.connected_changed.emit(True, "Connected to relay")
                session.log_message.emit("🔗 Connected to remote control server")
                # Join room and start sharing with capabilities
                session.sio.emit('join_room', {'room_id': session.room_id})
                session.sio.emit('device_share_start', {
                    'room_id': session.room_id,
                    'device_info': device_info,
                    'capabilities': capabilities,
                })

            @self.sio.event
            def disconnect():
                session.connected = False
                session.session_id = None
                session.connected_changed.emit(False, "Disconnected")
                session.log_message.emit("🔌 Disconnected from relay")
                session.session_stopped.emit()

            @self.sio.event
            def connect_error(data):
                session.connected = False
                session.error_signal.emit(f"Connection error: {data}")

            @self.sio.on('device_share_started')
            def on_share_started(data):
                session.session_id = data.get('session_id')
                session.log_message.emit(f"📡 Device shared! Session: {session.session_id[:8]}...")
                session.session_started.emit(session.session_id)

            @self.sio.on('device_command_approval_request')
            def on_approval_request(data):
                """Professional wants to run a command - needs Host approval."""
                session.command_received.emit(data)

            @self.sio.on('device_execute_command')
            def on_execute_command(data):
                """Command approved (or auto-approved) - execute it now."""
                cmd_type = data.get('type', 'operation')
                if cmd_type == 'raw_command':
                    session._execute_raw_command(data)
                else:
                    session._execute_operation(data)

            @self.sio.on('device_trust_changed')
            def on_trust_changed(data):
                session.trust_mode = data.get('trust_mode', False)
                session.trust_changed.emit(session.trust_mode)

            @self.sio.on('professional_joined')
            def on_pro_joined(data):
                pro_name = data.get('professional_name', 'Unknown')
                session.log_message.emit(f"👤 Professional '{pro_name}' connected to your session")
                session.professional_joined_signal.emit(pro_name)

            # ── Screen Share handlers (Host receives from relay) ────────
            @self.sio.on('screen_share_request')
            def on_screen_share_request(data):
                """Professional wants to see our screen."""
                session.screen_share_requested.emit(data)

            @self.sio.on('screen_input')
            def on_screen_input(data):
                """Professional sent touch/key input — inject via ADB."""
                session._inject_screen_input(data)

            @self.sio.on('screen_share_ended')
            def on_screen_share_ended(data):
                """Relay says screen session ended."""
                reason = data.get('reason', 'Session ended')
                session._stop_screen_capture()
                session.screen_share_ended_signal.emit(reason)

            @self.sio.on('error')
            def on_error(data):
                session.error_signal.emit(data.get('message', 'Unknown error'))

            # Get JWT token from plugin store API (same auth system)
            token = getattr(plugin_store_api, 'token', None)
            if not token:
                self.error_signal.emit("Login required - sign in via Plugin Store first")
                return

            def do_connect():
                try:
                    session.sio.connect(
                        REMOTE_CTL_URL,
                        auth={'token': token},
                        headers=get_rc_cf_headers(),
                        transports=['polling'],
                    )
                except Exception as e:
                    session.error_signal.emit(f"Failed to connect: {str(e)[:100]}")

            import threading
            threading.Thread(target=do_connect, daemon=True).start()

        def stop_sharing(self):
            """Stop sharing and disconnect."""
            self._stop_screen_capture()  # Clean up screen share first
            if self.sio and self.connected:
                try:
                    if self.session_id:
                        self.sio.emit('device_share_stop', {'session_id': self.session_id})
                    self.sio.disconnect()
                except Exception:
                    pass
            self.session_id = None
            self.connected = False
            self.session_stopped.emit()
            self.log_message.emit("🛑 Device sharing stopped")

        def approve_command(self, command_id: str):
            """Approve a pending command from a Professional."""
            if self.sio and self.connected:
                self.sio.emit('device_command_respond', {
                    'command_id': command_id,
                    'approved': True,
                })
                self.log_message.emit(f"✅ Command {command_id[:8]}... approved")

        def reject_command(self, command_id: str):
            """Reject a pending command from a Professional."""
            if self.sio and self.connected:
                self.sio.emit('device_command_respond', {
                    'command_id': command_id,
                    'approved': False,
                })
                self.log_message.emit(f"❌ Command {command_id[:8]}... rejected")

        def toggle_trust(self, enabled: bool):
            """Toggle trust mode (auto-approve READ operations)."""
            self.trust_mode = enabled
            if self.sio and self.connected and self.session_id:
                self.sio.emit('device_trust_toggle', {
                    'session_id': self.session_id,
                    'trust_mode': enabled,
                })

        def update_device_status(self, device_info: dict):
            """Send updated device info to the relay."""
            if self.sio and self.connected and self.session_id:
                self.sio.emit('device_status_update', {
                    'session_id': self.session_id,
                    'device_info': device_info,
                })

        def refresh_capabilities(self):
            """Re-scan plugin operations and push updated capabilities to relay."""
            capabilities = self.build_capabilities()
            if self.sio and self.connected and self.session_id:
                self.sio.emit('device_capabilities_update', {
                    'session_id': self.session_id,
                    'capabilities': capabilities,
                })

        # ═══════════════════════════════════════════════════════════
        # SCREEN SHARE — Host-side methods (Zero-Persistence)
        # All data lives in RAM only. Nothing is written to disk.
        # https://github.com/vehoelite/image-anarchy
        # ═══════════════════════════════════════════════════════════

        def approve_screen_share(self, screen_session_id, permissions=None):
            """Approve a screen share request and start capture."""
            if not self.sio or not self.connected:
                return
            perms = permissions or {'view': True, 'touch': False, 'keyboard': False}
            self._screen_session_id = screen_session_id
            self._screen_permissions = perms
            self.sio.emit('screen_share_respond', {
                'screen_session_id': screen_session_id,
                'approved': True,
                'permissions': perms,
            })
            self.log_message.emit("📺 Screen share approved — starting capture...")
            self._start_screen_capture(screen_session_id)

        def deny_screen_share(self, screen_session_id):
            """Deny a screen share request."""
            if self.sio and self.connected:
                self.sio.emit('screen_share_respond', {
                    'screen_session_id': screen_session_id,
                    'approved': False,
                })
                self.log_message.emit("❌ Screen share request denied")

        def update_screen_permissions(self, permissions):
            """Update screen share permissions mid-session."""
            if not self._screen_session_id or not self.sio or not self.connected:
                return
            self._screen_permissions = permissions
            self.sio.emit('screen_permissions_update', {
                'screen_session_id': self._screen_session_id,
                'permissions': permissions,
            })

        def stop_screen_share(self):
            """Host: Stop screen sharing."""
            if self._screen_session_id and self.sio and self.connected:
                self.sio.emit('screen_share_stop', {
                    'screen_session_id': self._screen_session_id,
                })
            self._stop_screen_capture()

        def _start_screen_capture(self, screen_session_id):
            """Start the ScreenCaptureService thread."""
            self._stop_screen_capture()  # Stop any existing capture

            # Find ADB path
            adb_path = self._find_adb_path()
            if not adb_path:
                self.error_signal.emit("Cannot start screen share: ADB not found")
                logging.error("[SCREEN] ADB not found in any known location")
                return

            # Find device serial
            serial = self._find_device_serial(adb_path)
            if not serial:
                self.error_signal.emit("Cannot start screen share: No ADB device connected")
                logging.error(f"[SCREEN] No device found via {adb_path}")
                return

            logging.info(f"[SCREEN] Starting capture: adb={adb_path}, serial={serial}, session={screen_session_id[:8]}")

            self._screen_capture = ScreenCaptureService(
                adb_path=adb_path,
                device_serial=serial,
                screen_session_id=screen_session_id,
                target_fps=5,
                quality=55,
                max_size=720,
            )
            self._screen_capture.frame_ready.connect(self._on_screen_frame)
            self._screen_capture.status_changed.connect(
                lambda s: self.log_message.emit(f"[SCREEN] {s}"))
            self._screen_capture.error_occurred.connect(
                lambda e: self.error_signal.emit(f"Screen capture error: {e}"))
            self._screen_capture.stopped_signal.connect(self._on_screen_capture_stopped)
            self._screen_capture.start()

        def _stop_screen_capture(self):
            """Stop the screen capture service."""
            if self._screen_capture:
                self._screen_capture.stop()
                if not self._screen_capture.wait(3000):
                    self._screen_capture.terminate()
                self._screen_capture = None
            self._screen_session_id = None
            self._screen_permissions = {}

        def _on_screen_frame(self, frame_data):
            """Forward captured frame to relay as binary."""
            if self.sio and self.connected and self._screen_session_id:
                try:
                    self.sio.emit('screen_frame', frame_data)
                except Exception as e:
                    logging.warning(f"[SCREEN] Failed to emit frame ({len(frame_data)} bytes): {e}")

        def _on_screen_capture_stopped(self):
            """Capture service stopped unexpectedly."""
            self._screen_capture = None
            self.log_message.emit("⏹️ Screen capture stopped")

        def _inject_screen_input(self, data):
            """Inject touch/key/text input via ADB (background thread)."""
            if not self._screen_permissions:
                return
            input_type = data.get('type', '')
            if input_type == 'touch' and not self._screen_permissions.get('touch'):
                return
            if input_type in ('key', 'text') and not self._screen_permissions.get('keyboard'):
                return

            adb_path = self._find_adb_path()
            serial = self._find_device_serial(adb_path) if adb_path else None
            if not adb_path or not serial:
                return

            import threading
            def _do_input():
                try:
                    cmd = [adb_path, '-s', serial, 'shell', 'input']
                    if input_type == 'touch':
                        x, y = data.get('x', 0), data.get('y', 0)
                        action = data.get('action', 'tap')
                        if action == 'tap':
                            cmd.extend(['tap', str(int(x)), str(int(y))])
                        elif action == 'swipe':
                            x2, y2 = data.get('x2', x), data.get('y2', y)
                            dur = data.get('duration', 200)
                            cmd.extend(['swipe', str(int(x)), str(int(y)),
                                       str(int(x2)), str(int(y2)), str(int(dur))])
                        else:
                            return
                    elif input_type == 'key':
                        keycode = data.get('keycode', '')
                        if keycode:
                            cmd.extend(['keyevent', str(keycode)])
                        else:
                            return
                    elif input_type == 'text':
                        text = data.get('text', '')
                        if text:
                            cmd.extend(['text', text])
                        else:
                            return
                    else:
                        return
                    subprocess.run(
                        cmd, capture_output=True, timeout=5,
                        creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0,
                    )
                except Exception as e:
                    logging.warning(f"[SCREEN] Input injection failed: {e}")
            threading.Thread(target=_do_input, daemon=True).start()

        def _find_adb_path(self):
            """Find ADB executable from plugins or system."""
            import shutil
            base = Path(sys.executable).parent if getattr(sys, 'frozen', False) else Path(__file__).parent
            for p in [
                base / 'plugins' / 'scrcpy_toolkit' / 'adb.exe',
                base / 'plugins' / 'adb_toolkit' / 'platform-tools' / 'adb.exe',
                base / 'platform-tools' / 'adb.exe',
            ]:
                if p.exists():
                    return str(p)
            return shutil.which('adb')

        def _find_device_serial(self, adb_path):
            """Find the first connected ADB device serial."""
            if not adb_path:
                return None
            try:
                result = subprocess.run(
                    [adb_path, 'devices'], capture_output=True, text=True, timeout=5,
                    creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0,
                )
                for line in result.stdout.strip().split('\n')[1:]:
                    parts = line.strip().split()
                    if len(parts) >= 2 and parts[1] == 'device':
                        return parts[0]
            except Exception:
                pass
            return None

        def _execute_operation(self, data: dict):
            """Execute a plugin-specific operation on the Host's device.
            
            Dispatches to the correct plugin based on plugin_id in the command data.
            This is for structured operations (Professional clicked a button).
            """
            command_id = data.get('command_id')
            plugin_id = data.get('plugin_id')
            operation = data.get('operation')
            params = data.get('params', {})
            tech = data.get('technician', '?')

            if operation in REMOTE_BLOCKED_OPS:
                self._send_result(command_id, False, error=f"Operation '{operation}' is blocked remotely")
                return

            # Find the plugin
            plugin = self._plugins.get(plugin_id)
            if not plugin:
                self._send_result(command_id, False, error=f"Plugin '{plugin_id}' not available on this device")
                return

            self._executing_command = command_id
            self._log_lines = []
            self.command_executing.emit(command_id, f"{plugin_id}:{operation}")
            self.log_message.emit(f"⚙️ [{plugin_id}] Executing '{operation}' (requested by {tech})")

            # Setup log capture — try plugin handler first, then plugin itself
            handler = self._plugin_handlers.get(plugin_id)
            log_connected = False
            
            def capture_log(line):
                self._log_lines.append(str(line))
                if self.sio and self.connected and self.session_id:
                    self.sio.emit('device_log_stream', {
                        'session_id': self.session_id,
                        'command_id': command_id,
                        'log_line': str(line),
                    })

            if handler and hasattr(handler, 'log_signal'):
                handler.log_signal.connect(capture_log)
                log_connected = True

            def run_op():
                success = False
                result = None
                error = None
                try:
                    # Try the handler first (for MTK-style operations)
                    if handler:
                        op_method = getattr(handler, operation, None)
                        if op_method and callable(op_method):
                            ret = op_method(**params) if params else op_method()
                            if isinstance(ret, bool):
                                success = ret
                            elif isinstance(ret, (list, dict)):
                                success = True
                                result = ret
                            elif ret is not None:
                                success = True
                                result = str(ret)
                            else:
                                success = False
                                error = "Operation returned None"
                        else:
                            error = f"Unknown operation '{operation}' on plugin '{plugin_id}'"
                    else:
                        error = f"No handler for plugin '{plugin_id}' — use raw commands instead"
                except Exception as e:
                    error = str(e)

                # Cleanup log capture
                if log_connected:
                    try:
                        handler.log_signal.disconnect(capture_log)
                    except Exception:
                        pass

                self._send_result(command_id, success, result=result, error=error)
                self._executing_command = None
                self.command_completed.emit(command_id, success)

            import threading
            threading.Thread(target=run_op, daemon=True).start()

        def _execute_raw_command(self, data: dict):
            """Execute a raw command from the Professional's master console.
            
            Routes the command to the correct plugin based on the prefix.
            E.g. 'adb devices' → adb_toolkit, 'fastboot getvar all' → fastboot_toolkit
            """
            command_id = data.get('command_id')
            raw_command = data.get('raw_command', '').strip()
            tech = data.get('technician', '?')

            if not raw_command:
                self._send_result(command_id, False, error="Empty command")
                return

            # Parse prefix to find target plugin
            prefix = raw_command.split()[0].lower()
            plugin_id = self._prefix_map.get(prefix)

            if not plugin_id:
                available = ', '.join(sorted(self._prefix_map.keys()))
                self._send_result(command_id, False, 
                    error=f"Unknown command prefix '{prefix}'. Available: {available}")
                return

            plugin = self._plugins.get(plugin_id)
            if not plugin:
                self._send_result(command_id, False, error=f"Plugin '{plugin_id}' not loaded")
                return

            if not hasattr(plugin, 'execute_raw_command'):
                self._send_result(command_id, False, 
                    error=f"Plugin '{plugin_id}' doesn't support raw commands")
                return

            self._executing_command = command_id
            self._log_lines = []
            self.command_executing.emit(command_id, f"raw:{raw_command[:50]}")
            self.log_message.emit(f"🖥️ [{plugin_id}] Raw command from {tech}: {raw_command}")

            def capture_log(line):
                self._log_lines.append(str(line))
                if self.sio and self.connected and self.session_id:
                    self.sio.emit('device_log_stream', {
                        'session_id': self.session_id,
                        'command_id': command_id,
                        'log_line': str(line),
                    })

            def run_raw():
                try:
                    result = plugin.execute_raw_command(raw_command, log_callback=capture_log)
                    self._send_result(
                        command_id,
                        result.get('success', False),
                        result=result.get('output'),
                        error=result.get('error'),
                    )
                except Exception as e:
                    self._send_result(command_id, False, error=str(e))
                finally:
                    self._executing_command = None
                    self.command_completed.emit(command_id, True)

            import threading
            threading.Thread(target=run_raw, daemon=True).start()

        def _send_result(self, command_id: str, success: bool, result=None, error=None):
            """Send command result back to relay server."""
            if self.sio and self.connected:
                self.sio.emit('device_command_result', {
                    'command_id': command_id,
                    'success': success,
                    'result': result,
                    'error': error,
                    'logs': self._log_lines[-100:],  # Last 100 lines
                })


    # ═══════════════════════════════════════════════════════════════════════
    # SCREEN SHARE — ScreenCaptureService (Host-side capture thread)
    # Zero-Persistence: No frames cached. No files written. RAM → Socket.IO.
    # https://github.com/vehoelite/image-anarchy
    # ═══════════════════════════════════════════════════════════════════════

    class ScreenCaptureService(QThread):
        """Captures device screenshots via ADB for zero-persistence relay.

        Uses 'adb exec-out screencap -p' for maximum compatibility (Android 4.4+).
        Each frame: PNG capture → JPEG compress → prepend 16-byte session UUID → emit.
        The relay passes it through as opaque binary without inspection.

        Frame wire format:
            [16 bytes: screen_session_id as raw UUID] + [JPEG image data]

        Privacy: No frames stored. No files created. All RAM-only.
        Verify: https://github.com/vehoelite/image-anarchy
        """

        frame_ready = pyqtSignal(bytes)        # 16-byte UUID + JPEG data
        status_changed = pyqtSignal(str)       # status text
        error_occurred = pyqtSignal(str)       # error message
        stopped_signal = pyqtSignal()          # capture ended

        def __init__(self, adb_path, device_serial, screen_session_id,
                     target_fps=5, quality=55, max_size=720, parent=None):
            super().__init__(parent)
            self.adb_path = adb_path
            self.serial = device_serial
            self.session_id = screen_session_id
            # Convert UUID string → 16 raw bytes for frame prefix
            self.session_id_bytes = bytes.fromhex(screen_session_id.replace('-', ''))
            self.target_fps = max(1, min(target_fps, 15))   # Clamp 1-15fps
            self.quality = max(20, min(quality, 90))         # Clamp 20-90
            self.max_size = max(240, min(max_size, 1080))    # Clamp 240-1080
            self._running = False
            self._frame_count = 0

        def run(self):
            """Capture loop — runs in dedicated thread."""
            import time
            self._running = True
            self._frame_count = 0
            frame_interval = 1.0 / self.target_fps

            logging.info(f"[SCREEN] Capture thread started: {self.adb_path} -s {self.serial}")
            self.status_changed.emit("📸 Screen capture starting...")

            while self._running:
                t0 = time.monotonic()
                try:
                    # Capture PNG screenshot via ADB
                    result = subprocess.run(
                        [self.adb_path, '-s', self.serial, 'exec-out', 'screencap', '-p'],
                        capture_output=True, timeout=10,
                        creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0,
                    )
                    if result.returncode != 0 or not result.stdout:
                        if self._running:
                            stderr_msg = (result.stderr or b'').decode('utf-8', errors='replace')[:200]
                            logging.warning(f"[SCREEN] screencap failed: rc={result.returncode}, stderr={stderr_msg}")
                            self.status_changed.emit("⚠️ screencap failed, retrying...")
                            time.sleep(0.5)
                        continue

                    png_data = result.stdout
                    if self._frame_count < 3:
                        logging.info(f"[SCREEN] Frame {self._frame_count}: PNG={len(png_data)} bytes")

                    # Convert PNG → JPEG with resize using QImage (thread-safe)
                    img = QImage()
                    if not img.loadFromData(png_data):
                        logging.warning(f"[SCREEN] QImage.loadFromData failed for {len(png_data)} bytes")
                        continue

                    # Resize if either dimension exceeds max_size
                    if max(img.width(), img.height()) > self.max_size:
                        img = img.scaled(
                            self.max_size, self.max_size,
                            Qt.AspectRatioMode.KeepAspectRatio,
                            Qt.TransformationMode.SmoothTransformation,
                        )

                    # Convert to JPEG bytes
                    from PyQt6.QtCore import QBuffer, QIODevice
                    buf = QBuffer()
                    buf.open(QIODevice.OpenModeFlag.WriteOnly)
                    img.save(buf, 'JPEG', self.quality)
                    jpeg_data = bytes(buf.data())
                    buf.close()

                    if not jpeg_data or len(jpeg_data) < 100:
                        continue

                    # Emit frame: 16-byte session UUID prefix + JPEG data
                    frame = self.session_id_bytes + jpeg_data
                    self.frame_ready.emit(frame)

                    self._frame_count += 1
                    if self._frame_count == 1:
                        self.status_changed.emit(
                            f"📺 Streaming {img.width()}x{img.height()} @ ~{self.target_fps}fps"
                        )

                except subprocess.TimeoutExpired:
                    if self._running:
                        self.status_changed.emit("⚠️ ADB timeout, retrying...")
                except Exception as e:
                    if self._running:
                        self.error_occurred.emit(f"Capture error: {e}")
                        time.sleep(1)

                # Rate limit
                elapsed = time.monotonic() - t0
                sleep_time = frame_interval - elapsed
                if sleep_time > 0 and self._running:
                    time.sleep(sleep_time)

            self.status_changed.emit("⏹️ Screen capture stopped")
            self.stopped_signal.emit()

        def stop(self):
            """Stop the capture loop."""
            self._running = False

        @property
        def frame_count(self):
            return self._frame_count


    # ═══════════════════════════════════════════════════════════════════════
    # SCREEN SHARE — ScreenViewerWidget (Professional-side viewer)
    # Zero-Persistence: No frames saved. No screenshots. All RAM-only.
    # https://github.com/vehoelite/image-anarchy
    # ═══════════════════════════════════════════════════════════════════════

    class ScreenViewerWidget(QWidget):
        """Professional-side screen viewer for Remote Play.

        Receives JPEG frames from relay, renders in QWidget.
        Supports mouse → touch and keyboard → key injection.

        Zero-Persistence: No frames saved to disk. All RAM-only.
        """

        input_event = pyqtSignal(dict)    # Touch/key event to send to relay
        closed = pyqtSignal()             # Viewer closed by user

        def __init__(self, screen_session_id, host_name='', permissions=None, parent=None):
            super().__init__(parent)
            self.screen_session_id = screen_session_id
            self.host_name = host_name
            self.permissions = permissions or {'view': True, 'touch': False, 'keyboard': False}
            import time as _time
            self._current_frame = None       # QPixmap
            self._device_width = 0
            self._device_height = 0
            self._frame_count = 0
            self._last_fps_time = _time.monotonic()
            self._last_fps_count = 0
            self._current_fps = 0

            self.setWindowTitle(f"📺 Screen Share — {host_name}")
            self.setWindowFlags(Qt.WindowType.Window)
            self.setMinimumSize(360, 640)
            self.resize(400, 720)
            self.setStyleSheet("background: #000;")
            self.setMouseTracking(True)
            self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

            self._setup_ui()

        def _setup_ui(self):
            layout = QVBoxLayout(self)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setSpacing(0)

            # Status bar
            self._status_bar = QLabel("📺 Waiting for frames...")
            self._status_bar.setFixedHeight(24)
            self._status_bar.setStyleSheet(
                "background: #1a1a2e; color: #4fc3f7; font-size: 10px; padding: 2px 8px;"
            )
            layout.addWidget(self._status_bar)

            # Frame display
            self._frame_label = QLabel()
            self._frame_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self._frame_label.setStyleSheet("background: #000;")
            self._frame_label.setSizePolicy(
                QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding
            )
            layout.addWidget(self._frame_label, 1)

            # Bottom bar
            bottom = QHBoxLayout()
            bottom.setContentsMargins(8, 4, 8, 4)

            self._perm_label = QLabel()
            self._update_perm_label()
            self._perm_label.setStyleSheet("color: #888; font-size: 10px;")
            bottom.addWidget(self._perm_label)

            bottom.addStretch()

            self._fps_label = QLabel("0 fps")
            self._fps_label.setStyleSheet("color: #666; font-size: 10px;")
            bottom.addWidget(self._fps_label)

            disconnect_btn = QPushButton("🔴 Stop")
            disconnect_btn.setFixedWidth(80)
            disconnect_btn.setStyleSheet("""
                QPushButton {
                    background: #c62828; color: white; border: none;
                    border-radius: 3px; padding: 3px 8px; font-size: 10px;
                }
                QPushButton:hover { background: #d32f2f; }
            """)
            disconnect_btn.clicked.connect(self.close)
            bottom.addWidget(disconnect_btn)

            layout.addLayout(bottom)

        def update_frame(self, jpeg_data):
            """Update displayed frame from raw JPEG bytes."""
            import time
            pixmap = QPixmap()
            if not pixmap.loadFromData(jpeg_data):
                return

            self._current_frame = pixmap
            self._device_width = pixmap.width()
            self._device_height = pixmap.height()
            self._frame_count += 1

            # Calculate FPS every second
            now = time.monotonic()
            if now - self._last_fps_time >= 1.0:
                self._current_fps = self._frame_count - self._last_fps_count
                self._last_fps_count = self._frame_count
                self._last_fps_time = now
                self._fps_label.setText(f"{self._current_fps} fps")
                self._status_bar.setText(
                    f"📺 {self._device_width}x{self._device_height} | "
                    f"{self._current_fps}fps | Frame #{self._frame_count}"
                )

            # Scale pixmap to fit label while keeping aspect ratio
            label_size = self._frame_label.size()
            scaled = pixmap.scaled(
                label_size,
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation,
            )
            self._frame_label.setPixmap(scaled)

        def update_permissions(self, perms):
            """Update permissions mid-session."""
            self.permissions = perms
            self._update_perm_label()

        def _update_perm_label(self):
            parts = []
            if self.permissions.get('view'):
                parts.append("👁️ View")
            if self.permissions.get('touch'):
                parts.append("👆 Touch")
            if self.permissions.get('keyboard'):
                parts.append("⌨️ Keyboard")
            self._perm_label.setText(" | ".join(parts) or "No permissions")

        def mousePressEvent(self, event):
            """Convert mouse click to touch tap on device."""
            if not self.permissions.get('touch') or not self._current_frame:
                return super().mousePressEvent(event)

            coords = self._map_to_device(event.pos())
            if coords:
                x, y = coords
                self.input_event.emit({
                    'screen_session_id': self.screen_session_id,
                    'type': 'touch',
                    'x': x, 'y': y,
                    'action': 'tap',
                })

        def keyPressEvent(self, event):
            """Convert key press to device key event."""
            if not self.permissions.get('keyboard'):
                return super().keyPressEvent(event)

            # Map Qt key → Android keycode
            key_map = {
                Qt.Key.Key_Return: 66,     # KEYCODE_ENTER
                Qt.Key.Key_Backspace: 67,  # KEYCODE_DEL
                Qt.Key.Key_Escape: 4,      # KEYCODE_BACK
                Qt.Key.Key_Home: 3,        # KEYCODE_HOME
                Qt.Key.Key_Tab: 61,        # KEYCODE_TAB
                Qt.Key.Key_Up: 19,         # KEYCODE_DPAD_UP
                Qt.Key.Key_Down: 20,       # KEYCODE_DPAD_DOWN
                Qt.Key.Key_Left: 21,       # KEYCODE_DPAD_LEFT
                Qt.Key.Key_Right: 22,      # KEYCODE_DPAD_RIGHT
                Qt.Key.Key_VolumeUp: 24,   # KEYCODE_VOLUME_UP
                Qt.Key.Key_VolumeDown: 25, # KEYCODE_VOLUME_DOWN
            }

            keycode = key_map.get(event.key())
            if keycode:
                self.input_event.emit({
                    'screen_session_id': self.screen_session_id,
                    'type': 'key',
                    'keycode': keycode,
                })
            elif event.text():
                self.input_event.emit({
                    'screen_session_id': self.screen_session_id,
                    'type': 'text',
                    'text': event.text(),
                })

        def _map_to_device(self, pos):
            """Map widget position to device screen coordinates."""
            if not self._current_frame or not self._frame_label.pixmap():
                return None

            label_size = self._frame_label.size()
            pixmap = self._frame_label.pixmap()

            # Offset of the displayed image within the label
            x_offset = (label_size.width() - pixmap.width()) / 2
            y_offset = (label_size.height() - pixmap.height()) / 2

            # Position relative to the frame label
            frame_label_pos = self._frame_label.mapFrom(self, pos)

            # Position within the displayed pixmap
            px = frame_label_pos.x() - x_offset
            py = frame_label_pos.y() - y_offset

            if px < 0 or py < 0 or px >= pixmap.width() or py >= pixmap.height():
                return None

            # Scale to device resolution
            scale_x = self._device_width / pixmap.width()
            scale_y = self._device_height / pixmap.height()

            return (px * scale_x, py * scale_y)

        def closeEvent(self, event):
            """Emit closed signal when viewer is closed."""
            self.closed.emit()
            super().closeEvent(event)


    class PluginPlayground(QWidget):
        """Plugin testing and validation environment."""

        def __init__(self, parent=None):
            super().__init__(parent)

            self.loaded_plugin_path: Optional[str] = None
            self.loaded_plugin_widget: Optional[QWidget] = None
            self.file_watcher_timer: Optional[QTimer] = None
            self.last_manifest_mtime: float = 0
            self._setup_ui()

        def _setup_ui(self):
            main_layout = QVBoxLayout(self)
            main_layout.setContentsMargins(0, 0, 0, 0)
            main_layout.setSpacing(0)

            # Header - fixed height, no stretch
            header = QFrame()
            header.setStyleSheet("background: #1e1e1e; border-bottom: 1px solid #444;")
            header.setFixedHeight(45)  # Fixed height for header
            header_layout = QHBoxLayout(header)
            header_layout.setContentsMargins(16, 10, 16, 10)

            title = QLabel("🧪 Plugin Playground")
            title.setStyleSheet("font-size: 16px; font-weight: bold; color: #4fc3f7;")
            header_layout.addWidget(title)

            header_layout.addStretch()

            # Hot reload toggle
            self.hot_reload_check = QCheckBox("🔄 Hot Reload")
            self.hot_reload_check.setStyleSheet("color: #aaa;")
            self.hot_reload_check.setToolTip("Automatically reload when files change")
            self.hot_reload_check.stateChanged.connect(self._toggle_hot_reload)
            header_layout.addWidget(self.hot_reload_check)

            main_layout.addWidget(header)

            # Main content splitter
            splitter = QSplitter(Qt.Orientation.Horizontal)
            splitter.setStyleSheet("QSplitter::handle { background: #444; }")

            # Left panel: Plugin loader and validation (wrapped in scroll area for 1080p)
            left_scroll = QScrollArea()
            left_scroll.setWidgetResizable(True)
            left_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            left_scroll.setStyleSheet("QScrollArea { background: #252525; border: none; border-right: 1px solid #444; }")
            left_scroll.setMinimumWidth(300)
            left_scroll.setMaximumWidth(400)
            
            left_panel = QFrame()
            left_panel.setStyleSheet("background: #252525;")
            left_layout = QVBoxLayout(left_panel)
            left_layout.setContentsMargins(12, 12, 12, 12)
            left_layout.setSpacing(10)

            # Load plugin section
            load_frame = QFrame()
            load_frame.setStyleSheet("background: #1a1a1a; border: 1px solid #444; border-radius: 8px;")
            load_layout = QVBoxLayout(load_frame)
            load_layout.setContentsMargins(12, 12, 12, 12)
            load_layout.setSpacing(8)

            load_title = QLabel("📂 Load Plugin")
            load_title.setStyleSheet("font-weight: bold; color: #4fc3f7;")
            load_layout.addWidget(load_title)

            # Path input row
            path_row = QHBoxLayout()
            self.plugin_path_input = QLineEdit()
            self.plugin_path_input.setPlaceholderText("Select a plugin folder...")
            self.plugin_path_input.setStyleSheet("""
                QLineEdit { background: #2a2a2a; border: 1px solid #555; border-radius: 4px; padding: 6px; color: white; }
                QLineEdit:focus { border-color: #4fc3f7; }
            """)
            path_row.addWidget(self.plugin_path_input)

            browse_btn = QPushButton("📁")
            browse_btn.setFixedWidth(36)
            browse_btn.setStyleSheet("QPushButton { background: #333; border: 1px solid #555; border-radius: 4px; padding: 6px; }")
            browse_btn.clicked.connect(self._browse_plugin)
            path_row.addWidget(browse_btn)
            load_layout.addLayout(path_row)

            # Load buttons
            btn_row = QHBoxLayout()
            load_btn = QPushButton("🚀 Load Plugin")
            load_btn.setStyleSheet("""
                QPushButton { background: #4fc3f7; color: black; border: none; border-radius: 4px; padding: 8px 16px; font-weight: bold; }
                QPushButton:hover { background: #81d4fa; }
            """)
            load_btn.clicked.connect(self._load_plugin)
            btn_row.addWidget(load_btn)

            reload_btn = QPushButton("🔄 Reload")
            reload_btn.setStyleSheet("""
                QPushButton { background: #333; border: 1px solid #555; border-radius: 4px; padding: 8px 16px; color: #aaa; }
                QPushButton:hover { background: #444; color: white; }
            """)
            reload_btn.clicked.connect(self._reload_plugin)
            btn_row.addWidget(reload_btn)

            unload_btn = QPushButton("✖ Unload")
            unload_btn.setStyleSheet("""
                QPushButton { background: #333; border: 1px solid #555; border-radius: 4px; padding: 8px 16px; color: #aaa; }
                QPushButton:hover { background: #f44336; color: white; }
            """)
            unload_btn.clicked.connect(self._unload_plugin)
            btn_row.addWidget(unload_btn)
            load_layout.addLayout(btn_row)

            left_layout.addWidget(load_frame)

            # Validation checklist (compact for 1080p)
            validation_frame = QFrame()
            validation_frame.setStyleSheet("background: #1a1a1a; border: 1px solid #444; border-radius: 8px;")
            validation_layout = QVBoxLayout(validation_frame)
            validation_layout.setContentsMargins(10, 10, 10, 10)
            validation_layout.setSpacing(3)

            validation_title = QLabel("✅ Validation Checklist")
            validation_title.setStyleSheet("font-weight: bold; color: #4caf50; font-size: 12px;")
            validation_layout.addWidget(validation_title)

            # Checklist items - ALL 15 REQUIRED MANIFEST FIELDS (compact)
            self.check_items = {}
            checks = [
                ('manifest_exists', '📄 manifest.json exists'),
                ('manifest_valid', '✓ manifest.json valid'),
                # All 15 required fields
                ('has_id', '🔖 id'),
                ('has_name', '📛 name'),
                ('has_version', '🏷️ version'),
                ('has_description', '📝 description'),
                ('has_author', '👤 author'),
                ('has_icon', '🎨 icon'),
                ('has_license_type', '📜 license_type'),
                ('has_website', '🌐 website'),
                ('has_support_url', '🆘 support_url'),
                ('has_min_version', '⚙️ min_version'),
                ('has_git_clone', '📥 git_clone'),
                ('has_requirements', '📦 requirements'),
                ('has_bundled_binaries', '💾 bundled_binaries'),
                ('has_setup_commands', '🔧 setup_commands'),
                ('has_enabled', '✅ enabled'),
                # Plugin file checks
                ('plugin_py_exists', '🐍 plugin.py exists'),
                ('plugin_loads', '⚡ Plugin loads'),
                ('widget_creates', '🖼️ Widget creates'),
                ('deps_available', '📦 Deps available'),
            ]

            for check_id, check_label in checks:
                check_row = QHBoxLayout()
                check_row.setSpacing(4)

                status_label = QLabel("⬜")
                status_label.setFixedWidth(16)
                check_row.addWidget(status_label)

                text_label = QLabel(check_label)
                text_label.setStyleSheet("color: #888; font-size: 10px;")
                check_row.addWidget(text_label)
                check_row.addStretch()

                self.check_items[check_id] = (status_label, text_label)
                validation_layout.addLayout(check_row)

            # Ready to submit indicator
            self.submit_ready_label = QLabel("❓ Load a plugin to validate")
            self.submit_ready_label.setStyleSheet("""
                QLabel {
                    background: rgba(255, 255, 255, 0.1);
                    color: #888;
                    padding: 8px;
                    border-radius: 4px;
                    font-weight: bold;
                    margin-top: 8px;
                }
            """)
            self.submit_ready_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            validation_layout.addWidget(self.submit_ready_label)

            left_layout.addWidget(validation_frame)

            # Dependency checker
            deps_frame = QFrame()
            deps_frame.setStyleSheet("background: #1a1a1a; border: 1px solid #444; border-radius: 8px;")
            deps_layout = QVBoxLayout(deps_frame)
            deps_layout.setContentsMargins(12, 12, 12, 12)
            deps_layout.setSpacing(6)

            deps_title = QLabel("📦 Dependencies")
            deps_title.setStyleSheet("font-weight: bold; color: #ff9800;")
            deps_layout.addWidget(deps_title)

            self.deps_list = QTextEdit()
            self.deps_list.setReadOnly(True)
            self.deps_list.setMaximumHeight(100)
            self.deps_list.setStyleSheet("""
                QTextEdit {
                    background: #0a0a0a;
                    border: 1px solid #333;
                    border-radius: 4px;
                    color: #aaa;
                    font-family: monospace;
                    font-size: 10px;
                }
            """)
            self.deps_list.setPlaceholderText("No dependencies")
            deps_layout.addWidget(self.deps_list)

            left_layout.addWidget(deps_frame)
            left_layout.addStretch()

            left_scroll.setWidget(left_panel)
            splitter.addWidget(left_scroll)

            # Right panel: Plugin preview and console
            right_panel = QWidget()
            right_layout = QVBoxLayout(right_panel)
            right_layout.setContentsMargins(0, 0, 0, 0)
            right_layout.setSpacing(0)

            # Preview area
            preview_frame = QFrame()
            preview_frame.setStyleSheet("background: #1a1a1a;")
            preview_layout = QVBoxLayout(preview_frame)
            preview_layout.setContentsMargins(12, 12, 12, 12)

            preview_header = QHBoxLayout()
            preview_title = QLabel("🖼️ Plugin Preview")
            preview_title.setStyleSheet("font-weight: bold; color: #e91e63;")
            preview_header.addWidget(preview_title)
            preview_header.addStretch()

            self.plugin_status = QLabel("No plugin loaded")
            self.plugin_status.setStyleSheet("color: #666; font-size: 11px;")
            preview_header.addWidget(self.plugin_status)
            preview_layout.addLayout(preview_header)

            # Plugin container with scroll
            self.preview_scroll = QScrollArea()
            self.preview_scroll.setWidgetResizable(True)
            self.preview_scroll.setStyleSheet("""
                QScrollArea { border: 1px solid #444; border-radius: 4px; background: #252525; }
            """)

            self.preview_container = QWidget()
            self.preview_container_layout = QVBoxLayout(self.preview_container)
            self.preview_container_layout.setContentsMargins(8, 8, 8, 8)

            # Placeholder
            self.preview_placeholder = QLabel("🧪 Load a plugin to preview it here\n\nUse the panel on the left to select a plugin folder")
            self.preview_placeholder.setStyleSheet("color: #555; font-size: 13px;")
            self.preview_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.preview_container_layout.addWidget(self.preview_placeholder)

            self.preview_scroll.setWidget(self.preview_container)
            preview_layout.addWidget(self.preview_scroll, 1)

            right_layout.addWidget(preview_frame, 2)

            # Console area
            console_frame = QFrame()
            console_frame.setStyleSheet("background: #0d0d0d; border-top: 1px solid #444;")
            console_layout = QVBoxLayout(console_frame)
            console_layout.setContentsMargins(12, 8, 12, 8)
            console_layout.setSpacing(4)

            console_header = QHBoxLayout()
            console_title = QLabel("🐛 Console Output")
            console_title.setStyleSheet("font-weight: bold; color: #f44336;")
            console_header.addWidget(console_title)
            console_header.addStretch()

            clear_console_btn = QPushButton("Clear")
            clear_console_btn.setStyleSheet("""
                QPushButton { background: #333; border: 1px solid #555; border-radius: 3px; padding: 3px 10px; color: #aaa; font-size: 10px; }
                QPushButton:hover { background: #444; }
            """)
            clear_console_btn.clicked.connect(self._clear_console)
            console_header.addWidget(clear_console_btn)
            console_layout.addLayout(console_header)

            self.console_output = QTextEdit()
            self.console_output.setReadOnly(True)
            self.console_output.setMaximumHeight(150)
            self.console_output.setStyleSheet("""
                QTextEdit {
                    background: #0a0a0a;
                    border: 1px solid #333;
                    border-radius: 4px;
                    color: #4caf50;
                    font-family: 'Consolas', 'Monaco', monospace;
                    font-size: 11px;
                }
            """)
            self.console_output.setPlaceholderText("Console output will appear here...")
            console_layout.addWidget(self.console_output)

            right_layout.addWidget(console_frame)

            splitter.addWidget(right_panel)
            splitter.setSizes([350, 650])

            main_layout.addWidget(splitter)

        def _browse_plugin(self):
            """Open folder browser to select plugin directory."""
            folder = QFileDialog.getExistingDirectory(
                self, "Select Plugin Folder",
                os.path.join(get_app_dir(), 'plugins')
            )
            if folder:
                self.plugin_path_input.setText(folder)

        def _log(self, message: str, level: str = 'info'):
            """Add message to console with timestamp."""
            import datetime
            timestamp = datetime.datetime.now().strftime("%H:%M:%S")
            colors = {
                'info': '#4caf50',
                'warning': '#ff9800',
                'error': '#f44336',
                'success': '#4fc3f7'
            }
            color = colors.get(level, '#888')
            self.console_output.append(f'<span style="color: #666;">[{timestamp}]</span> <span style="color: {color};">{message}</span>')

        def _clear_console(self):
            """Clear console output."""
            self.console_output.clear()

        def _update_check(self, check_id: str, passed: bool, message: str = ""):
            """Update a validation check item."""
            if check_id not in self.check_items:
                return
            status_label, text_label = self.check_items[check_id]
            if passed:
                status_label.setText("✅")
                text_label.setStyleSheet("color: #4caf50; font-size: 11px;")
            else:
                status_label.setText("❌")
                text_label.setStyleSheet("color: #f44336; font-size: 11px;")
            if message:
                text_label.setToolTip(message)

        def _reset_checks(self):
            """Reset all validation checks."""
            for check_id, (status_label, text_label) in self.check_items.items():
                status_label.setText("⬜")
                text_label.setStyleSheet("color: #888; font-size: 11px;")
                text_label.setToolTip("")

        def _load_plugin(self):
            """Load and validate a plugin from the specified path."""
            plugin_path = self.plugin_path_input.text().strip()
            if not plugin_path:
                QMessageBox.warning(self, "No Path", "Please select a plugin folder first.")
                return

            if not os.path.isdir(plugin_path):
                QMessageBox.warning(self, "Invalid Path", "The specified path is not a directory.")
                return

            self._unload_plugin()
            self._reset_checks()
            self._log(f"Loading plugin from: {plugin_path}")

            self.loaded_plugin_path = plugin_path
            manifest_path = os.path.join(plugin_path, 'manifest.json')
            plugin_py_path = os.path.join(plugin_path, 'plugin.py')

            all_passed = True

            # Check 1: manifest.json exists
            manifest_exists = os.path.exists(manifest_path)
            self._update_check('manifest_exists', manifest_exists)
            if not manifest_exists:
                self._log("manifest.json not found!", 'error')
                all_passed = False

            # Check 2: manifest.json is valid JSON
            manifest_data = None
            if manifest_exists:
                try:
                    with open(manifest_path, 'r', encoding='utf-8') as f:
                        manifest_data = json.load(f)
                    self._update_check('manifest_valid', True)
                    self._log("manifest.json parsed successfully", 'success')
                except json.JSONDecodeError as e:
                    self._update_check('manifest_valid', False, str(e))
                    self._log(f"JSON parse error: {e}", 'error')
                    all_passed = False
                except Exception as e:
                    self._update_check('manifest_valid', False, str(e))
                    self._log(f"Error reading manifest: {e}", 'error')
                    all_passed = False

            # Check ALL 15 required manifest fields (strict validation)
            if manifest_data:
                # Field presence checks - ALL 15 REQUIRED
                field_checks = [
                    ('has_id', 'id', manifest_data.get('id')),
                    ('has_name', 'name', manifest_data.get('name')),
                    ('has_version', 'version', manifest_data.get('version')),
                    ('has_description', 'description', manifest_data.get('description')),
                    ('has_author', 'author', manifest_data.get('author')),
                    ('has_icon', 'icon', manifest_data.get('icon')),
                    ('has_license_type', 'license_type', manifest_data.get('license_type')),
                    ('has_website', 'website', manifest_data.get('website')),
                    ('has_support_url', 'support_url', manifest_data.get('support_url')),
                    ('has_min_version', 'min_version', manifest_data.get('min_version')),
                    ('has_git_clone', 'git_clone', 'git_clone' in manifest_data),  # Can be null
                    ('has_requirements', 'requirements', 'requirements' in manifest_data),  # Can be empty list
                    ('has_bundled_binaries', 'bundled_binaries', 'bundled_binaries' in manifest_data),  # Can be empty list
                    ('has_setup_commands', 'setup_commands', 'setup_commands' in manifest_data),  # Can be empty list
                    ('has_enabled', 'enabled', 'enabled' in manifest_data),  # Must be present
                ]
                
                missing_fields = []
                for check_id, field_name, field_present in field_checks:
                    passed = bool(field_present)
                    self._update_check(check_id, passed)
                    if not passed:
                        missing_fields.append(field_name)
                        all_passed = False
                
                if missing_fields:
                    self._log(f"⚠️ Missing required fields: {', '.join(missing_fields)}", 'warning')
                else:
                    self._log("✅ All 15 required manifest fields present", 'success')
                
                # Show dependencies
                deps_info = []
                if manifest_data.get('requirements'):
                    deps_info.append(f"📦 Pip: {', '.join(manifest_data['requirements'])}")
                if manifest_data.get('git_clone'):
                    deps_info.append(f"📥 Git: {manifest_data['git_clone'].get('repo', 'N/A')}")
                if manifest_data.get('bundled_binaries'):
                    deps_info.append(f"⬇️ Binaries: {len(manifest_data['bundled_binaries'])} files")
                if manifest_data.get('setup_commands'):
                    deps_info.append(f"⚙️ Commands: {len(manifest_data['setup_commands'])} commands")

                self.deps_list.setPlainText('\n'.join(deps_info) if deps_info else "No dependencies")

                # Check dependencies availability
                deps_ok = True
                for req in manifest_data.get('requirements', []):
                    pkg_name = req.split('>=')[0].split('==')[0].split('<')[0].strip()
                    try:
                        __import__(pkg_name.replace('-', '_'))
                    except ImportError:
                        deps_ok = False
                        self._log(f"Missing dependency: {pkg_name}", 'warning')
                self._update_check('deps_available', deps_ok)
                if not deps_ok:
                    all_passed = False

            # Check 8: plugin.py exists
            plugin_py_exists = os.path.exists(plugin_py_path)
            self._update_check('plugin_py_exists', plugin_py_exists)
            if not plugin_py_exists:
                self._log("plugin.py not found!", 'error')
                all_passed = False

            # Check 9: Plugin loads without errors
            plugin_class = None
            if plugin_py_exists:
                try:
                    import importlib.util
                    spec = importlib.util.spec_from_file_location("test_plugin", plugin_py_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)

                    # Find plugin class
                    if hasattr(module, 'Plugin'):
                        plugin_class = module.Plugin
                    else:
                        for name, obj in vars(module).items():
                            if isinstance(obj, type) and name.endswith('Plugin'):
                                plugin_class = obj
                                break

                    self._update_check('plugin_loads', True)
                    self._log("Plugin module loaded successfully", 'success')
                except Exception as e:
                    self._update_check('plugin_loads', False, str(e))
                    self._log(f"Plugin load error: {e}", 'error')
                    import traceback
                    self._log(traceback.format_exc(), 'error')
                    all_passed = False

            # Check 10: Widget creates successfully
            if plugin_class:
                try:
                    plugin_instance = plugin_class()
                    if manifest_data:
                        plugin_instance.manifest = PluginManifest.from_dict(manifest_data, manifest_data.get('id', 'test'))

                    widget = plugin_instance.create_widget(self)
                    if widget:
                        self._update_check('widget_creates', True)
                        self._log("Widget created successfully", 'success')

                        # Show widget in preview
                        self.preview_placeholder.hide()

                        # Clear old widget
                        for i in reversed(range(self.preview_container_layout.count())):
                            item = self.preview_container_layout.itemAt(i)
                            if item.widget() and item.widget() != self.preview_placeholder:
                                item.widget().deleteLater()

                        self.preview_container_layout.addWidget(widget)
                        self.loaded_plugin_widget = widget
                        self.plugin_status.setText(f"✓ {manifest_data.get('name', 'Plugin')} v{manifest_data.get('version', '?')}")
                        self.plugin_status.setStyleSheet("color: #4caf50; font-size: 11px;")
                    else:
                        self._update_check('widget_creates', False, "create_widget returned None")
                        self._log("create_widget() returned None", 'error')
                        all_passed = False
                except Exception as e:
                    self._update_check('widget_creates', False, str(e))
                    self._log(f"Widget creation error: {e}", 'error')
                    import traceback
                    self._log(traceback.format_exc(), 'error')
                    all_passed = False

            # Update ready to submit indicator
            if all_passed:
                self.submit_ready_label.setText("🎉 Ready to Submit!")
                self.submit_ready_label.setStyleSheet("""
                    QLabel {
                        background: rgba(76, 175, 80, 0.2);
                        color: #4caf50;
                        padding: 8px;
                        border-radius: 4px;
                        font-weight: bold;
                        margin-top: 8px;
                    }
                """)
                self._log("✅ All validation checks passed! Plugin is ready for submission.", 'success')
            else:
                self.submit_ready_label.setText("⚠️ Issues Found - Fix before submitting")
                self.submit_ready_label.setStyleSheet("""
                    QLabel {
                        background: rgba(244, 67, 54, 0.2);
                        color: #f44336;
                        padding: 8px;
                        border-radius: 4px;
                        font-weight: bold;
                        margin-top: 8px;
                    }
                """)

            # Store manifest mtime for hot reload
            if manifest_exists:
                self.last_manifest_mtime = os.path.getmtime(manifest_path)

        def _reload_plugin(self):
            """Reload the currently loaded plugin."""
            if self.loaded_plugin_path:
                self._log("Reloading plugin...", 'info')
                self._load_plugin()
            else:
                QMessageBox.information(self, "No Plugin", "No plugin is currently loaded.")

        def _unload_plugin(self):
            """Unload the currently loaded plugin."""
            if self.loaded_plugin_widget:
                self.preview_container_layout.removeWidget(self.loaded_plugin_widget)
                self.loaded_plugin_widget.deleteLater()
                self.loaded_plugin_widget = None

            self.preview_placeholder.show()
            self.plugin_status.setText("No plugin loaded")
            self.plugin_status.setStyleSheet("color: #666; font-size: 11px;")
            self.deps_list.clear()
            self._reset_checks()
            self.submit_ready_label.setText("❓ Load a plugin to validate")
            self.submit_ready_label.setStyleSheet("""
                QLabel {
                    background: rgba(255, 255, 255, 0.1);
                    color: #888;
                    padding: 8px;
                    border-radius: 4px;
                    font-weight: bold;
                    margin-top: 8px;
                }
            """)

            if self.loaded_plugin_path:
                self._log(f"Unloaded plugin from: {self.loaded_plugin_path}", 'info')
            self.loaded_plugin_path = None

        def _toggle_hot_reload(self, state):
            """Toggle hot reload file watching."""
            if state == Qt.CheckState.Checked.value:
                if self.file_watcher_timer is None:
                    self.file_watcher_timer = QTimer(self)
                    self.file_watcher_timer.timeout.connect(self._check_for_changes)
                self.file_watcher_timer.start(1000)  # Check every second
                self._log("Hot reload enabled - watching for file changes", 'info')
            else:
                if self.file_watcher_timer:
                    self.file_watcher_timer.stop()
                self._log("Hot reload disabled", 'info')

        def _check_for_changes(self):
            """Check if plugin files have changed and reload if needed."""
            if not self.loaded_plugin_path:
                return

            manifest_path = os.path.join(self.loaded_plugin_path, 'manifest.json')
            plugin_py_path = os.path.join(self.loaded_plugin_path, 'plugin.py')

            try:
                current_mtime = 0
                if os.path.exists(manifest_path):
                    current_mtime = max(current_mtime, os.path.getmtime(manifest_path))
                if os.path.exists(plugin_py_path):
                    current_mtime = max(current_mtime, os.path.getmtime(plugin_py_path))

                if current_mtime > self.last_manifest_mtime:
                    self._log("🔄 File change detected, reloading...", 'warning')
                    self.last_manifest_mtime = current_mtime
                    self._load_plugin()
            except Exception as e:
                self._log(f"Hot reload error: {e}", 'error')


    class VisualPluginMaker(QWidget):
        """Visual Plugin Maker - Wrapper for AST-based V2 editor.

        This is a wrapper class that loads the new VisualPluginMakerV2 from
        the visual_plugin_maker_v2 module. The V2 editor uses Python's AST
        module to parse plugins properly, preserving all code during edits.

        Features:
        - Parse any plugin.py into editable blocks (imports, functions, classes)
        - Edit manifest.json fields with proper form widgets
        - Edit code directly with syntax highlighting
        - Add new blocks (imports, functions, classes, variables)
        - Export without losing ANY code - AST-based reconstruction
        """

        def __init__(self, parent=None):
            super().__init__(parent)
            self._setup_ui()

        def _setup_ui(self):
            """Setup UI - loads the V2 editor or shows fallback."""
            main_layout = QVBoxLayout(self)
            main_layout.setContentsMargins(0, 0, 0, 0)
            main_layout.setSpacing(0)

            # Try to load VisualPluginMakerV2
            V2Class = _get_visual_plugin_maker_v2()

            if V2Class:
                # Use the new AST-based V2 editor
                self.v2_editor = V2Class(self)
                main_layout.addWidget(self.v2_editor)
            else:
                # Fallback: Show message if module not found
                self._show_fallback(main_layout)

        def _show_fallback(self, layout):
            """Show fallback message when V2 module isn't available."""
            fallback = QFrame()
            fallback.setStyleSheet("background: #1e1e1e;")
            fallback_layout = QVBoxLayout(fallback)
            fallback_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

            icon = QLabel("⚠️")
            icon.setStyleSheet("font-size: 48px;")
            icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
            fallback_layout.addWidget(icon)

            title = QLabel("Visual Plugin Maker V2 Not Available")
            title.setStyleSheet("font-size: 18px; font-weight: bold; color: #e91e63;")
            title.setAlignment(Qt.AlignmentFlag.AlignCenter)
            fallback_layout.addWidget(title)

            msg = QLabel(
                "The visual_plugin_maker_v2.py module could not be loaded.\n\n"
                "Make sure this file exists in the same directory as image_anarchy.py"
            )
            msg.setStyleSheet("color: #888; font-size: 12px;")
            msg.setAlignment(Qt.AlignmentFlag.AlignCenter)
            msg.setWordWrap(True)
            fallback_layout.addWidget(msg)

            layout.addWidget(fallback)

    # =========================================================================
    # PLUGINS MANAGEMENT TAB
    # =========================================================================

    class PluginsTab(QWidget):
        """Tab for managing plugins - browse, enable/disable, view info, open."""
        
        def __init__(self, parent_window):
            super().__init__()
            self.parent_window = parent_window
            self.loaded_widgets: Dict[str, QWidget] = {}
            self.loaded_plugins: Dict[str, Any] = {}  # Track plugin instances for cleanup
            self.active_plugin_id: Optional[str] = None  # Currently open plugin
            self.builtin_plugins = {}
            
            self._setup_ui()
            self._load_plugins()
        
        def _log(self, message: str):
            """Log a plugin message."""
            logger.debug(f"[Plugins] {message}")
        
        def _setup_ui(self):
            layout = QVBoxLayout(self)
            layout.setSpacing(8)
            layout.setContentsMargins(8, 8, 8, 8)
            
            # Main tab widget for Installed / Store views
            self.view_tabs = QTabWidget()
            self.view_tabs.setStyleSheet("""
                QTabWidget::pane { border: 1px solid #444; border-radius: 4px; }
                QTabBar::tab { padding: 8px 20px; }
                QTabBar::tab:selected { background: #3a3a3a; }
            """)
            
            # Auto-refresh store when switching to Store tab
            self._store_loaded = False
            def on_tab_changed(index):
                tab_text = self.view_tabs.tabText(index)
                if "Store" in tab_text and not self._store_loaded:
                    self._refresh_store()
                    self._store_loaded = True
            self.view_tabs.currentChanged.connect(on_tab_changed)
            
            # =====================================================================
            # INSTALLED PLUGINS TAB
            # =====================================================================
            installed_widget = QWidget()
            installed_layout = QVBoxLayout(installed_widget)
            installed_layout.setContentsMargins(8, 12, 8, 8)
            
            # Header
            header_layout = QHBoxLayout()
            title = QLabel("🔌 Plugin Manager")
            title.setStyleSheet("font-size: 16px; font-weight: bold;")
            header_layout.addWidget(title)
            header_layout.addStretch()
            
            refresh_btn = QPushButton("🔄 Refresh")
            refresh_btn.clicked.connect(self._load_plugins)
            header_layout.addWidget(refresh_btn)
            
            open_folder_btn = QPushButton("📁 Open Plugins Folder")
            open_folder_btn.clicked.connect(self._open_plugins_folder)
            header_layout.addWidget(open_folder_btn)
            
            installed_layout.addLayout(header_layout)
            
            # Splitter for plugin list and details
            splitter = QSplitter(Qt.Orientation.Horizontal)
            
            # Plugin list
            list_widget = QWidget()
            list_layout = QVBoxLayout(list_widget)
            list_layout.setContentsMargins(0, 0, 0, 0)
            
            list_label = QLabel("Installed Plugins")
            list_label.setStyleSheet("font-weight: bold;")
            list_layout.addWidget(list_label)
            
            self.plugin_list = QListWidget()
            self.plugin_list.setMinimumWidth(250)
            self.plugin_list.currentItemChanged.connect(self._on_plugin_selected)
            self.plugin_list.itemDoubleClicked.connect(self._open_plugin)
            list_layout.addWidget(self.plugin_list)
            
            splitter.addWidget(list_widget)
            
            # Plugin details
            details_widget = QWidget()
            details_layout = QVBoxLayout(details_widget)
            details_layout.setContentsMargins(0, 0, 0, 0)
            
            details_label = QLabel("Plugin Details")
            details_label.setStyleSheet("font-weight: bold;")
            details_layout.addWidget(details_label)
            
            self.details_group = QGroupBox()
            self.details_layout = QVBoxLayout(self.details_group)
            
            # Plugin info labels
            self.plugin_icon = QLabel("🔌")
            self.plugin_icon.setStyleSheet("font-size: 48px;")
            self.plugin_icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.details_layout.addWidget(self.plugin_icon)
            
            self.plugin_name = QLabel("Select a plugin")
            self.plugin_name.setStyleSheet("font-size: 18px; font-weight: bold;")
            self.plugin_name.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.details_layout.addWidget(self.plugin_name)
            
            self.plugin_version = QLabel("")
            self.plugin_version.setStyleSheet("color: #888;")
            self.plugin_version.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.details_layout.addWidget(self.plugin_version)
            
            self.plugin_author = QLabel("")
            self.plugin_author.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.details_layout.addWidget(self.plugin_author)
            
            self.plugin_desc = QLabel("")
            self.plugin_desc.setWordWrap(True)
            self.plugin_desc.setStyleSheet("margin: 10px;")
            self.details_layout.addWidget(self.plugin_desc)
            
            # License/Payment info
            self.payment_group = QGroupBox("Support the Developer")
            payment_layout = QVBoxLayout(self.payment_group)
            
            self.license_label = QLabel("")
            self.license_label.setWordWrap(True)
            payment_layout.addWidget(self.license_label)
            
            self.payment_btn = QPushButton("💰 Support / Purchase")
            self.payment_btn.clicked.connect(self._open_payment)
            self.payment_btn.setVisible(False)
            payment_layout.addWidget(self.payment_btn)
            
            self.payment_group.setVisible(False)
            self.details_layout.addWidget(self.payment_group)
            
            self.details_layout.addStretch()
            
            # Action buttons
            btn_layout = QHBoxLayout()
            
            self.enable_btn = QPushButton("✓ Enable")
            self.enable_btn.clicked.connect(self._toggle_enable)
            self.enable_btn.setEnabled(False)
            btn_layout.addWidget(self.enable_btn)
            
            self.open_btn = QPushButton("▶ Open Plugin")
            self.open_btn.setProperty("primary", True)
            self.open_btn.clicked.connect(self._open_plugin)
            self.open_btn.setEnabled(False)
            btn_layout.addWidget(self.open_btn)
            
            self.uninstall_btn = QPushButton("🗑️ Uninstall")
            self.uninstall_btn.setStyleSheet("background-color: #c62828; color: white;")
            self.uninstall_btn.clicked.connect(self._uninstall_plugin)
            self.uninstall_btn.setEnabled(False)
            btn_layout.addWidget(self.uninstall_btn)
            
            self.details_layout.addLayout(btn_layout)
            
            details_layout.addWidget(self.details_group)
            splitter.addWidget(details_widget)
            
            splitter.setSizes([300, 500])
            installed_layout.addWidget(splitter)
            
            # Info label at bottom
            info_label = QLabel(
                "💡 Drop plugins into the 'plugins' folder to install them. "
                "Double-click a plugin to open it."
            )
            info_label.setStyleSheet("color: #888; font-style: italic;")
            installed_layout.addWidget(info_label)
            
            # Store reference to main view for installed tab
            self.main_view = splitter
            
            self.view_tabs.addTab(installed_widget, "📦 Installed")
            
            # =====================================================================
            # PLUGIN STORE TAB
            # =====================================================================
            store_widget = QWidget()
            store_main_layout = QVBoxLayout(store_widget)
            store_main_layout.setContentsMargins(8, 12, 8, 8)
            
            # Store Header with search and auth
            store_header = QHBoxLayout()
            
            store_title = QLabel("🛒 Plugin Store")
            store_title.setStyleSheet("font-size: 18px; font-weight: bold; color: #4fc3f7;")
            store_header.addWidget(store_title)
            
            store_header.addStretch()
            
            # Search
            self.store_search = QLineEdit()
            self.store_search.setPlaceholderText("Search plugins...")
            self.store_search.setMinimumWidth(220)
            self.store_search.setMaximumWidth(280)
            self.store_search.setStyleSheet("""
                QLineEdit {
                    background-color: #2a2a3a;
                    border: 1px solid #3a3a4a;
                    border-radius: 16px;
                    padding: 6px 14px;
                    color: #ffffff;
                    font-size: 12px;
                }
                QLineEdit:focus {
                    border-color: #4fc3f7;
                }
            """)
            self.store_search.returnPressed.connect(self._search_store)
            store_header.addWidget(self.store_search)
            
            search_btn = QPushButton("🔍")
            search_btn.setFixedSize(32, 32)
            search_btn.setStyleSheet("""
                QPushButton {
                    background-color: #3a3a4a;
                    border-radius: 16px;
                    border: none;
                    font-size: 16px;
                }
                QPushButton:hover {
                    background-color: #4fc3f7;
                }
            """)
            search_btn.clicked.connect(self._search_store)
            store_header.addWidget(search_btn)
            
            refresh_store_btn = QPushButton("🔄")
            refresh_store_btn.setFixedSize(32, 32)
            refresh_store_btn.setToolTip("Refresh store")
            refresh_store_btn.setStyleSheet("""
                QPushButton {
                    background-color: #3a3a4a;
                    border-radius: 16px;
                    border: none;
                    font-size: 16px;
                }
                QPushButton:hover {
                    background-color: #4fc3f7;
                }
            """)
            refresh_store_btn.clicked.connect(self._refresh_store)
            store_header.addWidget(refresh_store_btn)
            
            # Chat toggle button
            self.chat_toggle_btn = QPushButton("💬")
            self.chat_toggle_btn.setFixedSize(32, 32)
            self.chat_toggle_btn.setToolTip("Toggle Community Chat")
            self.chat_toggle_btn.setCheckable(True)
            self.chat_toggle_btn.setChecked(False)  # Chat hidden by default
            self.chat_toggle_btn.setStyleSheet("""
                QPushButton {
                    background-color: #3a3a4a;
                    border-radius: 16px;
                    border: none;
                    font-size: 16px;
                }
                QPushButton:hover {
                    background-color: #4fc3f7;
                }
                QPushButton:checked {
                    background-color: #4fc3f7;
                }
            """)
            self.chat_toggle_btn.clicked.connect(self._toggle_chat_panel)
            self.chat_toggle_btn.setToolTip("Click: Show/Hide chat\nDouble-click: Undock chat")
            self._chat_click_timer = None
            self._chat_is_undocked = False
            self._chat_floating_window = None
            store_header.addWidget(self.chat_toggle_btn)
            
            # Auth buttons
            self.login_btn = QPushButton("🔑 Login")
            self.login_btn.setStyleSheet("""
                QPushButton {
                    background-color: #3a3a4a;
                    border-radius: 14px;
                    padding: 6px 14px;
                    border: none;
                }
                QPushButton:hover {
                    background-color: #4fc3f7;
                    color: #000;
                }
            """)
            self.login_btn.clicked.connect(self._show_login_dialog)
            store_header.addWidget(self.login_btn)
            
            self.user_menu_btn = QPushButton()
            self.user_menu_btn.setVisible(False)
            self.user_menu_btn.setStyleSheet("""
                QPushButton {
                    background-color: #2e7d32;
                    border-radius: 14px;
                    padding: 6px 14px;
                    border: none;
                    color: #fff;
                }
                QPushButton:hover {
                    background-color: #4CAF50;
                }
            """)
            self.user_menu_btn.clicked.connect(self._show_user_menu)
            store_header.addWidget(self.user_menu_btn)
            
            store_main_layout.addLayout(store_header)
            
            # Category filter
            cat_layout = QHBoxLayout()
            cat_label = QLabel("Category:")
            cat_label.setStyleSheet("color: #888; font-size: 12px;")
            cat_layout.addWidget(cat_label)
            
            self.category_combo = QComboBox()
            self.category_combo.addItems(["All", "Tools", "Extraction", "Modification", "ADB", "Fastboot", "Utilities", "Other"])
            self.category_combo.currentTextChanged.connect(self._filter_store_category)
            self.category_combo.setMinimumWidth(140)
            self.category_combo.setStyleSheet("""
                QComboBox {
                    background-color: #2a2a3a;
                    border: 1px solid #3a3a4a;
                    border-radius: 12px;
                    padding: 5px 12px;
                    color: #ffffff;
                }
                QComboBox:hover {
                    border-color: #4fc3f7;
                }
                QComboBox::drop-down {
                    border: none;
                    padding-right: 8px;
                }
            """)
            cat_layout.addWidget(self.category_combo)
            cat_layout.addStretch()
            
            # Developer upload button (visible when logged in)
            self.upload_btn = QPushButton("📤 Upload Plugin")
            self.upload_btn.clicked.connect(self._show_upload_dialog)
            self.upload_btn.setVisible(False)
            self.upload_btn.setStyleSheet("""
                QPushButton {
                    background-color: #4CAF50;
                    color: #fff;
                    font-weight: bold;
                    padding: 8px 16px;
                    border-radius: 14px;
                    border: none;
                }
                QPushButton:hover {
                    background-color: #66bb6a;
                }
            """)
            cat_layout.addWidget(self.upload_btn)
            
            store_main_layout.addLayout(cat_layout)
            
            # Horizontal splitter: Plugin grid (left) + Chat (right)
            store_splitter = QSplitter(Qt.Orientation.Horizontal)
            store_splitter.setChildrenCollapsible(False)
            
            # Left side: Plugin grid
            store_left = QWidget()
            store_left_layout = QVBoxLayout(store_left)
            store_left_layout.setContentsMargins(0, 0, 0, 0)
            
            # Store plugin grid (using scroll area with grid)
            self.store_scroll = QScrollArea()
            self.store_scroll.setWidgetResizable(True)
            self.store_scroll.setFrameShape(QFrame.Shape.NoFrame)
            
            self.store_grid_widget = QWidget()
            self.store_grid_layout = QGridLayout(self.store_grid_widget)
            self.store_grid_layout.setSpacing(16)
            self.store_grid_layout.setContentsMargins(8, 8, 8, 8)
            self.store_grid_layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
            
            self.store_scroll.setWidget(self.store_grid_widget)
            store_left_layout.addWidget(self.store_scroll)
            
            # Store status
            self.store_status = QLabel("Connect to the Plugin Store to browse available plugins.")
            self.store_status.setStyleSheet("color: #6a6a8a; font-size: 12px; padding: 8px;")
            self.store_status.setAlignment(Qt.AlignmentFlag.AlignCenter)
            store_left_layout.addWidget(self.store_status)
            
            store_splitter.addWidget(store_left)
            
            # Right side: Community Chat (hidden by default)
            self.community_chat = CommunityChatWidget()
            self.community_chat.setMinimumWidth(250)
            self.community_chat.setMaximumWidth(350)
            self.community_chat.setVisible(False)  # Hidden by default
            store_splitter.addWidget(self.community_chat)
            
            # Set splitter sizes (100% plugins when chat hidden)
            store_splitter.setSizes([850, 0])
            
            store_main_layout.addWidget(store_splitter, 1)
            
            self.view_tabs.addTab(store_widget, "🛒 Store")

            
            # =====================================================================
            # PLUGIN PLAYGROUND TAB - Fully Functional!
            # =====================================================================
            self.plugin_playground = PluginPlayground()
            self.view_tabs.addTab(self.plugin_playground, "🧪 Playground")
            
            # =====================================================================
            # VISUAL PLUGIN MAKER TAB - Fully Functional!
            # =====================================================================
            self.visual_plugin_maker = VisualPluginMaker()
            self.view_tabs.addTab(self.visual_plugin_maker, "🎨 Creator")
            
            layout.addWidget(self.view_tabs)
            
            # Plugin content area (shown when a plugin is opened)
            self.plugin_container = QWidget()
            self.plugin_container_layout = QVBoxLayout(self.plugin_container)
            self.plugin_container_layout.setContentsMargins(0, 0, 0, 0)
            
            # Back button header
            back_header = QHBoxLayout()
            self.back_btn = QPushButton("← Back to Plugins")
            self.back_btn.clicked.connect(self._close_plugin)
            back_header.addWidget(self.back_btn)
            
            self.active_plugin_label = QLabel("")
            self.active_plugin_label.setStyleSheet("font-weight: bold; font-size: 14px;")
            back_header.addWidget(self.active_plugin_label)
            back_header.addStretch()
            self.plugin_container_layout.addLayout(back_header)
            
            # Plugin widget holder
            self.plugin_widget_holder = QWidget()
            self.plugin_widget_layout = QVBoxLayout(self.plugin_widget_holder)
            self.plugin_widget_layout.setContentsMargins(0, 0, 0, 0)
            self.plugin_container_layout.addWidget(self.plugin_widget_holder)
            
            self.plugin_container.setVisible(False)
            layout.addWidget(self.plugin_container)
            
            # Update auth UI
            self._update_auth_ui()
        
        def _load_plugins(self):
            """Load and display all available plugins."""
            self.plugin_list.clear()
            
            # Create example plugin if plugins folder is empty
            plugin_manager.create_example_plugin()
            
            # Discover external plugins
            external_plugins = plugin_manager.discover_plugins()
            
            # Add built-in plugins first (if any)
            for plugin_id, plugin in self.builtin_plugins.items():
                manifest = plugin.manifest
                item = QListWidgetItem(f"{manifest.icon} {manifest.name}")
                item.setData(Qt.ItemDataRole.UserRole, {
                    'id': plugin_id,
                    'builtin': True,
                    'manifest': manifest
                })
                if manifest.license_type == "free":
                    item.setToolTip("Free (built-in)")
                self.plugin_list.addItem(item)
            
            # Add external plugins
            for manifest in external_plugins:
                icon = manifest.icon
                if not manifest.enabled:
                    icon = "⭕"  # Disabled indicator
                
                item = QListWidgetItem(f"{icon} {manifest.name}")
                item.setData(Qt.ItemDataRole.UserRole, {
                    'id': manifest.id,
                    'builtin': False,
                    'manifest': manifest
                })
                
                # Tooltip with license info
                tip = f"v{manifest.version} by {manifest.author}"
                if manifest.license_type == "paid":
                    tip += f" - ${manifest.price} {manifest.currency}"
                elif manifest.license_type == "donation":
                    tip += " - Donations welcome"
                item.setToolTip(tip)
                
                self.plugin_list.addItem(item)
        
        def _on_plugin_selected(self, current, previous):
            """Show details for selected plugin."""
            if not current:
                return
            
            data = current.data(Qt.ItemDataRole.UserRole)
            manifest = data['manifest']
            
            self.plugin_icon.setText(manifest.icon)
            self.plugin_name.setText(manifest.name)
            self.plugin_version.setText(f"Version {manifest.version}")
            self.plugin_author.setText(f"by {manifest.author}")
            self.plugin_desc.setText(manifest.description)
            
            # Update enable button
            if data['builtin']:
                self.enable_btn.setText("✓ Built-in")
                self.enable_btn.setEnabled(False)
            else:
                if manifest.enabled:
                    self.enable_btn.setText("✓ Enabled")
                else:
                    self.enable_btn.setText("○ Disabled")
                self.enable_btn.setEnabled(True)
            
            # Only developer_guide cannot be uninstalled
            if data['id'] == 'developer_guide':
                self.uninstall_btn.setEnabled(False)
                self.uninstall_btn.setToolTip("Developer Guide cannot be uninstalled")
            else:
                self.uninstall_btn.setEnabled(True)
                self.uninstall_btn.setToolTip("Remove this plugin")
            
            self.open_btn.setEnabled(manifest.enabled)
            
            # Payment/license info
            if manifest.license_type in ("paid", "donation"):
                self.payment_group.setVisible(True)
                
                if manifest.license_type == "paid":
                    if manifest.licensed:
                        self.license_label.setText("✓ Licensed - Thank you for your support!")
                        self.payment_btn.setText("💝 Tip the Developer")
                    else:
                        self.license_label.setText(
                            f"This plugin costs ${manifest.price:.2f} {manifest.currency}.\n"
                            "Please support the developer to unlock all features."
                        )
                        self.payment_btn.setText(f"💰 Purchase (${manifest.price:.2f})")
                else:
                    self.license_label.setText(
                        "This plugin is free, but donations help the developer\n"
                        "continue creating great tools!"
                    )
                    self.payment_btn.setText("💝 Donate")
                
                self.payment_btn.setVisible(bool(manifest.payment_address))
                self._current_payment_info = {
                    'address': manifest.payment_address,
                    'type': manifest.payment_type,
                    'price': manifest.price
                }
            else:
                self.payment_group.setVisible(False)
        
        def _toggle_enable(self):
            """Toggle the selected plugin's enabled state."""
            current = self.plugin_list.currentItem()
            if not current:
                return
            
            data = current.data(Qt.ItemDataRole.UserRole)
            if data['builtin']:
                return
            
            manifest = data['manifest']
            new_state = not manifest.enabled
            plugin_manager.enable_plugin(manifest.id, new_state)
            
            # Refresh list
            self._load_plugins()
        
        def _uninstall_plugin(self):
            """Uninstall the selected plugin."""
            current = self.plugin_list.currentItem()
            if not current:
                return
            
            data = current.data(Qt.ItemDataRole.UserRole)
            plugin_id = data['id']
            
            # Only developer_guide is protected
            if plugin_id == 'developer_guide':
                QMessageBox.warning(
                    self,
                    "Cannot Uninstall",
                    "The Plugin Developer's Guide cannot be uninstalled."
                )
                return
            
            manifest = data['manifest']
            
            # Confirm uninstall
            reply = QMessageBox.question(
                self,
                "Confirm Uninstall",
                f"Are you sure you want to uninstall '{manifest.name}'?\n\n"
                "This will delete the plugin folder and all its files.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                return
            
            # Get plugin path and delete
            plugins_dir = plugin_manager._get_plugins_dir()
            plugin_path = os.path.join(plugins_dir, plugin_id)
            
            if os.path.exists(plugin_path):
                try:
                    self._force_remove_directory(plugin_path, plugin_id)
                    
                    QMessageBox.information(
                        self,
                        "Plugin Uninstalled",
                        f"'{manifest.name}' has been successfully uninstalled."
                    )
                    
                    # Refresh the plugin list
                    self._load_plugins()
                    
                    # Clear details panel
                    self.plugin_icon.setText("🔌")
                    self.plugin_name.setText("Select a plugin")
                    self.plugin_version.setText("")
                    self.plugin_author.setText("")
                    self.plugin_desc.setText("")
                    self.payment_group.setVisible(False)
                    self.enable_btn.setEnabled(False)
                    self.open_btn.setEnabled(False)
                    self.uninstall_btn.setEnabled(False)
                    
                except Exception as e:
                    QMessageBox.critical(
                        self,
                        "Uninstall Failed",
                        f"Failed to uninstall plugin:\n{str(e)}"
                    )
            else:
                QMessageBox.warning(
                    self,
                    "Plugin Not Found",
                    f"Plugin folder not found at:\n{plugin_path}"
                )
        
        def _force_remove_directory(self, path: str, plugin_id: str):
            """Forcefully remove a directory, handling locked files and read-only attributes."""
            import shutil
            import stat
            import subprocess
            import time
            
            # Kill processes that might be locking files
            processes_to_kill = ['adb.exe', 'fastboot.exe', 'mtk_client.exe', 'python.exe']
            plugin_path_lower = path.lower()
            
            # Try to kill any processes that might be using files in this plugin
            try:
                if sys.platform == 'win32':
                    # Use tasklist to find processes and check if they're from this plugin folder
                    result = subprocess.run(
                        ['tasklist', '/FO', 'CSV', '/V'],
                        capture_output=True, text=True, timeout=10
                    )
                    # Look for adb.exe or fastboot.exe specifically
                    for proc_name in ['adb.exe', 'fastboot.exe']:
                        if proc_name in result.stdout.lower():
                            # Check if this is from our plugin directory by trying to kill gracefully
                            subprocess.run(
                                ['taskkill', '/F', '/IM', proc_name],
                                capture_output=True, timeout=5
                            )
                            time.sleep(0.5)  # Give time for process to fully terminate
            except Exception:
                pass  # Best effort - continue even if this fails
            
            def on_rm_error(func, filepath, exc_info):
                """Error handler for shutil.rmtree - handles read-only and permission errors."""
                try:
                    # Clear the read-only flag
                    os.chmod(filepath, stat.S_IWRITE | stat.S_IREAD)
                    # Try again
                    func(filepath)
                except Exception as e:
                    # If still failing, try one more approach on Windows
                    if sys.platform == 'win32':
                        try:
                            # Use attrib to clear all attributes
                            subprocess.run(
                                ['attrib', '-R', '-H', '-S', filepath],
                                capture_output=True, timeout=5
                            )
                            func(filepath)
                        except Exception:
                            raise e
                    else:
                        raise e
            
            # First pass: try to make all files writable
            for root, dirs, files in os.walk(path):
                for name in files:
                    filepath = os.path.join(root, name)
                    try:
                        os.chmod(filepath, stat.S_IWRITE | stat.S_IREAD)
                    except Exception:
                        pass
                for name in dirs:
                    dirpath = os.path.join(root, name)
                    try:
                        os.chmod(dirpath, stat.S_IWRITE | stat.S_IREAD | stat.S_IEXEC)
                    except Exception:
                        pass
            
            # Try rmtree with error handler
            try:
                shutil.rmtree(path, onerror=on_rm_error)
            except Exception as e:
                # Last resort on Windows: use rd /s /q
                if sys.platform == 'win32':
                    try:
                        # Use Windows rd command which can be more forceful
                        result = subprocess.run(
                            ['cmd', '/c', 'rd', '/s', '/q', path],
                            capture_output=True, text=True, timeout=30
                        )
                        if os.path.exists(path):
                            raise Exception(f"Directory still exists after rd command: {result.stderr}")
                    except subprocess.TimeoutExpired:
                        raise Exception("Timeout while removing directory")
                    except Exception as rd_error:
                        raise Exception(f"Failed to remove directory: {str(e)}. rd also failed: {str(rd_error)}")
                else:
                    raise
        
        def _open_payment(self):
            """Open payment link or show payment address."""
            if not hasattr(self, '_current_payment_info'):
                return
            
            info = self._current_payment_info
            if info['type'] == 'btc':
                # Show BTC address with copy option
                QMessageBox.information(
                    self,
                    "Bitcoin Payment",
                    f"Send payment to:\n\n{info['address']}\n\n"
                    "After payment, the developer will provide a license key."
                )
            elif info['type'] in ('paypal', 'kofi', 'patreon', 'github'):
                # Open URL
                import webbrowser
                webbrowser.open(info['address'])
            else:
                QMessageBox.information(
                    self,
                    "Payment",
                    f"Payment address:\n{info['address']}"
                )
        
        def _open_plugin(self, item=None):
            """Open the selected plugin."""
            # Handle case where called from button click (passes bool) vs double-click (passes item)
            if item is None or isinstance(item, bool):
                item = self.plugin_list.currentItem()
            if not item:
                return
            
            data = item.data(Qt.ItemDataRole.UserRole)
            if not data:
                return
            
            manifest = data['manifest']
            plugin_id = data['id']
            
            if not manifest.enabled:
                QMessageBox.warning(
                    self,
                    "Plugin Disabled",
                    "This plugin is disabled. Enable it first to use it."
                )
                return
            
            # ═══════════════════════════════════════════════════════════════════════
            # Check for deferred setup_commands (pip install ., etc.)
            # These run on first plugin open after download to ensure all files exist
            # ═══════════════════════════════════════════════════════════════════════
            if not data['builtin'] and plugin_manager.has_pending_setup_commands(plugin_id):
                msg = (
                    f"Plugin '{manifest.name}' needs to complete setup.\n\n"
                    "This includes installing Python packages and dependencies.\n"
                    "This may take a few minutes.\n\n"
                    "Would you like to run the setup now?"
                )
                
                reply = QMessageBox.question(
                    self,
                    "Plugin Setup Required",
                    msg,
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                
                if reply == QMessageBox.StandardButton.Yes:
                    from PyQt6.QtWidgets import QProgressDialog
                    progress = QProgressDialog(
                        "Running plugin setup...", "Cancel", 0, 100, self
                    )
                    progress.setWindowModality(Qt.WindowModality.WindowModal)
                    progress.setMinimumDuration(0)
                    progress.setValue(0)
                    progress.setWindowTitle(f"Setting up {manifest.name}")
                    
                    def progress_callback(step_name: str, status: str, pct: int):
                        progress.setLabelText(f"{step_name}\n{status}")
                        progress.setValue(pct)
                        QApplication.processEvents()
                    
                    self._log(f"Running deferred setup for {manifest.name}...")
                    QApplication.processEvents()
                    
                    success, message = plugin_manager.run_deferred_setup_commands(plugin_id, progress_callback)
                    progress.close()
                    
                    if success:
                        self._log(f"✓ Setup complete for {manifest.name}")
                        QMessageBox.information(
                            self,
                            "Setup Complete",
                            f"Plugin '{manifest.name}' setup completed successfully!"
                        )
                    else:
                        self._log(f"✗ Setup failed: {message}")
                        QMessageBox.warning(
                            self,
                            "Setup Issues",
                            f"Setup encountered issues:\n\n{message[:500]}\n\n"
                            "The plugin may still work, but some features might be unavailable."
                        )
                        # Continue anyway - user might want to try the plugin
                else:
                    QMessageBox.information(
                        self,
                        "Setup Skipped",
                        "Setup was skipped. The plugin may not work correctly.\n\n"
                        "You can try again by reopening the plugin."
                    )
                    return
            
            # Check for post-install steps (drivers, git clones, etc.)
            if not data['builtin'] and manifest.post_install:
                # Check if post-install has already been completed
                plugin_config = plugin_manager.config.get(plugin_id, {})
                if not plugin_config.get('post_install_done', False):
                    # Build description of what will happen
                    steps_desc = []
                    for step in manifest.post_install:
                        step_type = step.get('type', '')
                        step_name = step.get('name', step_type)
                        if step_type == 'driver':
                            steps_desc.append(f"• Install driver: {step.get('file', 'Unknown')}")
                        elif step_type == 'git_clone':
                            steps_desc.append(f"• Clone repository: {step.get('repo', 'Unknown')}")
                        elif step_type == 'pip_requirements':
                            steps_desc.append(f"• Install pip requirements from cloned repo")
                        elif step_type == 'command':
                            steps_desc.append(f"• Run setup command")
                    
                    if steps_desc:
                        msg = (
                            f"Plugin '{manifest.name}' requires additional setup:\n\n"
                            + "\n".join(steps_desc) + "\n\n"
                            "Would you like to run the setup now?\n"
                            "(This may take a few minutes)"
                        )
                        
                        reply = QMessageBox.question(
                            self,
                            "Plugin Setup Required",
                            msg,
                            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                        )
                        
                        if reply == QMessageBox.StandardButton.Yes:
                            # Create progress dialog
                            from PyQt6.QtWidgets import QProgressDialog
                            progress = QProgressDialog(
                                "Running plugin setup...", "Cancel", 0, len(manifest.post_install), self
                            )
                            progress.setWindowModality(Qt.WindowModality.WindowModal)
                            progress.setMinimumDuration(0)
                            progress.setValue(0)
                            progress.setWindowTitle("Plugin Setup")
                            
                            step_idx = [0]  # Use list for closure
                            
                            def progress_callback(step_name: str, status: str):
                                progress.setLabelText(f"Step: {step_name}\nStatus: {status}")
                                step_idx[0] += 1
                                progress.setValue(min(step_idx[0], len(manifest.post_install)))
                                QApplication.processEvents()
                            
                            self._log(f"Running post-install setup for {manifest.name}...")
                            QApplication.processEvents()
                            
                            success, message = plugin_manager.run_post_install(plugin_id, progress_callback)
                            progress.close()
                            
                            if success:
                                self._log(f"✓ Post-install setup complete")
                                # Mark as done
                                if plugin_id not in plugin_manager.config:
                                    plugin_manager.config[plugin_id] = {}
                                plugin_manager.config[plugin_id]['post_install_done'] = True
                                plugin_manager._save_config()
                                
                                QMessageBox.information(
                                    self,
                                    "Setup Complete",
                                    f"Plugin '{manifest.name}' setup completed successfully!"
                                )
                            else:
                                self._log(f"✗ Post-install setup failed: {message}")
                                QMessageBox.warning(
                                    self,
                                    "Setup Issues",
                                    f"Some setup steps had issues:\n\n{message}\n\n"
                                    "The plugin may still work, but some features might be unavailable.\n"
                                    "You can try the manual setup in the plugin's Setup tab."
                                )
                        else:
                            # User declined - show info about manual setup
                            QMessageBox.information(
                                self,
                                "Setup Skipped",
                                "You can run the setup later from the plugin's Setup tab.\n\n"
                                "Some features may not work until setup is complete."
                            )
            
            # Generic check: if plugin has git_clone or other setup requirements not yet completed
            if not data['builtin']:
                plugin_config = plugin_manager.config.get(plugin_id, {})
                if not plugin_config.get('setup_complete', False):
                    # Check if plugin has setup requirements
                    has_git_clone = manifest.git_clone is not None
                    has_bundled_binaries = bool(manifest.bundled_binaries)
                    
                    if has_git_clone or has_bundled_binaries:
                        # Run setup
                        from PyQt6.QtWidgets import QProgressDialog
                        progress_dialog = QProgressDialog(
                            f"Setting up {manifest.name}...",
                            "Cancel",
                            0, 100,
                            self
                        )
                        progress_dialog.setWindowTitle("Plugin Setup")
                        progress_dialog.setWindowModality(Qt.WindowModality.WindowModal)
                        progress_dialog.setMinimumDuration(0)
                        progress_dialog.setValue(0)
                        
                        def setup_progress(step_name: str, status: str, progress: int):
                            if progress_dialog.wasCanceled():
                                return
                            progress_dialog.setLabelText(f"{step_name}\n{status}")
                            progress_dialog.setValue(progress)
                            QApplication.processEvents()
                        
                        success, message = plugin_manager.setup_plugin_dependencies(plugin_id, setup_progress)
                        progress_dialog.close()
                        
                        if not success:
                            reply = QMessageBox.warning(
                                self,
                                "Setup Issues",
                                f"Some setup steps had issues:\n\n{message}\n\n"
                                "Would you like to continue loading the plugin anyway?",
                                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                            )
                            if reply != QMessageBox.StandardButton.Yes:
                                return
            
            # Load plugin if not already loaded
            if plugin_id in self.loaded_widgets:
                widget = self.loaded_widgets[plugin_id]
            else:
                if data['builtin']:
                    plugin = self.builtin_plugins[plugin_id]
                else:
                    plugin = plugin_manager.load_plugin(plugin_id)
                
                if not plugin:
                    QMessageBox.critical(
                        self,
                        "Error",
                        f"Failed to load plugin: {manifest.name}"
                    )
                    return
                
                try:
                    widget = plugin.create_widget(self.parent_window)
                    if widget is None:
                        QMessageBox.critical(
                            self,
                            "Error",
                            f"Plugin '{manifest.name}' returned no widget."
                        )
                        return
                    self.loaded_widgets[plugin_id] = widget
                    self.loaded_plugins[plugin_id] = plugin  # Track plugin for cleanup
                except Exception as e:
                    logger.exception(f"Failed to create plugin widget: {e}")
                    QMessageBox.critical(
                        self,
                        "Error",
                        f"Failed to create plugin widget:\n{str(e)}"
                    )
                    return
            
            # Track active plugin for cleanup
            self.active_plugin_id = plugin_id
            
            # Show plugin view
            self.view_tabs.setVisible(False)
            
            # Clear old widget from layout (but don't destroy it)
            while self.plugin_widget_layout.count():
                child = self.plugin_widget_layout.takeAt(0)
                if child.widget():
                    child.widget().setParent(None)
            
            # Add widget to layout
            self.plugin_widget_layout.addWidget(widget)
            widget.setVisible(True)
            self.active_plugin_label.setText(f"{manifest.icon} {manifest.name}")
            self.plugin_container.setVisible(True)
        
        def _close_plugin(self):
            """Close the current plugin and return to list."""
            # Call cleanup on the active plugin if it has one
            if self.active_plugin_id and self.active_plugin_id in self.loaded_plugins:
                plugin = self.loaded_plugins[self.active_plugin_id]
                if hasattr(plugin, 'cleanup') and callable(plugin.cleanup):
                    try:
                        plugin.cleanup()
                    except Exception as e:
                        logger.warning(f"[Plugins] Cleanup error for {self.active_plugin_id}: {e}")
            
            self.active_plugin_id = None
            self.plugin_container.setVisible(False)
            self.view_tabs.setVisible(True)
        
        def _open_plugins_folder(self):
            """Open the plugins folder in file explorer."""
            plugins_dir = plugin_manager._get_plugins_dir()
            os.makedirs(plugins_dir, exist_ok=True)
            
            if sys.platform == 'win32':
                os.startfile(plugins_dir)
            elif sys.platform == 'darwin':
                subprocess.run(['open', plugins_dir])
            else:
                subprocess.run(['xdg-open', plugins_dir])
        
        # =====================================================================
        # PLUGIN STORE METHODS
        # =====================================================================
        
        def _update_auth_ui(self):
            """Update the auth UI based on login status."""
            if plugin_store_api.is_logged_in():
                self.login_btn.setVisible(False)
                self.user_menu_btn.setVisible(True)
                username = plugin_store_api.user.get('username', 'User')
                self.user_menu_btn.setText(f"👤 {username}")
                self.upload_btn.setVisible(True)
                
                # Connect to community chat when logged in
                if hasattr(self, 'community_chat'):
                    self.community_chat.connect_chat(username)
            else:
                self.login_btn.setVisible(True)
                self.user_menu_btn.setVisible(False)
                self.upload_btn.setVisible(False)
                
                # Disconnect from community chat when logged out
                if hasattr(self, 'community_chat'):
                    self.community_chat.disconnect_chat()
        
        def _toggle_chat_panel(self):
            """Toggle the community chat panel visibility or undock on double-click."""
            # Detect double-click for undock
            if self._chat_click_timer is not None:
                # This is a double-click - undock or dock
                self._chat_click_timer.stop()
                self._chat_click_timer = None
                self._toggle_chat_dock()
                return
            
            # Start timer to detect double-click
            self._chat_click_timer = QTimer()
            self._chat_click_timer.setSingleShot(True)
            self._chat_click_timer.timeout.connect(self._do_toggle_chat_visibility)
            self._chat_click_timer.start(300)  # 300ms window for double-click
            
        def _do_toggle_chat_visibility(self):
            """Actually toggle chat visibility after double-click timeout."""
            self._chat_click_timer = None
            
            # If undocked, just focus the floating window
            if self._chat_is_undocked and self._chat_floating_window:
                self._chat_floating_window.raise_()
                self._chat_floating_window.activateWindow()
                return
            
            is_visible = self.chat_toggle_btn.isChecked()
            self.community_chat.setVisible(is_visible)
            
            # Adjust splitter sizes based on visibility
            if is_visible:
                # Show chat: 75% plugins, 25% chat
                total = sum(self.findChild(QSplitter).sizes()) if self.findChild(QSplitter) else 850
                self.findChild(QSplitter).setSizes([int(total * 0.75), int(total * 0.25)])
            else:
                # Hide chat: 100% plugins
                if self.findChild(QSplitter):
                    total = sum(self.findChild(QSplitter).sizes())
                    self.findChild(QSplitter).setSizes([total, 0])
                    
        def _toggle_chat_dock(self):
            """Toggle between docked and floating chat window."""
            if self._chat_is_undocked:
                # Dock back into main window
                self._dock_chat()
            else:
                # Undock into floating window
                self._undock_chat()
                
        def _undock_chat(self):
            """Undock chat into floating window."""
            if self._chat_is_undocked:
                return
                
            # Create floating window with proper close handling
            class ChatFloatingWindow(QWidget):
                closed = pyqtSignal()
                def __init__(self, parent_ref):
                    super().__init__(None, Qt.WindowType.Window)
                    self._parent_ref = parent_ref
                def closeEvent(self, event):
                    # Dock the chat back before closing
                    if self._parent_ref and hasattr(self._parent_ref, '_dock_chat_internal'):
                        self._parent_ref._dock_chat_internal()
                    event.accept()
            
            self._chat_floating_window = ChatFloatingWindow(self)
            self._chat_floating_window.setWindowTitle("💬 Community Chat - Image Anarchy")
            self._chat_floating_window.setMinimumSize(350, 500)
            self._chat_floating_window.resize(400, 600)
            self._chat_floating_window.setStyleSheet("background-color: #1e1e1e;")
            
            # Move chat widget to floating window
            layout = QVBoxLayout(self._chat_floating_window)
            layout.setContentsMargins(0, 0, 0, 0)
            self.community_chat.setParent(self._chat_floating_window)
            layout.addWidget(self.community_chat)
            self.community_chat.setVisible(True)
            self.community_chat.setMinimumWidth(0)  # Remove min width constraint
            self.community_chat.setMaximumWidth(16777215)  # Remove max width constraint
            
            # Position near main window
            main_geo = self.geometry()
            self._chat_floating_window.move(main_geo.right() + 10, main_geo.top())
            
            self._chat_floating_window.show()
            self._chat_is_undocked = True
            
            # Update button state
            self.chat_toggle_btn.setChecked(True)
            self.chat_toggle_btn.setToolTip("Double-click: Dock chat back")
            
        def _dock_chat_internal(self):
            """Internal dock method called from floating window closeEvent.
            Does NOT close the floating window (it's already closing)."""
            if not self._chat_is_undocked:
                return
                
            # Find the splitter in plugin store tab
            splitter = self.findChild(QSplitter)
            if splitter:
                # Move chat widget back to splitter
                self.community_chat.setParent(None)
                self.community_chat.setMinimumWidth(250)
                self.community_chat.setMaximumWidth(350)
                splitter.addWidget(self.community_chat)
                self.community_chat.setVisible(True)
                
                # Adjust splitter sizes
                total = sum(splitter.sizes())
                splitter.setSizes([int(total * 0.75), int(total * 0.25)])
            
            # Clear reference (window is closing itself)
            self._chat_floating_window = None
            self._chat_is_undocked = False
            self.chat_toggle_btn.setToolTip("Click: Show/Hide chat\nDouble-click: Undock chat")
            
        def _dock_chat(self):
            """Dock chat back into main window (called from double-click)."""
            if not self._chat_is_undocked:
                return
                
            # Find the splitter in plugin store tab
            splitter = self.findChild(QSplitter)
            if splitter:
                # Move chat widget back to splitter
                self.community_chat.setParent(None)
                self.community_chat.setMinimumWidth(250)
                self.community_chat.setMaximumWidth(350)
                splitter.addWidget(self.community_chat)
                self.community_chat.setVisible(True)
                
                # Adjust splitter sizes
                total = sum(splitter.sizes())
                splitter.setSizes([int(total * 0.75), int(total * 0.25)])
            
            # Close floating window
            if self._chat_floating_window:
                # Temporarily clear reference to avoid recursion
                window = self._chat_floating_window
                self._chat_floating_window = None
                self._chat_is_undocked = False
                window.close()
                window.deleteLater()
                
            self.chat_toggle_btn.setToolTip("Click: Show/Hide chat\nDouble-click: Undock chat")
        
        def _refresh_store(self):
            """Refresh the plugin store listing using background thread."""
            self.store_status.setText("Loading plugins from store...")
            
            # Clear existing grid
            while self.store_grid_layout.count():
                item = self.store_grid_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
            
            # Fetch plugins in background thread to avoid blocking UI
            self._store_refresh_thread = StoreRefreshThread(plugin_store_api)
            
            def on_store_refresh_finished(plugins):
                if not plugins:
                    self.store_status.setText(
                        "No plugins found or unable to connect to store.\n"
                        f"Server: {plugin_store_api.base_url}"
                    )
                    return
                
                self.store_status.setText(f"Found {len(plugins)} plugins")
                self._store_plugins = plugins
                self._display_store_plugins(plugins)
            
            def on_store_refresh_error(error_msg):
                self.store_status.setText(f"Error loading store: {error_msg}")
            
            self._store_refresh_thread.finished.connect(on_store_refresh_finished)
            self._store_refresh_thread.error.connect(on_store_refresh_error)
            self._store_refresh_thread.start()
        
        def _display_store_plugins(self, plugins: list):
            """Display plugins in the store grid."""
            # Clear existing
            while self.store_grid_layout.count():
                item = self.store_grid_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
            
            row, col = 0, 0
            max_cols = 3
            
            for plugin in plugins:
                card = self._create_store_plugin_card(plugin)
                self.store_grid_layout.addWidget(card, row, col)
                col += 1
                if col >= max_cols:
                    col = 0
                    row += 1
        
        def _create_store_plugin_card(self, plugin: dict) -> QWidget:
            """Create a modern card widget for a store plugin."""
            card = QFrame()
            card.setFrameShape(QFrame.Shape.StyledPanel)
            card.setStyleSheet("""
                QFrame {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 #2d2d3a, stop:1 #1e1e28);
                    border: 1px solid #3a3a4a;
                    border-radius: 12px;
                    padding: 0px;
                }
                QFrame:hover {
                    border: 2px solid #4fc3f7;
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 #353545, stop:1 #252530);
                }
            """)
            card.setFixedSize(280, 220)
            
            layout = QVBoxLayout(card)
            layout.setSpacing(8)
            layout.setContentsMargins(14, 14, 14, 12)
            
            # Header with icon and name
            header = QHBoxLayout()
            header.setSpacing(12)
            
            # Icon with background
            icon_container = QFrame()
            icon_container.setFixedSize(50, 50)
            icon_container.setStyleSheet("""
                QFrame {
                    background-color: rgba(79, 195, 247, 0.15);
                    border-radius: 10px;
                    border: none;
                }
            """)
            icon_layout = QVBoxLayout(icon_container)
            icon_layout.setContentsMargins(0, 0, 0, 0)
            icon_label = QLabel(plugin.get('icon', '🔌'))
            icon_label.setStyleSheet("font-size: 28px; background: transparent; border: none;")
            icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            icon_layout.addWidget(icon_label)
            header.addWidget(icon_container)
            
            # Name and author column
            name_col = QVBoxLayout()
            name_col.setSpacing(2)
            
            name_label = QLabel(plugin.get('name', 'Unknown'))
            name_label.setStyleSheet("font-weight: bold; font-size: 14px; color: #ffffff; background: transparent; border: none;")
            name_label.setWordWrap(True)
            name_col.addWidget(name_label)
            
            info_label = QLabel(f"by {plugin.get('author_name', 'Unknown')} • v{plugin.get('version', '1.0')}")
            info_label.setStyleSheet("color: #8888aa; font-size: 11px; background: transparent; border: none;")
            name_col.addWidget(info_label)
            
            header.addLayout(name_col, 1)
            layout.addLayout(header)
            
            # Description - now with more space
            desc = plugin.get('description', 'No description available')
            if len(desc) > 120:
                desc = desc[:117] + '...'
            desc_label = QLabel(desc)
            desc_label.setWordWrap(True)
            desc_label.setStyleSheet("color: #aaaacc; font-size: 12px; line-height: 1.4; background: transparent; border: none;")
            desc_label.setMinimumHeight(50)
            desc_label.setMaximumHeight(60)
            layout.addWidget(desc_label)
            
            layout.addStretch()
            
            # Footer with license badge, downloads, and button
            footer = QHBoxLayout()
            footer.setSpacing(8)
            
            # License/Price badge with pill style
            license_type = plugin.get('license_type', 'free')
            price_badge = QLabel()
            if license_type == 'free':
                price_badge.setText("FREE")
                price_badge.setStyleSheet("""
                    QLabel {
                        background-color: rgba(76, 175, 80, 0.2);
                        color: #4CAF50;
                        font-weight: bold;
                        font-size: 10px;
                        padding: 4px 10px;
                        border-radius: 10px;
                        border: none;
                    }
                """)
            elif license_type == 'donation':
                price_badge.setText("☕ TIP")
                price_badge.setStyleSheet("""
                    QLabel {
                        background-color: rgba(255, 152, 0, 0.2);
                        color: #ff9800;
                        font-weight: bold;
                        font-size: 10px;
                        padding: 4px 10px;
                        border-radius: 10px;
                        border: none;
                    }
                """)
            else:
                price = plugin.get('price', 0)
                try:
                    price_val = float(price)
                except (ValueError, TypeError):
                    price_val = 0.0
                price_badge.setText(f"${price_val:.2f}")
                price_badge.setStyleSheet("""
                    QLabel {
                        background-color: rgba(244, 67, 54, 0.2);
                        color: #f44336;
                        font-weight: bold;
                        font-size: 10px;
                        padding: 4px 10px;
                        border-radius: 10px;
                        border: none;
                    }
                """)
            footer.addWidget(price_badge)
            
            # Downloads count with icon
            downloads = plugin.get('downloads', 0)
            dl_label = QLabel(f"⬇ {downloads}")
            dl_label.setStyleSheet("color: #666688; font-size: 11px; background: transparent; border: none;")
            footer.addWidget(dl_label)
            
            footer.addStretch()
            
            # Details button - modern style
            details_btn = QPushButton("Details")
            details_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            details_btn.setStyleSheet("""
                QPushButton {
                    background-color: #4fc3f7;
                    color: #000000;
                    font-weight: bold;
                    font-size: 11px;
                    padding: 6px 16px;
                    border-radius: 12px;
                    border: none;
                }
                QPushButton:hover {
                    background-color: #81d4fa;
                }
                QPushButton:pressed {
                    background-color: #29b6f6;
                }
            """)
            details_btn.clicked.connect(lambda checked, p=plugin: self._show_plugin_details(p))
            footer.addWidget(details_btn)
            
            layout.addLayout(footer)
            
            return card
        
        def _show_plugin_details(self, plugin: dict):
            """Show detailed view of a plugin with HTML description."""
            from PyQt6.QtWidgets import QTextBrowser
            
            plugin_id = plugin.get('id')
            plugin_name = plugin.get('name', 'Unknown')
            
            # Fetch full plugin details from API (includes long_description)
            self.store_status.setText(f"Loading details for {plugin_name}...")
            QApplication.processEvents()
            
            full_plugin = plugin_store_api.get_plugin(plugin_id)
            if 'error' in full_plugin:
                QMessageBox.warning(self, "Error", f"Failed to load plugin details:\n{full_plugin['error']}")
                self.store_status.setText("Failed to load details")
                return
            
            self.store_status.setText("")
            
            dialog = QDialog(self)
            dialog.setWindowTitle(f"{full_plugin.get('icon', '🔌')} {plugin_name}")
            dialog.setMinimumSize(650, 550)
            
            layout = QVBoxLayout(dialog)
            
            # Header
            header = QHBoxLayout()
            
            icon_label = QLabel(full_plugin.get('icon', '🔌'))
            icon_label.setStyleSheet("font-size: 48px;")
            header.addWidget(icon_label)
            
            header_info = QVBoxLayout()
            
            name_label = QLabel(f"<b style='font-size: 18px;'>{plugin_name}</b>")
            name_label.setTextFormat(Qt.TextFormat.RichText)
            header_info.addWidget(name_label)
            
            author_label = QLabel(f"by <b>{full_plugin.get('author_name', 'Unknown')}</b> • v{full_plugin.get('version', '1.0')}")
            author_label.setStyleSheet("color: #888;")
            header_info.addWidget(author_label)
            
            # Safely convert rating to float (API may return string)
            try:
                rating_val = float(full_plugin.get('rating', 0) or 0)
            except (ValueError, TypeError):
                rating_val = 0.0
            stats_label = QLabel(f"⬇️ {full_plugin.get('downloads', 0)} downloads • ⭐ {rating_val:.1f} ({full_plugin.get('rating_count', 0)} reviews)")
            stats_label.setStyleSheet("color: #666; font-size: 11px;")
            header_info.addWidget(stats_label)
            
            header.addLayout(header_info, 1)
            
            # Price badge
            license_type = full_plugin.get('license_type', 'free')
            if license_type == 'free':
                price_badge = QLabel("FREE")
                price_badge.setStyleSheet("background: #4CAF50; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;")
            elif license_type == 'donation':
                price_badge = QLabel("DONATION")
                price_badge.setStyleSheet("background: #ff9800; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;")
            else:
                try:
                    price = float(full_plugin.get('price', 0) or 0)
                except (ValueError, TypeError):
                    price = 0.0
                price_badge = QLabel(f"${price:.2f}")
                price_badge.setStyleSheet("background: #f44336; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;")
            header.addWidget(price_badge)
            
            layout.addLayout(header)
            
            # Category and tags
            tags_layout = QHBoxLayout()
            
            cat_label = QLabel(f"📁 {full_plugin.get('category', 'other')}")
            cat_label.setStyleSheet("background: #333; padding: 4px 8px; border-radius: 4px; font-size: 11px;")
            tags_layout.addWidget(cat_label)
            
            tags = full_plugin.get('tags', [])
            if isinstance(tags, str):
                try:
                    tags = json.loads(tags)
                except:
                    tags = []
            
            for tag in tags[:5]:
                tag_label = QLabel(f"🏷️ {tag}")
                tag_label.setStyleSheet("background: #2a4a6a; padding: 4px 8px; border-radius: 4px; font-size: 11px;")
                tags_layout.addWidget(tag_label)
            
            tags_layout.addStretch()
            layout.addLayout(tags_layout)
            
            # Screenshots button (if screenshots available)
            screenshots = full_plugin.get('screenshots', [])
            logger.debug(f"[PLUGIN DETAILS] Raw screenshots data: {screenshots} (type: {type(screenshots).__name__})")
            if isinstance(screenshots, str):
                try:
                    screenshots = json.loads(screenshots)
                    logger.debug(f"[PLUGIN DETAILS] Parsed screenshots: {screenshots}")
                except:
                    screenshots = []
                    logger.debug(f"[PLUGIN DETAILS] Failed to parse screenshots JSON")
            
            logger.info(f"[PLUGIN DETAILS] Plugin {plugin_name} has {len(screenshots)} screenshots: {screenshots}")
            
            if screenshots:
                screenshots_btn = QPushButton(f"🖼️ View Screenshots ({len(screenshots)})")
                screenshots_btn.setStyleSheet("background: #2196F3; padding: 8px 16px;")
                screenshots_btn.clicked.connect(lambda: self._show_screenshots_dialog(plugin_name, plugin_id, screenshots))
                layout.addWidget(screenshots_btn)
            
            # Description area with HTML support
            desc_group = QGroupBox("Description")
            desc_layout = QVBoxLayout(desc_group)
            
            desc_browser = QTextBrowser()
            desc_browser.setOpenExternalLinks(True)
            desc_browser.setStyleSheet("""
                QTextBrowser {
                    background-color: #1a1a1a;
                    border: 1px solid #333;
                    border-radius: 4px;
                    padding: 10px;
                }
            """)
            
            # Build HTML content
            long_desc = full_plugin.get('long_description', '')
            short_desc = full_plugin.get('description', '')
            
            html_content = f"""
            <style>
                body {{ font-family: 'Segoe UI', sans-serif; color: #e0e0e0; line-height: 1.6; }}
                h1, h2, h3 {{ color: #4fc3f7; }}
                a {{ color: #4fc3f7; }}
                code {{ background: #333; padding: 2px 6px; border-radius: 3px; }}
                pre {{ background: #1a1a2e; padding: 10px; border-radius: 6px; overflow-x: auto; }}
                ul, ol {{ margin-left: 20px; }}
                .highlight {{ background: #4fc3f720; padding: 10px; border-left: 3px solid #4fc3f7; margin: 10px 0; }}
            </style>
            <p>{short_desc}</p>
            <hr style="border-color: #333;">
            {long_desc if long_desc else '<p style="color: #666;"><i>No detailed description provided.</i></p>'}
            """
            
            desc_browser.setHtml(html_content)
            desc_layout.addWidget(desc_browser)
            layout.addWidget(desc_group)
            
            # Requirements info
            min_version = full_plugin.get('min_app_version', '1.0')
            req_label = QLabel(f"📋 Requires Image Anarchy v{min_version} or later")
            req_label.setStyleSheet("color: #888; font-size: 11px;")
            layout.addWidget(req_label)
            
            # Feedback, Rating, Bug Report Section
            feedback_tabs = QTabWidget()
            feedback_tabs.setMaximumHeight(200)
            
            # Tab 1: Reviews/Ratings
            reviews_tab = QWidget()
            reviews_layout = QVBoxLayout(reviews_tab)
            reviews_layout.setContentsMargins(5, 5, 5, 5)
            
            reviews_list = QTextEdit()
            reviews_list.setReadOnly(True)
            reviews_list.setMaximumHeight(120)
            
            # Populate reviews
            reviews = full_plugin.get('reviews', [])
            if reviews:
                reviews_html = ""
                for r in reviews[:10]:
                    try:
                        review_rating = int(r.get('rating', 0) or 0)
                    except (ValueError, TypeError):
                        review_rating = 0
                    review_rating = max(0, min(5, review_rating))  # Clamp to 0-5
                    stars = "⭐" * review_rating + "☆" * (5 - review_rating)
                    reviews_html += f"<p><b>{r.get('username', 'User')}</b> {stars}<br>"
                    reviews_html += f"<span style='color:#aaa;'>{r.get('comment', '')}</span></p><hr>"
                reviews_list.setHtml(reviews_html)
            else:
                reviews_list.setHtml("<p style='color:#888;'>No reviews yet. Be the first to rate this plugin!</p>")
            reviews_layout.addWidget(reviews_list)
            
            # Rate button
            rate_btn = QPushButton("⭐ Rate This Plugin")
            rate_btn.clicked.connect(lambda: self._show_rate_dialog(plugin_id, plugin_name))
            reviews_layout.addWidget(rate_btn)
            
            feedback_tabs.addTab(reviews_tab, "⭐ Reviews")
            
            # Tab 2: Feedback
            feedback_tab = QWidget()
            feedback_layout = QVBoxLayout(feedback_tab)
            feedback_layout.setContentsMargins(5, 5, 5, 5)
            
            feedback_label = QLabel("Share your thoughts with the developer:")
            feedback_label.setStyleSheet("color: #888;")
            feedback_layout.addWidget(feedback_label)
            
            feedback_btn = QPushButton("💬 Leave Feedback")
            feedback_btn.clicked.connect(lambda: self._show_feedback_dialog(plugin_id, plugin_name))
            feedback_layout.addWidget(feedback_btn)
            feedback_layout.addStretch()
            
            feedback_tabs.addTab(feedback_tab, "💬 Feedback")
            
            # Tab 3: Bug Report
            bug_tab = QWidget()
            bug_layout = QVBoxLayout(bug_tab)
            bug_layout.setContentsMargins(5, 5, 5, 5)
            
            bug_label = QLabel("Found a bug? Report it here (no login required):")
            bug_label.setStyleSheet("color: #888;")
            bug_layout.addWidget(bug_label)
            
            bug_btn = QPushButton("🐛 Report Bug")
            bug_btn.clicked.connect(lambda: self._show_bug_report_dialog(plugin_id, plugin_name))
            bug_layout.addWidget(bug_btn)
            bug_layout.addStretch()
            
            feedback_tabs.addTab(bug_tab, "🐛 Report Bug")
            
            layout.addWidget(feedback_tabs)
            
            # Buttons
            btn_layout = QHBoxLayout()
            
            if full_plugin.get('homepage'):
                homepage_btn = QPushButton("🌐 Homepage")
                homepage_btn.clicked.connect(lambda: webbrowser.open(full_plugin.get('homepage')))
                btn_layout.addWidget(homepage_btn)
            
            if full_plugin.get('repository'):
                repo_btn = QPushButton("📦 Repository")
                repo_btn.clicked.connect(lambda: webbrowser.open(full_plugin.get('repository')))
                btn_layout.addWidget(repo_btn)
            
            btn_layout.addStretch()
            
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(dialog.reject)
            btn_layout.addWidget(close_btn)
            
            install_btn = QPushButton("⬇️ Install Plugin")
            install_btn.setStyleSheet("background-color: #4CAF50; padding: 10px 24px; font-size: 14px;")
            install_btn.clicked.connect(lambda: self._install_from_details(dialog, full_plugin))
            btn_layout.addWidget(install_btn)
            
            layout.addLayout(btn_layout)
            
            dialog.exec()
        
        def _install_from_details(self, dialog, plugin: dict):
            """Install plugin from the details dialog."""
            dialog.accept()
            self._download_store_plugin(plugin)
        
        def _show_screenshots_dialog(self, plugin_name: str, plugin_id: str, screenshots: list):
            """Show dialog with all plugin screenshots."""
            from PyQt6.QtGui import QPixmap
            from PyQt6.QtNetwork import QNetworkAccessManager, QNetworkRequest
            from PyQt6.QtCore import QUrl
            
            dialog = QDialog(self)
            dialog.setWindowTitle(f"🖼️ Screenshots - {plugin_name}")
            dialog.setMinimumSize(800, 600)
            
            layout = QVBoxLayout(dialog)
            
            # Header
            header = QLabel(f"<b>Screenshots for {plugin_name}</b> ({len(screenshots)} image(s))")
            header.setStyleSheet("font-size: 14px; padding: 10px;")
            layout.addWidget(header)
            
            # Scroll area for screenshots
            scroll = QScrollArea()
            scroll.setWidgetResizable(True)
            scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            
            scroll_content = QWidget()
            scroll_layout = QVBoxLayout(scroll_content)
            scroll_layout.setSpacing(20)
            
            # Status label for loading
            self._screenshot_status = QLabel("Loading screenshots...")
            self._screenshot_status.setAlignment(Qt.AlignmentFlag.AlignCenter)
            scroll_layout.addWidget(self._screenshot_status)
            
            # Store references for loading
            self._screenshot_labels = []
            self._screenshot_manager = QNetworkAccessManager()
            
            # Base URL for screenshots
            base_url = plugin_store_api.base_url
            
            # Load each screenshot
            for i, ss_filename in enumerate(screenshots):
                # Container for each screenshot
                ss_container = QWidget()
                ss_container_layout = QVBoxLayout(ss_container)
                ss_container_layout.setContentsMargins(0, 0, 0, 0)
                
                # Screenshot label (placeholder)
                ss_label = QLabel(f"⏳ Loading screenshot {i+1}...")
                ss_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                ss_label.setMinimumHeight(300)
                ss_label.setStyleSheet("background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 10px;")
                ss_container_layout.addWidget(ss_label)
                
                # Caption
                caption = QLabel(f"Screenshot {i+1} of {len(screenshots)}")
                caption.setAlignment(Qt.AlignmentFlag.AlignCenter)
                caption.setStyleSheet("color: #888; font-size: 11px;")
                ss_container_layout.addWidget(caption)
                
                scroll_layout.addWidget(ss_container)
                self._screenshot_labels.append(ss_label)
                
                # Construct URL - handle different formats
                if ss_filename.startswith('http://') or ss_filename.startswith('https://'):
                    # Already a full URL
                    ss_url = ss_filename
                elif ss_filename.startswith('/screenshots/'):
                    # Path with leading slash
                    ss_url = f"{base_url}{ss_filename}"
                elif ss_filename.startswith('screenshots/'):
                    # Path without leading slash
                    ss_url = f"{base_url}/{ss_filename}"
                else:
                    # Just filename
                    ss_url = f"{base_url}/screenshots/{ss_filename}"
                
                logger.debug(f"Loading screenshot from: {ss_url}")
                self._load_screenshot_async(ss_label, ss_url, i)
            
            scroll_layout.addStretch()
            scroll.setWidget(scroll_content)
            layout.addWidget(scroll)
            
            # Update status
            self._screenshot_status.setText(f"Loaded {len(screenshots)} screenshot(s)")
            
            # Close button
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(dialog.accept)
            layout.addWidget(close_btn)
            
            dialog.exec()
        
        def _load_screenshot_async(self, label, url: str, index: int):
            """Load a screenshot image asynchronously using a worker thread with signals."""
            import urllib.request
            import urllib.error
            from PyQt6.QtGui import QPixmap
            from PyQt6.QtCore import QByteArray, QObject, pyqtSignal
            
            # Create a simple signal emitter for thread-safe UI updates
            class ScreenshotSignal(QObject):
                finished = pyqtSignal(bytes, object, str, int)  # data, label, url, index
                error = pyqtSignal(str, object)  # error_msg, label
            
            signal_obj = ScreenshotSignal()
            
            def on_finished(data, lbl, url, idx):
                try:
                    pixmap = QPixmap()
                    pixmap.loadFromData(QByteArray(data))
                    
                    if not pixmap.isNull():
                        if pixmap.width() > 750:
                            pixmap = pixmap.scaledToWidth(750, Qt.TransformationMode.SmoothTransformation)
                        lbl.setPixmap(pixmap)
                        lbl.setMinimumHeight(pixmap.height())
                        logger.debug(f"[SCREENSHOT] Successfully displayed screenshot {idx+1}")
                    else:
                        lbl.setText(f"❌ Failed to decode image {idx+1}\nURL: {url[:60]}...")
                except RuntimeError:
                    pass  # Widget was deleted
            
            def on_error(error_msg, lbl):
                try:
                    lbl.setText(error_msg)
                except RuntimeError:
                    pass  # Widget was deleted
            
            signal_obj.finished.connect(on_finished)
            signal_obj.error.connect(on_error)
            
            # Keep reference to prevent garbage collection
            label.setProperty('_signal_obj', signal_obj)
            
            def load_image():
                try:
                    headers = {'User-Agent': 'ImageAnarchy/' + APP_VERSION}
                    headers.update(get_cf_headers())
                    logger.info(f"[SCREENSHOT] Loading screenshot {index+1} from: {url}")
                    req = urllib.request.Request(url, headers=headers)
                    with urllib.request.urlopen(req, timeout=15) as response:
                        data = response.read()
                        logger.info(f"[SCREENSHOT] Downloaded {len(data)} bytes for screenshot {index+1}")
                        signal_obj.finished.emit(data, label, url, index)
                        
                except urllib.error.HTTPError as e:
                    logger.error(f"[SCREENSHOT] HTTP Error {e.code} loading screenshot {index+1}: {url}")
                    signal_obj.error.emit(f"❌ HTTP {e.code}: {url[:50]}...", label)
                except Exception as e:
                    error_msg = str(e)[:100]
                    logger.error(f"[SCREENSHOT] Error loading screenshot {index+1}: {error_msg} - URL: {url}")
                    signal_obj.error.emit(f"❌ Error: {str(e)[:40]}\nURL: {url[:50]}...", label)
            
            import threading
            thread = threading.Thread(target=load_image, daemon=True)
            thread.start()

        def _show_rate_dialog(self, plugin_id: str, plugin_name: str):
            """Show dialog to rate a plugin."""
            if not plugin_store_api.is_logged_in():
                QMessageBox.information(
                    self,
                    "Login Required",
                    "You need to be logged in to rate plugins.\n\n"
                    "Click 'Login' in the Plugin Store to create an account or sign in."
                )
                return
            
            dialog = QDialog(self)
            dialog.setWindowTitle(f"Rate {plugin_name}")
            dialog.setFixedWidth(400)
            
            layout = QVBoxLayout(dialog)
            
            # Star rating selector
            rating_label = QLabel("Select your rating:")
            layout.addWidget(rating_label)
            
            stars_layout = QHBoxLayout()
            star_buttons = []
            selected_rating = [0]  # Using list to allow modification in nested function
            
            def set_rating(rating):
                selected_rating[0] = rating
                for i, btn in enumerate(star_buttons):
                    if i < rating:
                        btn.setText("⭐")
                        btn.setStyleSheet("font-size: 28px; border: none; background: transparent;")
                    else:
                        btn.setText("☆")
                        btn.setStyleSheet("font-size: 28px; border: none; background: transparent; color: #666;")
            
            for i in range(5):
                star_btn = QPushButton("☆")
                star_btn.setStyleSheet("font-size: 28px; border: none; background: transparent; color: #666;")
                star_btn.setFixedSize(40, 40)
                star_btn.setCursor(Qt.CursorShape.PointingHandCursor)
                star_btn.clicked.connect(lambda checked, r=i+1: set_rating(r))
                star_buttons.append(star_btn)
                stars_layout.addWidget(star_btn)
            
            stars_layout.addStretch()
            layout.addLayout(stars_layout)
            
            # Comment
            comment_label = QLabel("Add a comment (optional):")
            layout.addWidget(comment_label)
            
            comment_edit = QTextEdit()
            comment_edit.setMaximumHeight(80)
            comment_edit.setPlaceholderText("Share your experience with this plugin...")
            layout.addWidget(comment_edit)
            
            # Status
            status_label = QLabel("")
            status_label.setStyleSheet("color: #f44336;")
            layout.addWidget(status_label)
            
            # Buttons
            btn_layout = QHBoxLayout()
            btn_layout.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            btn_layout.addWidget(cancel_btn)
            
            def submit_rating():
                if selected_rating[0] == 0:
                    status_label.setText("Please select a rating")
                    return
                
                comment = comment_edit.toPlainText().strip()
                result = plugin_store_api.submit_rating(plugin_id, selected_rating[0], comment)
                
                if 'error' in result:
                    status_label.setText(result['error'])
                else:
                    dialog.accept()
                    QMessageBox.information(self, "Success", "Thank you for your rating!")
            
            submit_btn = QPushButton("⭐ Submit Rating")
            submit_btn.setStyleSheet("background-color: #4CAF50;")
            submit_btn.clicked.connect(submit_rating)
            btn_layout.addWidget(submit_btn)
            
            layout.addLayout(btn_layout)
            dialog.exec()
        
        def _show_feedback_dialog(self, plugin_id: str, plugin_name: str):
            """Show dialog to leave feedback on a plugin."""
            if not plugin_store_api.is_logged_in():
                QMessageBox.information(
                    self,
                    "Login Required",
                    "You need to be logged in to leave feedback.\n\n"
                    "Click 'Login' in the Plugin Store to create an account or sign in."
                )
                return
            
            dialog = QDialog(self)
            dialog.setWindowTitle(f"Feedback for {plugin_name}")
            dialog.setFixedWidth(450)
            
            layout = QVBoxLayout(dialog)
            
            info_label = QLabel("Share your thoughts with the developer:")
            layout.addWidget(info_label)
            
            feedback_edit = QTextEdit()
            feedback_edit.setMinimumHeight(120)
            feedback_edit.setPlaceholderText(
                "Share your experience, suggestions, or feature requests...\n\n"
                "Your feedback helps developers improve their plugins!"
            )
            layout.addWidget(feedback_edit)
            
            char_count = QLabel("0/2000 characters")
            char_count.setStyleSheet("color: #888; font-size: 10px;")
            feedback_edit.textChanged.connect(
                lambda: char_count.setText(f"{len(feedback_edit.toPlainText())}/2000 characters")
            )
            layout.addWidget(char_count)
            
            # Status
            status_label = QLabel("")
            status_label.setStyleSheet("color: #f44336;")
            layout.addWidget(status_label)
            
            # Buttons
            btn_layout = QHBoxLayout()
            btn_layout.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            btn_layout.addWidget(cancel_btn)
            
            def submit_feedback():
                content = feedback_edit.toPlainText().strip()
                if len(content) < 10:
                    status_label.setText("Feedback must be at least 10 characters")
                    return
                if len(content) > 2000:
                    status_label.setText("Feedback must be under 2000 characters")
                    return
                
                result = plugin_store_api.submit_feedback(plugin_id, content)
                
                if 'error' in result:
                    status_label.setText(result['error'])
                else:
                    dialog.accept()
                    QMessageBox.information(self, "Success", "Thank you for your feedback!")
            
            submit_btn = QPushButton("💬 Submit Feedback")
            submit_btn.setStyleSheet("background-color: #4CAF50;")
            submit_btn.clicked.connect(submit_feedback)
            btn_layout.addWidget(submit_btn)
            
            layout.addLayout(btn_layout)
            dialog.exec()
        
        def _show_bug_report_dialog(self, plugin_id: str, plugin_name: str):
            """Show dialog to report a bug (no login required)."""
            dialog = QDialog(self)
            dialog.setWindowTitle(f"Report Bug in {plugin_name}")
            dialog.setFixedWidth(500)
            
            layout = QVBoxLayout(dialog)
            
            info_label = QLabel(
                "🐛 <b>Report a Bug</b><br>"
                "<span style='color:#888;'>No login required. The developer will review your report.</span>"
            )
            info_label.setTextFormat(Qt.TextFormat.RichText)
            layout.addWidget(info_label)
            
            # Name (optional)
            name_layout = QHBoxLayout()
            name_label = QLabel("Your name (optional):")
            name_layout.addWidget(name_label)
            name_edit = QLineEdit()
            name_edit.setPlaceholderText("Anonymous")
            name_layout.addWidget(name_edit)
            layout.addLayout(name_layout)
            
            # Email (optional)
            email_layout = QHBoxLayout()
            email_label = QLabel("Email (optional):")
            email_layout.addWidget(email_label)
            email_edit = QLineEdit()
            email_edit.setPlaceholderText("For follow-up if needed")
            email_layout.addWidget(email_edit)
            layout.addLayout(email_layout)
            
            # Bug description
            desc_label = QLabel("Describe the bug:")
            layout.addWidget(desc_label)
            
            bug_edit = QTextEdit()
            bug_edit.setMinimumHeight(150)
            bug_edit.setPlaceholderText(
                "Please describe:\n"
                "1. What you expected to happen\n"
                "2. What actually happened\n"
                "3. Steps to reproduce the bug\n\n"
                "Include any error messages if applicable."
            )
            layout.addWidget(bug_edit)
            
            char_count = QLabel("0/5000 characters (min 20)")
            char_count.setStyleSheet("color: #888; font-size: 10px;")
            bug_edit.textChanged.connect(
                lambda: char_count.setText(f"{len(bug_edit.toPlainText())}/5000 characters (min 20)")
            )
            layout.addWidget(char_count)
            
            # Simple captcha
            captcha_layout = QHBoxLayout()
            
            # Generate simple math captcha
            import random
            a = random.randint(1, 10)
            b = random.randint(1, 10)
            captcha_answer = a + b
            
            captcha_label = QLabel(f"🤖 Captcha: What is {a} + {b}?")
            captcha_layout.addWidget(captcha_label)
            
            captcha_edit = QLineEdit()
            captcha_edit.setFixedWidth(60)
            captcha_edit.setPlaceholderText("?")
            captcha_layout.addWidget(captcha_edit)
            captcha_layout.addStretch()
            layout.addLayout(captcha_layout)
            
            # Status
            status_label = QLabel("")
            status_label.setWordWrap(True)
            status_label.setStyleSheet("color: #f44336;")
            layout.addWidget(status_label)
            
            # Buttons
            btn_layout = QHBoxLayout()
            btn_layout.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            btn_layout.addWidget(cancel_btn)
            
            def submit_bug_report():
                content = bug_edit.toPlainText().strip()
                if len(content) < 20:
                    status_label.setText("Bug report must be at least 20 characters")
                    return
                if len(content) > 5000:
                    status_label.setText("Bug report must be under 5000 characters")
                    return
                
                # Verify captcha
                try:
                    user_answer = int(captcha_edit.text().strip())
                    if user_answer != captcha_answer:
                        status_label.setText("Incorrect captcha answer. Please try again.")
                        return
                except ValueError:
                    status_label.setText("Please enter a valid number for the captcha")
                    return
                
                email = email_edit.text().strip()
                if email and '@' not in email:
                    status_label.setText("Please enter a valid email or leave it blank")
                    return
                
                name = name_edit.text().strip() or "Anonymous"
                
                result = plugin_store_api.submit_bug_report(plugin_id, content, email, name, str(user_answer))
                
                if 'error' in result:
                    status_label.setText(result['error'])
                else:
                    dialog.accept()
                    QMessageBox.information(
                        self, 
                        "Bug Report Submitted",
                        "Thank you for reporting this bug!\n\n"
                        "The developer will review your report and may follow up if you provided an email."
                    )
            
            submit_btn = QPushButton("🐛 Submit Bug Report")
            submit_btn.setStyleSheet("background-color: #ff9800;")
            submit_btn.clicked.connect(submit_bug_report)
            btn_layout.addWidget(submit_btn)
            
            layout.addLayout(btn_layout)
            dialog.exec()
        
        def _search_store(self):
            """Search the plugin store."""
            query = self.store_search.text().strip()
            if not query:
                self._refresh_store()
                return
            
            self.store_status.setText(f"Searching for '{query}'...")
            QApplication.processEvents()
            
            plugins = plugin_store_api.get_plugins(search=query)
            
            if not plugins:
                self.store_status.setText(f"No plugins found for '{query}'")
                self._display_store_plugins([])
                return
            
            self.store_status.setText(f"Found {len(plugins)} plugins matching '{query}'")
            self._display_store_plugins(plugins)
        
        def _filter_store_category(self, category: str):
            """Filter store by category."""
            if category == "All":
                self._refresh_store()
                return
            
            if hasattr(self, '_store_plugins'):
                filtered = [p for p in self._store_plugins if p.get('category', '').lower() == category.lower()]
                self._display_store_plugins(filtered)
                self.store_status.setText(f"Showing {len(filtered)} plugins in '{category}'")
        
        def _show_anonymous_terms_dialog(self, plugin_name: str) -> bool:
            """Show terms acceptance dialog for anonymous downloads.
            
            Returns True if user accepts, False otherwise.
            """
            dialog = QDialog(self)
            dialog.setWindowTitle("🏴 Image Anarchy - Terms of Use")
            dialog.setMinimumSize(600, 550)
            dialog.setMaximumSize(800, 700)
            
            layout = QVBoxLayout(dialog)
            layout.setSpacing(15)
            
            # Header
            header = QLabel(f"<h2 style='color: #ff6b6b; text-align: center;'>🏴 Before You Download</h2>")
            header.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(header)
            
            # Intro text
            intro = QLabel(
                f"<p style='font-size: 13px;'>You're about to download <b>{plugin_name}</b> as an anonymous user.</p>"
                "<p style='font-size: 12px; color: #888;'>Please review and accept our terms to continue.</p>"
            )
            intro.setWordWrap(True)
            intro.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(intro)
            
            # Scrollable terms content
            scroll = QScrollArea()
            scroll.setWidgetResizable(True)
            scroll.setMinimumHeight(300)
            
            terms_widget = QWidget()
            terms_layout = QVBoxLayout(terms_widget)
            terms_layout.setContentsMargins(15, 15, 15, 15)
            
            terms_html = """
            <div style="font-family: Arial, sans-serif; line-height: 1.6; color: #e0e0e0;">
            
            <div style="background: #1a1a2e; border: 1px solid #444; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
            <h3 style="color: #00ff88; margin-top: 0;">🎯 Our Mission</h3>
            <p>Image Anarchy empowers <b>true device ownership</b>. When you buy a device, you should have complete control over it.</p>
            <p style="color: #00ff88;"><b>You bought it. You own it.</b></p>
            </div>
            
            <div style="background: #1a1a2e; border: 2px solid #00ff88; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
            <h3 style="color: #00ff88; margin-top: 0;">✅ By Downloading, I Agree:</h3>
            <ul style="margin: 5px 0; padding-left: 20px;">
            <li><b>Only use these tools on devices I legally own</b></li>
            <li><b>Comply with all applicable laws</b> in my jurisdiction</li>
            <li><b>NEVER use these tools on stolen devices</b></li>
            <li><b>Not use these tools for fraud</b> of any kind</li>
            <li><b>Accept full responsibility</b> for my actions</li>
            </ul>
            </div>
            
            <div style="background: #1a1a2e; border: 2px solid #ff6b6b; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
            <h3 style="color: #ff6b6b; margin-top: 0;">⚠️ IMEI Warning</h3>
            <p><b>IMEI modification is illegal in many countries</b> including the US, UK, Australia, Canada, and EU.</p>
            <p>Image Anarchy provides IMEI tools for <b>legitimate purposes only</b>: restoring corrupted IMEI on YOUR OWN device, repairing after failed flash.</p>
            <p style="color: #ff6b6b;"><b>Using these tools on stolen devices or for fraud is STRICTLY PROHIBITED.</b></p>
            </div>
            
            <div style="background: #2a2a4a; border: 1px solid #666; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
            <h3 style="color: #00d4ff; margin-top: 0;">📜 The Promise</h3>
            <p style="font-style: italic; color: #ccc; margin: 5px 0;">
            "I am here to exercise control over devices I legally own. I will not use these tools to steal, 
            defraud, or harm others. I understand that device modification carries risks and responsibilities, 
            and I accept both."
            </p>
            </div>
            
            <p style="text-align: center; color: #888; font-size: 11px;">
            Full policy: <a href="https://imageanarchy.com/policy" style="color: #00d4ff;">imageanarchy.com/policy</a>
            </p>
            </div>
            """
            
            terms_label = QLabel(terms_html)
            terms_label.setWordWrap(True)
            terms_label.setOpenExternalLinks(True)
            terms_label.setTextFormat(Qt.TextFormat.RichText)
            terms_layout.addWidget(terms_label)
            
            scroll.setWidget(terms_widget)
            scroll.setStyleSheet("QScrollArea { border: 1px solid #333; border-radius: 8px; background: #0d0d1a; }")
            layout.addWidget(scroll)
            
            # Checkbox
            checkbox = QCheckBox("I have read and agree to the Image Anarchy Terms of Use")
            checkbox.setStyleSheet("QCheckBox { font-size: 13px; padding: 10px; } QCheckBox::indicator { width: 18px; height: 18px; }")
            layout.addWidget(checkbox)
            
            # Buttons
            btn_layout = QHBoxLayout()
            btn_layout.setSpacing(15)
            
            # Login suggestion
            login_label = QLabel("<a href='#' style='color: #00d4ff;'>Login for faster downloads →</a>")
            login_label.setOpenExternalLinks(False)
            login_label.linkActivated.connect(lambda: self._prompt_login_from_terms(dialog))
            btn_layout.addWidget(login_label)
            
            btn_layout.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.setMinimumWidth(100)
            cancel_btn.clicked.connect(dialog.reject)
            btn_layout.addWidget(cancel_btn)
            
            accept_btn = QPushButton("✅ I Agree - Continue Download")
            accept_btn.setMinimumWidth(200)
            accept_btn.setEnabled(False)
            accept_btn.setStyleSheet("QPushButton:disabled { background-color: #333; color: #666; }")
            accept_btn.clicked.connect(dialog.accept)
            btn_layout.addWidget(accept_btn)
            
            # Enable accept button when checkbox is checked
            checkbox.stateChanged.connect(lambda state: accept_btn.setEnabled(state == Qt.CheckState.Checked.value))
            
            layout.addLayout(btn_layout)
            
            result = dialog.exec()
            return result == QDialog.DialogCode.Accepted
        
        def _prompt_login_from_terms(self, terms_dialog: QDialog):
            """Show login prompt from terms dialog."""
            terms_dialog.reject()  # Close terms dialog
            # Switch to account tab if it exists, or show login dialog
            if hasattr(self, 'store_tabs'):
                # Find and switch to account tab
                for i in range(self.store_tabs.count()):
                    if 'account' in self.store_tabs.tabText(i).lower():
                        self.store_tabs.setCurrentIndex(i)
                        break
            QMessageBox.information(
                self,
                "Login",
                "Please log in or create an account to download without the terms prompt.\n\n"
                "Logged-in users only need to accept terms once during registration."
            )

        def _download_store_plugin(self, plugin: dict):
            """Download and install a plugin from the store."""
            plugin_id = plugin.get('id')
            plugin_name = plugin.get('name', plugin_id)
            
            # Check if anonymous download - require terms acceptance first
            if not plugin_store_api.is_logged_in():
                if not self._show_anonymous_terms_dialog(plugin_name):
                    return  # User declined terms
            
            reply = QMessageBox.question(
                self,
                "Install Plugin",
                f"Download and install '{plugin_name}'?\n\n"
                f"Author: {plugin.get('author_name', 'Unknown')}\n"
                f"Version: {plugin.get('version', '1.0')}",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                return
            
            # Download to temp file
            import tempfile
            temp_dir = tempfile.mkdtemp()
            zip_path = os.path.join(temp_dir, f"{plugin_id}.zip")
            
            self.store_status.setText(f"Downloading {plugin_name}...")
            QApplication.processEvents()
            
            success, result = plugin_store_api.download_plugin(plugin_id, zip_path)
            
            if not success:
                QMessageBox.critical(self, "Download Failed", f"Failed to download plugin:\n{result}")
                self.store_status.setText("Download failed")
                return
            
            # Extract to plugins folder
            try:
                import zipfile
                plugins_dir = plugin_manager._get_plugins_dir()
                
                # Create plugin subdirectory using plugin ID
                plugin_install_dir = os.path.join(plugins_dir, plugin_id)
                os.makedirs(plugin_install_dir, exist_ok=True)
                
                self.store_status.setText(f"Extracting {plugin_name}...")
                QApplication.processEvents()
                
                with zipfile.ZipFile(zip_path, 'r') as zf:
                    # Check if the zip has a root folder or files at root
                    namelist = zf.namelist()
                    
                    # Check if all files are in a subdirectory already
                    has_root_folder = False
                    if namelist:
                        first_part = namelist[0].split('/')[0]
                        has_root_folder = all(n.startswith(first_part + '/') or n == first_part for n in namelist)
                    
                    if has_root_folder:
                        # Extract and move contents from the root folder
                        zf.extractall(plugins_dir)
                        # The extracted folder might have a different name, rename if needed
                        extracted_folder = os.path.join(plugins_dir, first_part)
                        if extracted_folder != plugin_install_dir and os.path.exists(extracted_folder):
                            # Remove target if exists, then rename
                            if os.path.exists(plugin_install_dir):
                                import shutil
                                shutil.rmtree(plugin_install_dir)
                            os.rename(extracted_folder, plugin_install_dir)
                    else:
                        # Files are at root level, extract to plugin subdirectory
                        zf.extractall(plugin_install_dir)
                
                # Clean up temp file
                os.remove(zip_path)
                os.rmdir(temp_dir)
                
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Extraction Failed",
                    f"Failed to extract plugin:\n{str(e)}"
                )
                self.store_status.setText("Installation failed")
                return
            
            # Run plugin setup (pip install, git clone, binary downloads, etc.)
            self.store_status.setText(f"Setting up {plugin_name}...")
            QApplication.processEvents()
            
            # Show progress dialog for setup
            from PyQt6.QtWidgets import QProgressDialog
            progress_dialog = QProgressDialog(
                f"Setting up {plugin_name}...",
                "Cancel",
                0, 100,
                self
            )
            progress_dialog.setWindowTitle("Plugin Setup")
            progress_dialog.setWindowModality(Qt.WindowModality.WindowModal)
            progress_dialog.setMinimumDuration(0)
            progress_dialog.setValue(0)
            
            setup_errors = []
            
            def setup_progress(step_name: str, status: str, progress: int):
                if progress_dialog.wasCanceled():
                    return
                progress_dialog.setLabelText(f"{step_name}\n{status}")
                progress_dialog.setValue(progress)
                QApplication.processEvents()
            
            try:
                success, message = plugin_manager.setup_plugin_dependencies(plugin_id, setup_progress)
                progress_dialog.close()
                
                if not success:
                    setup_errors.append(message)
            except Exception as e:
                progress_dialog.close()
                setup_errors.append(str(e))
            
            # Show result
            if setup_errors:
                QMessageBox.warning(
                    self,
                    "Plugin Installed with Warnings",
                    f"'{plugin_name}' was installed but some setup steps had issues:\n\n"
                    f"{chr(10).join(setup_errors)}\n\n"
                    "The plugin may still work, or you can try setup again from the plugin."
                )
            else:
                QMessageBox.information(
                    self,
                    "Plugin Installed",
                    f"'{plugin_name}' has been installed and configured successfully!\n\n"
                    "Go to the Installed tab to use it."
                )
            
            self.store_status.setText(f"Installed {plugin_name}")
            
            # Refresh installed plugins
            self._load_plugins()
        
        def _show_login_dialog(self):
            """Show login/register dialog."""
            dialog = QDialog(self)
            dialog.setWindowTitle("Plugin Store Login")
            dialog.setMinimumWidth(350)
            
            layout = QVBoxLayout(dialog)
            
            # Tab for Login / Register
            tabs = QTabWidget()
            
            # Login tab
            login_widget = QWidget()
            login_layout = QFormLayout(login_widget)
            
            login_user = QLineEdit()
            login_user.setPlaceholderText("Username")
            login_layout.addRow("Username:", login_user)
            
            login_pass = QLineEdit()
            login_pass.setPlaceholderText("Password")
            login_pass.setEchoMode(QLineEdit.EchoMode.Password)
            login_layout.addRow("Password:", login_pass)
            
            login_btn = QPushButton("Login")
            login_layout.addRow(login_btn)
            
            login_status = QLabel("")
            login_status.setStyleSheet("color: #f44336;")
            login_layout.addRow(login_status)
            
            def do_login():
                username = login_user.text().strip()
                password = login_pass.text()
                
                if not username or not password:
                    login_status.setText("Please enter username and password")
                    return
                
                login_status.setText("Logging in...")
                login_status.setStyleSheet("color: #888;")
                QApplication.processEvents()
                
                result = plugin_store_api.login(username, password)
                
                if 'error' in result:
                    login_status.setText(result['error'])
                    login_status.setStyleSheet("color: #f44336;")
                else:
                    dialog.accept()
                    self._update_auth_ui()
                    QMessageBox.information(self, "Login Successful", f"Welcome, {username}!")
            
            login_btn.clicked.connect(do_login)
            login_pass.returnPressed.connect(do_login)
            
            tabs.addTab(login_widget, "Login")
            
            # Register tab
            reg_widget = QWidget()
            reg_layout = QFormLayout(reg_widget)
            
            reg_user = QLineEdit()
            reg_user.setPlaceholderText("Choose a username")
            reg_layout.addRow("Username:", reg_user)
            
            reg_email = QLineEdit()
            reg_email.setPlaceholderText("your@email.com")
            reg_layout.addRow("Email:", reg_email)
            
            reg_pass = QLineEdit()
            reg_pass.setPlaceholderText("Min 6 characters")
            reg_pass.setEchoMode(QLineEdit.EchoMode.Password)
            reg_layout.addRow("Password:", reg_pass)
            
            reg_pass2 = QLineEdit()
            reg_pass2.setPlaceholderText("Confirm password")
            reg_pass2.setEchoMode(QLineEdit.EchoMode.Password)
            reg_layout.addRow("Confirm:", reg_pass2)
            
            reg_btn = QPushButton("Create Account")
            reg_layout.addRow(reg_btn)
            
            reg_status = QLabel("")
            reg_status.setStyleSheet("color: #f44336;")
            reg_status.setWordWrap(True)
            reg_layout.addRow(reg_status)
            
            def do_register():
                username = reg_user.text().strip()
                email = reg_email.text().strip()
                password = reg_pass.text()
                password2 = reg_pass2.text()
                
                if not username or not email or not password:
                    reg_status.setText("Please fill in all fields")
                    return
                
                if password != password2:
                    reg_status.setText("Passwords don't match")
                    return
                
                if len(password) < 6:
                    reg_status.setText("Password must be at least 6 characters")
                    return
                
                reg_status.setText("Creating account...")
                reg_status.setStyleSheet("color: #888;")
                QApplication.processEvents()
                
                result = plugin_store_api.register(username, email, password)
                
                if 'error' in result:
                    reg_status.setText(result['error'])
                    reg_status.setStyleSheet("color: #f44336;")
                else:
                    dialog.accept()
                    self._update_auth_ui()
                    QMessageBox.information(
                        self,
                        "Account Created",
                        f"Welcome, {username}!\n\n"
                        "You can now upload plugins to the store."
                    )
            
            reg_btn.clicked.connect(do_register)
            
            tabs.addTab(reg_widget, "Register")
            
            layout.addWidget(tabs)
            
            # Note about why register
            note = QLabel(
                "💡 Registration is only required for plugin developers who want to upload plugins.\n"
                "Browsing and downloading plugins is free for everyone!"
            )
            note.setStyleSheet("color: #888; font-style: italic; font-size: 11px;")
            note.setWordWrap(True)
            layout.addWidget(note)
            
            dialog.exec()
        
        def _show_user_menu(self):
            """Show user menu with logout option."""
            menu = QMenu(self)
            
            user = plugin_store_api.user or {}
            username = user.get('username', 'User')
            is_admin = user.get('is_admin', False)
            
            # User info
            if is_admin:
                user_action = menu.addAction(f"👤 {username} (Admin)")
            else:
                user_action = menu.addAction(f"👤 Logged in as {username}")
            user_action.setEnabled(False)
            
            menu.addSeparator()
            
            # Admin panel (only for admins)
            if is_admin:
                admin_action = menu.addAction("⚙️ Admin Panel")
                admin_action.triggered.connect(self._show_admin_panel)
                menu.addSeparator()
            
            # Upload plugin
            upload_action = menu.addAction("📤 Upload Plugin")
            upload_action.triggered.connect(self._show_upload_dialog)
            
            menu.addSeparator()
            
            # Logout
            logout_action = menu.addAction("🚪 Logout")
            logout_action.triggered.connect(self._logout)
            
            # Show menu at button
            menu.exec(self.user_menu_btn.mapToGlobal(self.user_menu_btn.rect().bottomLeft()))
        
        def _logout(self):
            """Logout from plugin store."""
            plugin_store_api.logout()
            self._update_auth_ui()
            QMessageBox.information(self, "Logged Out", "You have been logged out.")
        
        def _show_admin_panel(self):
            """Show admin panel for managing pending plugins."""
            dialog = QDialog(self)
            dialog.setWindowTitle("⚙️ Plugin Store Admin Panel")
            dialog.setMinimumWidth(800)
            dialog.setMinimumHeight(600)
            
            layout = QVBoxLayout(dialog)
            
            # Header
            header = QLabel("⚙️ <b>Admin Panel</b> - Review and manage plugin submissions")
            header.setTextFormat(Qt.TextFormat.RichText)
            header.setStyleSheet("font-size: 16px; padding: 10px; background: #ff9800; color: #1a1a1a; border-radius: 6px;")
            layout.addWidget(header)
            
            # Tabs
            tabs = QTabWidget()
            
            # Pending plugins tab
            pending_widget = QWidget()
            pending_layout = QVBoxLayout(pending_widget)
            
            pending_label = QLabel("📋 Pending plugins awaiting review:")
            pending_label.setStyleSheet("font-weight: bold;")
            pending_layout.addWidget(pending_label)
            
            self._admin_pending_list = QListWidget()
            self._admin_pending_list.setStyleSheet("""
                QListWidget::item { padding: 10px; border-bottom: 1px solid #333; }
                QListWidget::item:selected { background: #2d4a2d; }
            """)
            pending_layout.addWidget(self._admin_pending_list)
            
            # Action buttons
            btn_layout = QHBoxLayout()
            
            refresh_btn = QPushButton("🔄 Refresh")
            refresh_btn.clicked.connect(lambda: self._load_pending_plugins(dialog))
            btn_layout.addWidget(refresh_btn)
            
            review_btn = QPushButton("🔍 Review Details")
            review_btn.setStyleSheet("background: #2196F3; padding: 8px 16px;")
            review_btn.clicked.connect(lambda: self._review_selected_plugin(dialog))
            btn_layout.addWidget(review_btn)
            
            btn_layout.addStretch()
            
            approve_btn = QPushButton("✅ Approve Selected")
            approve_btn.setStyleSheet("background: #4CAF50; padding: 8px 16px;")
            approve_btn.clicked.connect(lambda: self._approve_selected_plugin(dialog))
            btn_layout.addWidget(approve_btn)
            
            reject_btn = QPushButton("❌ Reject Selected")
            reject_btn.setStyleSheet("background: #f44336; padding: 8px 16px;")
            reject_btn.clicked.connect(lambda: self._reject_selected_plugin(dialog))
            btn_layout.addWidget(reject_btn)
            
            pending_layout.addLayout(btn_layout)
            tabs.addTab(pending_widget, "📋 Pending")
            
            # All plugins tab
            all_widget = QWidget()
            all_layout = QVBoxLayout(all_widget)
            
            all_label = QLabel("📦 All plugins in the store:")
            all_label.setStyleSheet("font-weight: bold;")
            all_layout.addWidget(all_label)
            
            self._admin_all_list = QListWidget()
            self._admin_all_list.setStyleSheet("""
                QListWidget::item { padding: 8px; border-bottom: 1px solid #333; }
            """)
            all_layout.addWidget(self._admin_all_list)
            
            all_btn_layout = QHBoxLayout()
            refresh_all_btn = QPushButton("🔄 Refresh")
            refresh_all_btn.clicked.connect(lambda: self._load_all_admin_plugins(dialog))
            all_btn_layout.addWidget(refresh_all_btn)
            
            review_all_btn = QPushButton("🔍 Review Details")
            review_all_btn.setStyleSheet("background: #2196F3; padding: 8px 16px;")
            review_all_btn.clicked.connect(lambda: self._review_all_selected_plugin(dialog))
            all_btn_layout.addWidget(review_all_btn)
            
            all_btn_layout.addStretch()
            
            delete_btn = QPushButton("🗑️ Delete Selected")
            delete_btn.setStyleSheet("background: #f44336; padding: 8px 16px;")
            delete_btn.clicked.connect(lambda: self._delete_selected_plugin(dialog))
            all_btn_layout.addWidget(delete_btn)
            
            all_layout.addLayout(all_btn_layout)
            tabs.addTab(all_widget, "📦 All Plugins")

            # App Updates tab
            updates_widget = QWidget()
            updates_layout = QVBoxLayout(updates_widget)

            updates_label = QLabel("🚀 Manage application updates:")
            updates_label.setStyleSheet("font-weight: bold;")
            updates_layout.addWidget(updates_label)

            # Publish new version section
            publish_group = QGroupBox("Publish New Version")
            publish_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 15px; }")
            publish_layout = QFormLayout(publish_group)

            self._update_version_input = QLineEdit()
            self._update_version_input.setPlaceholderText("e.g., 2.2.0")
            publish_layout.addRow("Version:", self._update_version_input)

            self._update_changelog_input = QTextEdit()
            self._update_changelog_input.setPlaceholderText("What's new in this version...")
            self._update_changelog_input.setMaximumHeight(100)
            publish_layout.addRow("Changelog:", self._update_changelog_input)

            file_layout = QHBoxLayout()
            self._update_file_path = QLineEdit()
            self._update_file_path.setPlaceholderText("Select .exe file...")
            self._update_file_path.setReadOnly(True)
            file_layout.addWidget(self._update_file_path)
            browse_btn = QPushButton("Browse...")
            browse_btn.clicked.connect(self._browse_update_file)
            file_layout.addWidget(browse_btn)
            publish_layout.addRow("Exe File:", file_layout)

            self._update_critical_checkbox = QCheckBox("Critical update (security/major bug fix)")
            publish_layout.addRow("", self._update_critical_checkbox)

            self._update_progress = QProgressBar()
            self._update_progress.setVisible(False)
            publish_layout.addRow("", self._update_progress)

            publish_btn = QPushButton("🚀 Publish Update")
            publish_btn.setStyleSheet("background: #4CAF50; padding: 10px 20px; font-weight: bold;")
            publish_btn.clicked.connect(lambda: self._publish_app_update(dialog))
            publish_layout.addRow("", publish_btn)

            updates_layout.addWidget(publish_group)

            # Published versions list
            versions_label = QLabel("📦 Published Versions:")
            versions_label.setStyleSheet("font-weight: bold; margin-top: 15px;")
            updates_layout.addWidget(versions_label)

            self._admin_versions_list = QListWidget()
            self._admin_versions_list.setStyleSheet("""
                QListWidget::item { padding: 8px; border-bottom: 1px solid #333; }
                QListWidget::item:selected { background: #2d4a6d; }
            """)
            updates_layout.addWidget(self._admin_versions_list)

            versions_btn_layout = QHBoxLayout()
            refresh_versions_btn = QPushButton("🔄 Refresh")
            refresh_versions_btn.clicked.connect(lambda: self._load_app_versions(dialog))
            versions_btn_layout.addWidget(refresh_versions_btn)

            versions_btn_layout.addStretch()

            toggle_publish_btn = QPushButton("📤 Toggle Publish")
            toggle_publish_btn.setStyleSheet("background: #2196F3; padding: 8px 16px;")
            toggle_publish_btn.clicked.connect(lambda: self._toggle_version_publish(dialog))
            versions_btn_layout.addWidget(toggle_publish_btn)

            delete_version_btn = QPushButton("🗑️ Delete Version")
            delete_version_btn.setStyleSheet("background: #f44336; padding: 8px 16px;")
            delete_version_btn.clicked.connect(lambda: self._delete_app_version(dialog))
            versions_btn_layout.addWidget(delete_version_btn)

            updates_layout.addLayout(versions_btn_layout)
            tabs.addTab(updates_widget, "🚀 App Updates")

            # Logs & Stats tab
            logs_widget = QWidget()
            logs_layout = QVBoxLayout(logs_widget)

            # Stats section
            stats_group = QGroupBox("📈 Update Statistics")
            stats_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 15px; }")
            stats_layout = QGridLayout(stats_group)

            self._stats_labels = {}
            stat_items = [
                ("checks_today", "Checks Today:", 0, 0),
                ("downloads_today", "Downloads Today:", 0, 1),
                ("unique_ips_today", "Unique IPs Today:", 0, 2),
                ("checks_week", "Checks (7 days):", 1, 0),
                ("downloads_week", "Downloads (7 days):", 1, 1),
                ("failed_week", "Failed Downloads:", 1, 2),
            ]

            for key, label_text, row, col in stat_items:
                label = QLabel(label_text)
                label.setStyleSheet("color: #888;")
                value = QLabel("--")
                value.setStyleSheet("font-weight: bold; font-size: 16px; color: #4fc3f7;")
                self._stats_labels[key] = value

                item_layout = QVBoxLayout()
                item_layout.addWidget(label)
                item_layout.addWidget(value)
                stats_layout.addLayout(item_layout, row, col)

            logs_layout.addWidget(stats_group)

            # Version distribution
            version_group = QGroupBox("📊 Version Distribution (Last 7 Days)")
            version_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 15px; }")
            version_layout = QVBoxLayout(version_group)

            self._version_dist_list = QListWidget()
            self._version_dist_list.setMaximumHeight(100)
            self._version_dist_list.setStyleSheet("QListWidget::item { padding: 4px; }")
            version_layout.addWidget(self._version_dist_list)

            logs_layout.addWidget(version_group)

            # Recent logs
            logs_label = QLabel("📋 Recent Activity Logs:")
            logs_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
            logs_layout.addWidget(logs_label)

            # Filter row
            filter_row = QHBoxLayout()
            filter_label = QLabel("Filter:")
            filter_row.addWidget(filter_label)

            self._log_filter_combo = QComboBox()
            self._log_filter_combo.addItems(["All Events", "Update Checks", "Downloads", "Errors Only"])
            self._log_filter_combo.currentTextChanged.connect(lambda: self._load_update_logs(dialog))
            filter_row.addWidget(self._log_filter_combo)

            filter_row.addStretch()

            refresh_logs_btn = QPushButton("🔄 Refresh")
            refresh_logs_btn.clicked.connect(lambda: self._load_logs_and_stats(dialog))
            filter_row.addWidget(refresh_logs_btn)

            clear_logs_btn = QPushButton("🗑️ Clear Old Logs")
            clear_logs_btn.setStyleSheet("background: #f44336;")
            clear_logs_btn.clicked.connect(lambda: self._clear_old_logs(dialog))
            filter_row.addWidget(clear_logs_btn)

            logs_layout.addLayout(filter_row)

            self._update_logs_list = QListWidget()
            self._update_logs_list.setStyleSheet("""
                QListWidget::item { padding: 6px; border-bottom: 1px solid #333; font-family: monospace; }
                QListWidget::item:selected { background: #2d4a6d; }
            """)
            logs_layout.addWidget(self._update_logs_list)

            tabs.addTab(logs_widget, "📊 Logs & Stats")

            # Security tab
            security_widget = QWidget()
            security_layout = QVBoxLayout(security_widget)

            security_label = QLabel("🔒 Security logs and scan results:")
            security_label.setStyleSheet("font-weight: bold;")
            security_layout.addWidget(security_label)

            # Security logs filter
            sec_filter_row = QHBoxLayout()
            sec_filter_label = QLabel("Event Type:")
            sec_filter_row.addWidget(sec_filter_label)

            self._security_filter_combo = QComboBox()
            self._security_filter_combo.addItems(["All Events", "SCAN_THREAT", "FILE_QUARANTINED", "UPLOAD_BLOCKED", "SCAN_CLEAN"])
            self._security_filter_combo.currentTextChanged.connect(lambda: self._load_security_logs(dialog))
            sec_filter_row.addWidget(self._security_filter_combo)

            sec_filter_row.addStretch()

            refresh_sec_btn = QPushButton("🔄 Refresh")
            refresh_sec_btn.clicked.connect(lambda: self._load_security_logs(dialog))
            sec_filter_row.addWidget(refresh_sec_btn)

            security_layout.addLayout(sec_filter_row)

            self._security_logs_list = QListWidget()
            self._security_logs_list.setStyleSheet("""
                QListWidget::item { padding: 6px; border-bottom: 1px solid #333; font-family: monospace; }
                QListWidget::item:selected { background: #2d4a6d; }
            """)
            security_layout.addWidget(self._security_logs_list)

            # Quarantine section
            quarantine_label = QLabel("🦠 Quarantined Files:")
            quarantine_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
            security_layout.addWidget(quarantine_label)

            self._quarantine_list = QListWidget()
            self._quarantine_list.setMaximumHeight(150)
            self._quarantine_list.setStyleSheet("""
                QListWidget::item { padding: 4px; border-bottom: 1px solid #333; }
                QListWidget::item:selected { background: #4d2a2d; }
            """)
            security_layout.addWidget(self._quarantine_list)

            quarantine_btn_layout = QHBoxLayout()
            refresh_quar_btn = QPushButton("🔄 Refresh")
            refresh_quar_btn.clicked.connect(lambda: self._load_quarantine_files(dialog))
            quarantine_btn_layout.addWidget(refresh_quar_btn)

            quarantine_btn_layout.addStretch()

            delete_quar_btn = QPushButton("🗑️ Delete Selected")
            delete_quar_btn.setStyleSheet("background: #f44336;")
            delete_quar_btn.clicked.connect(lambda: self._delete_quarantine_file(dialog))
            quarantine_btn_layout.addWidget(delete_quar_btn)

            security_layout.addLayout(quarantine_btn_layout)

            tabs.addTab(security_widget, "🔒 Security")

            # IP Banning tab
            ip_widget = QWidget()
            ip_layout = QVBoxLayout(ip_widget)

            ip_label = QLabel("🚫 IP Banning Management:")
            ip_label.setStyleSheet("font-weight: bold;")
            ip_layout.addWidget(ip_label)

            # Ban IP section
            ban_group = QGroupBox("Ban an IP Address")
            ban_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 15px; }")
            ban_form = QFormLayout(ban_group)

            self._ban_ip_input = QLineEdit()
            self._ban_ip_input.setPlaceholderText("e.g., 192.168.1.100")
            ban_form.addRow("IP Address:", self._ban_ip_input)

            self._ban_reason_input = QLineEdit()
            self._ban_reason_input.setPlaceholderText("Reason for ban...")
            ban_form.addRow("Reason:", self._ban_reason_input)

            self._ban_permanent_checkbox = QCheckBox("Permanent ban (no expiry)")
            ban_form.addRow("", self._ban_permanent_checkbox)

            ban_btn = QPushButton("🚫 Ban IP")
            ban_btn.setStyleSheet("background: #f44336; padding: 8px 16px;")
            ban_btn.clicked.connect(lambda: self._ban_ip_action(dialog))
            ban_form.addRow("", ban_btn)

            ip_layout.addWidget(ban_group)

            # Banned IPs list
            banned_label = QLabel("🚫 Currently Banned IPs:")
            banned_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
            ip_layout.addWidget(banned_label)

            self._banned_ips_list = QListWidget()
            self._banned_ips_list.setStyleSheet("""
                QListWidget::item { padding: 6px; border-bottom: 1px solid #333; }
                QListWidget::item:selected { background: #4d2a2d; }
            """)
            ip_layout.addWidget(self._banned_ips_list)

            banned_btn_layout = QHBoxLayout()
            refresh_banned_btn = QPushButton("🔄 Refresh")
            refresh_banned_btn.clicked.connect(lambda: self._load_banned_ips(dialog))
            banned_btn_layout.addWidget(refresh_banned_btn)

            banned_btn_layout.addStretch()

            unban_btn = QPushButton("✅ Unban Selected")
            unban_btn.setStyleSheet("background: #4CAF50; padding: 8px 16px;")
            unban_btn.clicked.connect(lambda: self._unban_ip_action(dialog))
            banned_btn_layout.addWidget(unban_btn)

            ip_layout.addLayout(banned_btn_layout)

            # Suspicious IPs list
            suspicious_label = QLabel("⚠️ Suspicious IPs (high request count):")
            suspicious_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
            ip_layout.addWidget(suspicious_label)

            self._suspicious_ips_list = QListWidget()
            self._suspicious_ips_list.setMaximumHeight(150)
            self._suspicious_ips_list.setStyleSheet("""
                QListWidget::item { padding: 4px; border-bottom: 1px solid #333; }
                QListWidget::item:selected { background: #4d3a2d; }
            """)
            ip_layout.addWidget(self._suspicious_ips_list)

            tabs.addTab(ip_widget, "🚫 IP Bans")

            # Chat Admin tab
            chat_admin_widget = QWidget()
            chat_admin_layout = QVBoxLayout(chat_admin_widget)

            chat_admin_label = QLabel("💬 Chat & Rooms Administration:")
            chat_admin_label.setStyleSheet("font-weight: bold;")
            chat_admin_layout.addWidget(chat_admin_label)

            # Chat stats section
            chat_stats_group = QGroupBox("📈 Chat Statistics")
            chat_stats_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 15px; }")
            chat_stats_layout = QGridLayout(chat_stats_group)

            self._chat_stats_labels = {}
            chat_stat_items = [
                ("total_messages", "Total Messages:", 0, 0),
                ("messages_today", "Messages Today:", 0, 1),
                ("total_rooms", "Total Rooms:", 0, 2),
                ("active_users", "Active Users (24h):", 1, 0),
                ("online_now", "Online Now:", 1, 1),
                ("total_users", "Registered Users:", 1, 2),
            ]

            for key, label_text, row, col in chat_stat_items:
                label = QLabel(label_text)
                label.setStyleSheet("color: #888;")
                value = QLabel("--")
                value.setStyleSheet("font-weight: bold; font-size: 16px; color: #4fc3f7;")
                self._chat_stats_labels[key] = value

                item_layout = QVBoxLayout()
                item_layout.addWidget(label)
                item_layout.addWidget(value)
                chat_stats_layout.addLayout(item_layout, row, col)

            chat_admin_layout.addWidget(chat_stats_group)

            # Rooms management section
            rooms_label = QLabel("🏠 Chat Rooms:")
            rooms_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
            chat_admin_layout.addWidget(rooms_label)

            self._admin_rooms_list = QListWidget()
            self._admin_rooms_list.setStyleSheet("""
                QListWidget::item { padding: 8px; border-bottom: 1px solid #333; }
                QListWidget::item:selected { background: #2d4a6d; }
            """)
            chat_admin_layout.addWidget(self._admin_rooms_list)

            rooms_btn_layout = QHBoxLayout()
            
            # Create Room button with emoji picker
            create_room_btn = QPushButton("➕ Create Room")
            create_room_btn.setStyleSheet("background: #4CAF50; padding: 8px 16px;")
            create_room_btn.clicked.connect(lambda: self._show_create_room_dialog(dialog))
            rooms_btn_layout.addWidget(create_room_btn)
            
            refresh_rooms_btn = QPushButton("🔄 Refresh")
            refresh_rooms_btn.clicked.connect(lambda: self._load_admin_chat_data(dialog))
            rooms_btn_layout.addWidget(refresh_rooms_btn)

            rooms_btn_layout.addStretch()

            view_room_btn = QPushButton("👁️ View Messages")
            view_room_btn.setStyleSheet("background: #2196F3; padding: 8px 16px;")
            view_room_btn.clicked.connect(lambda: self._view_room_messages(dialog))
            rooms_btn_layout.addWidget(view_room_btn)

            delete_room_btn = QPushButton("🗑️ Delete Room")
            delete_room_btn.setStyleSheet("background: #f44336; padding: 8px 16px;")
            delete_room_btn.clicked.connect(lambda: self._delete_admin_room(dialog))
            rooms_btn_layout.addWidget(delete_room_btn)

            chat_admin_layout.addLayout(rooms_btn_layout)

            # Users management section
            chat_users_label = QLabel("👥 Chat Users (with moderation actions):")
            chat_users_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
            chat_admin_layout.addWidget(chat_users_label)

            # Search/filter row
            user_filter_row = QHBoxLayout()
            user_filter_label = QLabel("Search:")
            user_filter_row.addWidget(user_filter_label)

            self._chat_user_search = QLineEdit()
            self._chat_user_search.setPlaceholderText("Search by username...")
            self._chat_user_search.textChanged.connect(lambda: self._filter_chat_users())
            user_filter_row.addWidget(self._chat_user_search)

            user_filter_row.addStretch()
            chat_admin_layout.addLayout(user_filter_row)

            self._admin_chat_users_list = QListWidget()
            self._admin_chat_users_list.setMaximumHeight(200)
            self._admin_chat_users_list.setStyleSheet("""
                QListWidget::item { padding: 6px; border-bottom: 1px solid #333; }
                QListWidget::item:selected { background: #2d4a6d; }
            """)
            chat_admin_layout.addWidget(self._admin_chat_users_list)

            users_btn_layout = QHBoxLayout()

            mute_user_btn = QPushButton("🔇 Mute User")
            mute_user_btn.setStyleSheet("background: #ff9800; padding: 8px 16px;")
            mute_user_btn.clicked.connect(lambda: self._admin_mute_user(dialog))
            users_btn_layout.addWidget(mute_user_btn)

            ban_user_btn = QPushButton("🚫 Ban from Chat")
            ban_user_btn.setStyleSheet("background: #f44336; padding: 8px 16px;")
            ban_user_btn.clicked.connect(lambda: self._admin_ban_chat_user(dialog))
            users_btn_layout.addWidget(ban_user_btn)

            users_btn_layout.addStretch()

            unban_user_btn = QPushButton("✅ Unban User")
            unban_user_btn.setStyleSheet("background: #4CAF50; padding: 8px 16px;")
            unban_user_btn.clicked.connect(lambda: self._admin_unban_chat_user(dialog))
            users_btn_layout.addWidget(unban_user_btn)

            chat_admin_layout.addLayout(users_btn_layout)

            # Global chat settings
            settings_group = QGroupBox("⚙️ Global Chat Settings")
            settings_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 15px; }")
            settings_layout = QFormLayout(settings_group)

            self._chat_enabled_checkbox = QCheckBox("Chat enabled")
            self._chat_enabled_checkbox.setChecked(True)
            settings_layout.addRow("", self._chat_enabled_checkbox)

            self._chat_slowmode_input = QSpinBox()
            self._chat_slowmode_input.setRange(0, 300)
            self._chat_slowmode_input.setSuffix(" seconds")
            self._chat_slowmode_input.setToolTip("0 = no slow mode")
            settings_layout.addRow("Slow Mode:", self._chat_slowmode_input)

            broadcast_layout = QHBoxLayout()
            self._chat_broadcast_input = QLineEdit()
            self._chat_broadcast_input.setPlaceholderText("System announcement message...")
            broadcast_layout.addWidget(self._chat_broadcast_input)
            broadcast_btn = QPushButton("📢 Broadcast")
            broadcast_btn.setStyleSheet("background: #ff9800;")
            broadcast_btn.clicked.connect(lambda: self._broadcast_chat_message(dialog))
            broadcast_layout.addWidget(broadcast_btn)
            settings_layout.addRow("Broadcast:", broadcast_layout)

            chat_admin_layout.addWidget(settings_group)

            tabs.addTab(chat_admin_widget, "💬 Chat Admin")

            # Forum tab with iframe
            forum_widget = QWidget()
            forum_layout = QVBoxLayout(forum_widget)
            forum_layout.setContentsMargins(0, 0, 0, 0)
            
            try:
                from PyQt6.QtWebEngineWidgets import QWebEngineView
                from PyQt6.QtCore import QUrl
                forum_webview = QWebEngineView()
                forum_webview.setUrl(QUrl("https://forum.imageanarchy.com"))
                forum_layout.addWidget(forum_webview)
            except ImportError:
                # Fallback if QtWebEngine not installed
                fallback_label = QLabel("📌 Forum: forum.imageanarchy.com\n\nQtWebEngine not installed.\nRun: pip install PyQt6-WebEngine")
                fallback_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                fallback_label.setStyleSheet("font-size: 14px; color: #888; padding: 40px;")
                
                open_browser_btn = QPushButton("🌐 Open Forum in Browser")
                open_browser_btn.setStyleSheet("padding: 15px 30px; font-size: 14px;")
                open_browser_btn.clicked.connect(lambda: __import__('webbrowser').open("https://forum.imageanarchy.com"))
                
                forum_layout.addStretch()
                forum_layout.addWidget(fallback_label)
                forum_layout.addWidget(open_browser_btn, alignment=Qt.AlignmentFlag.AlignCenter)
                forum_layout.addStretch()
            
            tabs.addTab(forum_widget, "🌐 Forum")

            # Connect tab change to load data
            def on_tab_changed(idx):
                if idx == 1:
                    self._load_all_admin_plugins(dialog)
                elif idx == 2:
                    self._load_app_versions(dialog)
                elif idx == 3:
                    self._load_logs_and_stats(dialog)
                elif idx == 4:
                    self._load_security_logs(dialog)
                    self._load_quarantine_files(dialog)
                elif idx == 5:
                    self._load_banned_ips(dialog)
                elif idx == 6:
                    self._load_admin_chat_data(dialog)
                # idx == 7 is Forum tab - no special load needed
                elif idx == 5:
                    self._load_banned_ips(dialog)
                elif idx == 6:
                    self._load_admin_chat_data(dialog)
            tabs.currentChanged.connect(on_tab_changed)

            layout.addWidget(tabs)
            
            # Status
            self._admin_status = QLabel("")
            self._admin_status.setWordWrap(True)
            layout.addWidget(self._admin_status)
            
            # Close button
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(dialog.accept)
            layout.addWidget(close_btn)
            
            # Load pending plugins
            self._load_pending_plugins(dialog)
            
            dialog.exec()
        
        def _load_pending_plugins(self, dialog):
            """Load pending plugins from server using background thread."""
            self._admin_pending_list.clear()
            self._admin_status.setText("Loading pending plugins...")
            self._admin_status.setStyleSheet("color: #888;")
            
            # Use background thread to avoid blocking UI
            self._admin_pending_thread = AdminApiThread(plugin_store_api, 'get_pending_plugins')
            
            def on_pending_loaded(result):
                if 'error' in result:
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return
                
                plugins = result.get('plugins', [])
                
                if not plugins:
                    self._admin_status.setText("🎉 No pending plugins to review!")
                    self._admin_status.setStyleSheet("color: #4CAF50;")
                    return
                
                for p in plugins:
                    item = QListWidgetItem()
                    item.setData(Qt.ItemDataRole.UserRole, p)
                    
                    status_icon = "⏳"
                    text = f"{p.get('icon', '📦')} {p.get('name', 'Unknown')} v{p.get('version', '?')}\n"
                    text += f"   by {p.get('author_name', 'Unknown')} | {p.get('category', 'other')}\n"
                    text += f"   {p.get('description', '')[:100]}..."
                    item.setText(text)
                    
                    self._admin_pending_list.addItem(item)
                
                self._admin_status.setText(f"Found {len(plugins)} pending plugin(s)")
                self._admin_status.setStyleSheet("color: #4fc3f7;")
            
            self._admin_pending_thread.finished.connect(on_pending_loaded)
            self._admin_pending_thread.start()
        
        def _load_all_admin_plugins(self, dialog):
            """Load all plugins from server using background thread."""
            self._admin_all_list.clear()
            self._admin_status.setText("Loading all plugins...")
            
            # Use background thread to avoid blocking UI
            self._admin_all_thread = AdminApiThread(plugin_store_api, 'get_all_admin_plugins')
            
            def on_all_loaded(result):
                if 'error' in result:
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return
                
                plugins = result.get('plugins', [])
                
                for p in plugins:
                    item = QListWidgetItem()
                    item.setData(Qt.ItemDataRole.UserRole, p)
                    
                    status = p.get('status', 'unknown')
                    status_icon = "✅" if status == 'approved' else "⏳" if status == 'pending' else "❌"
                    
                    text = f"{status_icon} {p.get('icon', '📦')} {p.get('name', 'Unknown')} v{p.get('version', '?')} [{status}]\n"
                    text += f"   by {p.get('author_name', 'Unknown')} | ⬇️ {p.get('downloads', 0)} downloads"
                    item.setText(text)
                    
                    self._admin_all_list.addItem(item)
                
                self._admin_status.setText(f"Found {len(plugins)} plugin(s)")
                self._admin_status.setStyleSheet("color: #4fc3f7;")
            
            self._admin_all_thread.finished.connect(on_all_loaded)
            self._admin_all_thread.start()
        
        def _approve_selected_plugin(self, dialog):
            """Approve the selected pending plugin using background thread with progress tracking."""
            item = self._admin_pending_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a plugin to approve.")
                return
            
            plugin = item.data(Qt.ItemDataRole.UserRole)
            plugin_id = plugin.get('id')
            plugin_name = plugin.get('name', 'Unknown')
            
            reply = QMessageBox.question(
                dialog,
                "Approve Plugin",
                f"Approve '{plugin_name}'?\n\nIt will become publicly visible in the store.\n\n⚠️ Note: If the plugin has external dependencies,\nvirus scanning may take several minutes.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                return
            
            # Create progress dialog
            progress_dialog = QDialog(dialog)
            progress_dialog.setWindowTitle(f"Approving {plugin_name}")
            progress_dialog.setFixedSize(450, 180)
            progress_dialog.setWindowFlag(Qt.WindowType.WindowCloseButtonHint, False)
            progress_layout = QVBoxLayout(progress_dialog)
            progress_layout.setSpacing(15)
            
            title_label = QLabel(f"🔄 Approving: {plugin_name}")
            title_label.setStyleSheet("font-size: 14px; font-weight: bold; color: #2196F3;")
            progress_layout.addWidget(title_label)
            
            progress_bar = QProgressBar()
            progress_bar.setMinimum(0)
            progress_bar.setMaximum(100)
            progress_bar.setValue(0)
            progress_bar.setTextVisible(True)
            progress_bar.setStyleSheet("""
                QProgressBar {
                    border: 2px solid #333;
                    border-radius: 5px;
                    text-align: center;
                    background-color: #1a1a2e;
                    height: 25px;
                }
                QProgressBar::chunk {
                    background-color: #4fc3f7;
                    border-radius: 3px;
                }
            """)
            progress_layout.addWidget(progress_bar)
            
            status_label = QLabel("Starting approval process...")
            status_label.setStyleSheet("color: #888; font-size: 11px;")
            status_label.setWordWrap(True)
            progress_layout.addWidget(status_label)
            
            cancel_btn = QPushButton("Close (approval will continue in background)")
            cancel_btn.setEnabled(False)
            cancel_btn.clicked.connect(progress_dialog.accept)
            progress_layout.addWidget(cancel_btn)
            
            # Store references for the timer
            self._approve_progress_dialog = progress_dialog
            self._approve_progress_bar = progress_bar
            self._approve_status_label = status_label
            self._approve_cancel_btn = cancel_btn
            self._approve_plugin_id = plugin_id
            self._approve_plugin_name = plugin_name
            self._approve_completed = False
            
            # Progress polling timer
            self._approve_progress_timer = QTimer()
            self._approve_progress_timer.setInterval(2000)  # Poll every 2 seconds
            
            def poll_progress():
                if self._approve_completed:
                    self._approve_progress_timer.stop()
                    return
                try:
                    progress = plugin_store_api.get_approve_progress(self._approve_plugin_id)
                    if progress and 'status' in progress:
                        step = progress.get('step', 'Processing...')
                        pct = progress.get('progress', 0)
                        status = progress.get('status', '')
                        
                        self._approve_progress_bar.setValue(pct)
                        self._approve_status_label.setText(step)
                        
                        if status == 'completed':
                            self._approve_progress_timer.stop()
                        elif status == 'failed':
                            self._approve_progress_timer.stop()
                            error = progress.get('error', 'Unknown error')
                            self._approve_status_label.setText(f"❌ Failed: {error}")
                            self._approve_status_label.setStyleSheet("color: #f44336; font-size: 11px;")
                except Exception:
                    pass  # Silently ignore polling errors
            
            self._approve_progress_timer.timeout.connect(poll_progress)
            self._approve_progress_timer.start()
            
            # Start approval in background thread
            self._admin_approve_thread = AdminApiThread(plugin_store_api, 'approve_plugin', plugin_id)
            
            def on_approve_finished(result):
                self._approve_completed = True
                self._approve_progress_timer.stop()
                
                if 'error' in result:
                    self._approve_progress_bar.setValue(100)
                    self._approve_status_label.setText(f"❌ Error: {result['error']}")
                    self._approve_status_label.setStyleSheet("color: #f44336; font-size: 11px;")
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                else:
                    self._approve_progress_bar.setValue(100)
                    self._approve_status_label.setText(f"✅ {plugin_name} approved successfully!")
                    self._approve_status_label.setStyleSheet("color: #4CAF50; font-size: 11px;")
                    self._admin_status.setText(f"✅ {plugin_name} approved!")
                    self._admin_status.setStyleSheet("color: #4CAF50;")
                    self._load_pending_plugins(dialog)
                    self._refresh_store()  # Refresh main store view
                
                self._approve_cancel_btn.setText("Close")
                self._approve_cancel_btn.setEnabled(True)
            
            self._admin_approve_thread.finished.connect(on_approve_finished)
            self._admin_approve_thread.start()
            
            # Show progress dialog
            progress_dialog.exec()
        
        def _reject_selected_plugin(self, dialog):
            """Reject the selected pending plugin using background thread."""
            item = self._admin_pending_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a plugin to reject.")
                return
            
            plugin = item.data(Qt.ItemDataRole.UserRole)
            plugin_id = plugin.get('id')
            plugin_name = plugin.get('name', 'Unknown')
            
            reason, ok = QInputDialog.getText(
                dialog,
                "Rejection Reason",
                f"Reason for rejecting '{plugin_name}':\n(This will be sent to the developer)"
            )
            
            if not ok:
                return
            
            self._admin_status.setText(f"⏳ Rejecting {plugin_name}...")
            self._admin_status.setStyleSheet("color: #ff9800;")
            
            # Use background thread to avoid blocking UI
            self._admin_reject_thread = AdminApiThread(plugin_store_api, 'reject_plugin', plugin_id, reason)
            
            def on_reject_finished(result):
                if 'error' in result:
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                else:
                    self._admin_status.setText(f"❌ {plugin_name} rejected")
                    self._admin_status.setStyleSheet("color: #ff9800;")
                    self._load_pending_plugins(dialog)
            
            self._admin_reject_thread.finished.connect(on_reject_finished)
            self._admin_reject_thread.start()
        
        def _delete_selected_plugin(self, dialog):
            """Delete the selected plugin using background thread."""
            item = self._admin_all_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a plugin to delete.")
                return
            
            plugin = item.data(Qt.ItemDataRole.UserRole)
            plugin_id = plugin.get('id')
            plugin_name = plugin.get('name', 'Unknown')
            
            reply = QMessageBox.warning(
                dialog,
                "Delete Plugin",
                f"⚠️ DELETE '{plugin_name}'?\n\nThis cannot be undone!",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                return
            
            self._admin_status.setText(f"⏳ Deleting {plugin_name}...")
            self._admin_status.setStyleSheet("color: #ff9800;")
            
            # Use background thread to avoid blocking UI
            self._admin_delete_thread = AdminApiThread(plugin_store_api, 'delete_plugin', plugin_id)
            
            def on_delete_finished(result):
                if 'error' in result:
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                else:
                    self._admin_status.setText(f"🗑️ {plugin_name} deleted")
                    self._admin_status.setStyleSheet("color: #ff9800;")
                    self._load_all_admin_plugins(dialog)
                    self._refresh_store()
            
            self._admin_delete_thread.finished.connect(on_delete_finished)
            self._admin_delete_thread.start()

        def _browse_update_file(self):
            """Browse for update exe file."""
            file_path, _ = QFileDialog.getOpenFileName(
                self, "Select Update File", "", "Executable (*.exe)"
            )
            if file_path:
                self._update_file_path.setText(file_path)

        def _publish_app_update(self, dialog):
            """Publish a new app version with chunked upload support."""
            version = self._update_version_input.text().strip()
            changelog = self._update_changelog_input.toPlainText().strip()
            file_path = self._update_file_path.text().strip()
            is_critical = self._update_critical_checkbox.isChecked()

            if not version or not changelog or not file_path:
                QMessageBox.warning(dialog, "Missing Fields", "Please fill in version, changelog, and select a file.")
                return

            if not os.path.exists(file_path):
                QMessageBox.warning(dialog, "File Not Found", f"File not found: {file_path}")
                return

            # Get file size for user info
            file_size = os.path.getsize(file_path)
            size_mb = file_size / (1024 * 1024)
            
            # Show progress
            self._update_progress.setVisible(True)
            self._update_progress.setValue(0)
            
            if size_mb > 45:
                chunks_needed = int((size_mb / 45) + 1)
                self._admin_status.setText(f"📤 Uploading {size_mb:.1f} MB in {chunks_needed} chunks (Cloudflare limit)...")
            else:
                self._admin_status.setText(f"📤 Uploading {size_mb:.1f} MB...")
            self._admin_status.setStyleSheet("color: #2196F3;")
            QApplication.processEvents()

            # Run upload in a background thread to not freeze UI
            class UpdateUploadThread(QThread):
                progress = pyqtSignal(int, str)
                finished = pyqtSignal(dict)
                
                def __init__(self, api, version, changelog, file_path, is_critical):
                    super().__init__()
                    self.api = api
                    self.version = version
                    self.changelog = changelog
                    self.file_path = file_path
                    self.is_critical = is_critical
                
                def run(self):
                    try:
                        # Read file
                        with open(self.file_path, 'rb') as f:
                            file_data = f.read()
                        
                        def progress_callback(pct, msg):
                            self.progress.emit(pct, msg)
                        
                        # Use the API method with progress callback
                        result = self.api.publish_app_update(
                            version=self.version,
                            changelog=self.changelog,
                            file_data=file_data,
                            filename=os.path.basename(self.file_path),
                            is_critical=self.is_critical,
                            progress_callback=progress_callback
                        )
                        self.finished.emit(result)
                    except Exception as e:
                        self.finished.emit({'error': str(e)})
            
            self._upload_thread = UpdateUploadThread(
                plugin_store_api, version, changelog, file_path, is_critical
            )
            
            def on_progress(pct, msg):
                self._update_progress.setValue(pct)
                self._admin_status.setText(f"📤 {msg}")
                QApplication.processEvents()
            
            def on_finished(result):
                self._update_progress.setVisible(False)
                
                if 'error' in result:
                    self._admin_status.setText(f"❌ Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return
                
                if result.get('success'):
                    self._admin_status.setText(f"✅ Version {version} published successfully!")
                    self._admin_status.setStyleSheet("color: #4CAF50;")
                    # Clear inputs
                    self._update_version_input.clear()
                    self._update_changelog_input.clear()
                    self._update_file_path.clear()
                    self._update_critical_checkbox.setChecked(False)
                    # Refresh list
                    self._load_app_versions(dialog)
                else:
                    self._admin_status.setText(f"❌ Upload failed: {result.get('error', 'Unknown error')}")
                    self._admin_status.setStyleSheet("color: #f44336;")
            
            self._upload_thread.progress.connect(on_progress)
            self._upload_thread.finished.connect(on_finished)
            self._upload_thread.start()

        def _load_app_versions(self, dialog):
            """Load published app versions from server."""
            self._admin_versions_list.clear()
            self._admin_status.setText("⏳ Loading versions...")
            QApplication.processEvents()

            try:
                result = plugin_store_api.get_app_versions()
                
                if 'error' in result:
                    self._admin_status.setText(f"❌ Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return

                versions = result.get('versions', [])

                for v in versions:
                    size_mb = v.get('file_size', 0) / (1024 * 1024)
                    status = "✅ Published" if v.get('published') else "📝 Draft"
                    critical = " ⚠️ CRITICAL" if v.get('is_critical') else ""

                    item = QListWidgetItem(f"v{v['version']} | {size_mb:.1f} MB | {status}{critical}")
                    item.setData(Qt.ItemDataRole.UserRole, v)

                    if v.get('is_critical'):
                        item.setForeground(QColor('#ff9800'))
                    elif not v.get('published'):
                        item.setForeground(QColor('#888888'))

                    self._admin_versions_list.addItem(item)

                self._admin_status.setText(f"📦 Found {len(versions)} version(s)")
                self._admin_status.setStyleSheet("color: #4fc3f7;")

            except Exception as e:
                self._admin_status.setText(f"❌ Failed to load versions: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")

        def _toggle_version_publish(self, dialog):
            """Toggle publish status of selected version."""
            item = self._admin_versions_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a version.")
                return

            version_data = item.data(Qt.ItemDataRole.UserRole)
            version = version_data.get('version')
            is_published = version_data.get('published', False)

            action = "unpublish" if is_published else "publish"
            if not QMessageBox.question(
                dialog, "Confirm",
                f"Are you sure you want to {action} version {version}?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            ) == QMessageBox.StandardButton.Yes:
                return

            try:
                result = plugin_store_api.toggle_version_publish(version, not is_published)
                
                if 'error' in result:
                    self._admin_status.setText(f"❌ Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return

                self._admin_status.setText(f"✅ Version {version} {'published' if not is_published else 'unpublished'}")
                self._admin_status.setStyleSheet("color: #4CAF50;")
                self._load_app_versions(dialog)

            except Exception as e:
                self._admin_status.setText(f"❌ Failed: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")

        def _delete_app_version(self, dialog):
            """Delete selected version."""
            item = self._admin_versions_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a version to delete.")
                return

            version_data = item.data(Qt.ItemDataRole.UserRole)
            version = version_data.get('version')

            if not QMessageBox.question(
                dialog, "Confirm Delete",
                f"Are you sure you want to delete version {version}?\nThis cannot be undone.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            ) == QMessageBox.StandardButton.Yes:
                return

            try:
                result = plugin_store_api.delete_app_version(version)
                
                if 'error' in result:
                    self._admin_status.setText(f"❌ Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return

                self._admin_status.setText(f"🗑️ Version {version} deleted")
                self._admin_status.setStyleSheet("color: #ff9800;")
                self._load_app_versions(dialog)

            except Exception as e:
                self._admin_status.setText(f"❌ Failed to delete: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")

        def _load_logs_and_stats(self, dialog):
            """Load update logs and statistics."""
            self._admin_status.setText("📊 Loading logs and statistics...")
            QApplication.processEvents()

            # Load stats
            self._load_update_stats(dialog)
            # Load logs
            self._load_update_logs(dialog)

        def _load_update_stats(self, dialog):
            """Load update statistics from server."""
            try:
                result = plugin_store_api.get_update_stats()
                
                if 'error' in result:
                    self._admin_status.setText(f"❌ Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return

                # Update stat labels
                today = result.get('today', {})
                week = result.get('week', {})

                self._stats_labels['checks_today'].setText(str(today.get('checks', 0)))
                self._stats_labels['downloads_today'].setText(str(today.get('downloads', 0)))
                self._stats_labels['unique_ips_today'].setText(str(today.get('unique_ips', 0)))
                self._stats_labels['checks_week'].setText(str(week.get('checks', 0)))
                self._stats_labels['downloads_week'].setText(str(week.get('downloads', 0)))
                self._stats_labels['failed_week'].setText(str(week.get('failed_downloads', 0)))

                # Color failed downloads red if > 0
                if week.get('failed_downloads', 0) > 0:
                    self._stats_labels['failed_week'].setStyleSheet("font-weight: bold; font-size: 16px; color: #f44336;")
                else:
                    self._stats_labels['failed_week'].setStyleSheet("font-weight: bold; font-size: 16px; color: #4caf50;")

                # Update version distribution
                self._version_dist_list.clear()
                for v in result.get('version_distribution', []):
                    self._version_dist_list.addItem(f"v{v['current_version']}: {v['count']} checks")

                self._admin_status.setText("📊 Statistics loaded")
                self._admin_status.setStyleSheet("color: #4fc3f7;")

            except Exception as e:
                self._admin_status.setText(f"❌ Failed to load stats: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")

        def _load_update_logs(self, dialog):
            """Load update logs from server."""
            try:
                # Determine filter
                filter_text = self._log_filter_combo.currentText()
                event_type = None
                if filter_text == "Update Checks":
                    event_type = "update_check"
                elif filter_text == "Downloads":
                    event_type = "download"

                result = plugin_store_api.get_update_logs(limit=100, event_type=event_type)
                
                if 'error' in result:
                    self._admin_status.setText(f"❌ Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return

                self._update_logs_list.clear()

                logs = result.get('logs', [])
                errors_only = filter_text == "Errors Only"

                for log in logs:
                    # Skip successful if errors only
                    if errors_only and log.get('success', 1):
                        continue

                    # Format log entry
                    event = log.get('event_type', '?')
                    icon = "🔍" if event == 'update_check' else "⬇️" if event == 'download' else "❓"
                    success = "✅" if log.get('success') else "❌"
                    time = log.get('created_at', '?')[:19]  # Trim to datetime
                    version = log.get('current_version') or log.get('target_version') or '?'
                    ip = log.get('ip_address', '?')[:15]  # Truncate IP

                    text = f"{icon} {success} [{time}] v{version} | {ip}"
                    if log.get('error_message'):
                        text += f" | ⚠️ {log['error_message'][:30]}"

                    item = QListWidgetItem(text)
                    if not log.get('success'):
                        item.setForeground(QColor('#f44336'))
                    self._update_logs_list.addItem(item)

                total = result.get('total', len(logs))
                self._admin_status.setText(f"📋 Showing {len(logs)} of {total} log entries")
                self._admin_status.setStyleSheet("color: #4fc3f7;")

            except Exception as e:
                self._admin_status.setText(f"❌ Failed to load logs: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")

        def _clear_old_logs(self, dialog):
            """Clear logs older than specified days."""
            days, ok = QInputDialog.getInt(
                dialog, "Clear Old Logs",
                "Delete logs older than (days):",
                30, 7, 365, 1
            )
            if not ok:
                return

            try:
                result = plugin_store_api.clear_old_logs(days)
                
                if 'error' in result:
                    self._admin_status.setText(f"❌ Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return

                deleted = result.get('deleted', 0)
                self._admin_status.setText(f"🗑️ Deleted {deleted} old log entries")
                self._admin_status.setStyleSheet("color: #ff9800;")

                # Refresh logs
                self._load_update_logs(dialog)

            except Exception as e:
                self._admin_status.setText(f"❌ Failed to clear logs: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")

        # =====================================================================
        # Security Tab Handler Methods
        # =====================================================================
        
        def _load_security_logs(self, dialog):
            """Load security event logs from server."""
            self._security_logs_list.clear()
            self._admin_status.setText("Loading security logs...")
            self._admin_status.setStyleSheet("color: #888;")
            QApplication.processEvents()
            
            try:
                event_type = None
                filter_text = self._security_filter_combo.currentText()
                if filter_text != "All Events":
                    event_type = filter_text
                
                result = plugin_store_api.get_security_logs(limit=100, event_type=event_type)
                
                if 'error' in result:
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return
                
                logs = result.get('logs', [])
                
                if not logs:
                    self._admin_status.setText("No security events found")
                    self._admin_status.setStyleSheet("color: #4fc3f7;")
                    return
                
                for log in logs:
                    item = QListWidgetItem()
                    item.setData(Qt.ItemDataRole.UserRole, log)
                    
                    event_type = log.get('event_type', 'UNKNOWN')
                    created = log.get('created_at', '')[:19]
                    details = log.get('details', {})
                    
                    # Color-code by severity
                    if event_type in ['SCAN_THREAT', 'FILE_QUARANTINED', 'UPLOAD_BLOCKED']:
                        item.setForeground(QColor('#f44336'))  # Red for threats
                        icon = "🔴"
                    elif event_type in ['SCAN_CLEAN']:
                        item.setForeground(QColor('#4CAF50'))  # Green for clean
                        icon = "🟢"
                    else:
                        item.setForeground(QColor('#ff9800'))  # Orange for other
                        icon = "🟡"
                    
                    text = f"{icon} [{created}] {event_type}"
                    if isinstance(details, dict):
                        if 'plugin_id' in details:
                            text += f" | Plugin: {details['plugin_id']}"
                        if 'filename' in details:
                            text += f" | File: {details['filename']}"
                        if 'threats' in details and details['threats']:
                            text += f" | Threats: {len(details['threats'])}"
                    
                    item.setText(text)
                    self._security_logs_list.addItem(item)
                
                self._admin_status.setText(f"Loaded {len(logs)} security events")
                self._admin_status.setStyleSheet("color: #4fc3f7;")
                
            except Exception as e:
                self._admin_status.setText(f"❌ Failed to load security logs: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")
        
        def _load_quarantine_files(self, dialog):
            """Load quarantined files list from server."""
            self._quarantine_list.clear()
            
            try:
                result = plugin_store_api.get_quarantine_files()
                
                if 'error' in result:
                    return
                
                files = result.get('files', [])
                
                for f in files:
                    item = QListWidgetItem()
                    item.setData(Qt.ItemDataRole.UserRole, f)
                    
                    name = f.get('name', 'Unknown')
                    size = f.get('size', 0)
                    quarantined = f.get('quarantined_at', '')[:19]
                    
                    size_str = f"{size / 1024:.1f} KB" if size < 1048576 else f"{size / 1048576:.1f} MB"
                    
                    item.setText(f"🦠 {name} ({size_str}) - Quarantined: {quarantined}")
                    item.setForeground(QColor('#f44336'))
                    self._quarantine_list.addItem(item)
                
            except Exception as e:
                pass  # Silently fail for quarantine list
        
        def _delete_quarantine_file(self, dialog):
            """Delete a selected quarantined file."""
            item = self._quarantine_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a file to delete.")
                return
            
            file_data = item.data(Qt.ItemDataRole.UserRole)
            filename = file_data.get('name', '')
            
            reply = QMessageBox.question(
                dialog, "Confirm Delete",
                f"Permanently delete quarantined file '{filename}'?\n\nThis cannot be undone.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                return
            
            try:
                result = plugin_store_api.delete_quarantine_file(filename)
                
                if 'error' in result:
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return
                
                self._admin_status.setText(f"🗑️ Deleted quarantined file: {filename}")
                self._admin_status.setStyleSheet("color: #ff9800;")
                self._load_quarantine_files(dialog)
                
            except Exception as e:
                self._admin_status.setText(f"❌ Failed to delete file: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")
        
        # =====================================================================
        # IP Banning Tab Handler Methods
        # =====================================================================
        
        def _load_banned_ips(self, dialog):
            """Load banned and suspicious IPs from server."""
            self._banned_ips_list.clear()
            self._suspicious_ips_list.clear()
            self._admin_status.setText("Loading IP data...")
            self._admin_status.setStyleSheet("color: #888;")
            QApplication.processEvents()
            
            try:
                result = plugin_store_api.get_banned_ips()
                
                if 'error' in result:
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return
                
                banned = result.get('banned', [])
                suspicious = result.get('suspicious', [])
                
                # Load banned IPs
                for ip_data in banned:
                    item = QListWidgetItem()
                    item.setData(Qt.ItemDataRole.UserRole, ip_data)
                    
                    ip = ip_data.get('ip_address', 'Unknown')
                    reason = ip_data.get('ban_reason', 'No reason')
                    expires = ip_data.get('ban_expires')
                    
                    if expires:
                        text = f"🚫 {ip} | {reason} | Expires: {expires[:19]}"
                    else:
                        text = f"🚫 {ip} | {reason} | PERMANENT"
                        item.setForeground(QColor('#f44336'))
                    
                    item.setText(text)
                    self._banned_ips_list.addItem(item)
                
                # Load suspicious IPs
                for ip_data in suspicious:
                    item = QListWidgetItem()
                    item.setData(Qt.ItemDataRole.UserRole, ip_data)
                    
                    ip = ip_data.get('ip_address', 'Unknown')
                    count = ip_data.get('request_count', 0)
                    last_request = ip_data.get('last_request', '')[:19]
                    
                    item.setText(f"⚠️ {ip} | {count} requests | Last: {last_request}")
                    item.setForeground(QColor('#ff9800'))
                    self._suspicious_ips_list.addItem(item)
                
                self._admin_status.setText(f"Found {len(banned)} banned, {len(suspicious)} suspicious IPs")
                self._admin_status.setStyleSheet("color: #4fc3f7;")
                
            except Exception as e:
                self._admin_status.setText(f"❌ Failed to load IP data: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")
        
        def _ban_ip_action(self, dialog):
            """Ban an IP address."""
            ip = self._ban_ip_input.text().strip()
            if not ip:
                QMessageBox.warning(dialog, "Invalid Input", "Please enter an IP address.")
                return
            
            reason = self._ban_reason_input.text().strip() or "Banned by admin"
            permanent = self._ban_permanent_checkbox.isChecked()
            
            try:
                result = plugin_store_api.ban_ip(ip, reason, permanent)
                
                if 'error' in result:
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return
                
                self._admin_status.setText(f"🚫 Banned IP: {ip}")
                self._admin_status.setStyleSheet("color: #ff9800;")
                
                # Clear inputs
                self._ban_ip_input.clear()
                self._ban_reason_input.clear()
                self._ban_permanent_checkbox.setChecked(False)
                
                # Refresh list
                self._load_banned_ips(dialog)
                
            except Exception as e:
                self._admin_status.setText(f"❌ Failed to ban IP: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")
        
        def _unban_ip_action(self, dialog):
            """Unban a selected IP address."""
            item = self._banned_ips_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select an IP to unban.")
                return
            
            ip_data = item.data(Qt.ItemDataRole.UserRole)
            ip = ip_data.get('ip_address', '')
            
            try:
                result = plugin_store_api.unban_ip(ip)
                
                if 'error' in result:
                    self._admin_status.setText(f"Error: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
                    return
                
                self._admin_status.setText(f"✅ Unbanned IP: {ip}")
                self._admin_status.setStyleSheet("color: #4CAF50;")
                
                # Refresh list
                self._load_banned_ips(dialog)
                
            except Exception as e:
                self._admin_status.setText(f"❌ Failed to unban IP: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")

        # =====================================================================
        # Chat Admin Methods
        # =====================================================================
        
        def _show_create_room_dialog(self, parent_dialog):
            """Show dialog to create a new chat room with emoji picker (admin only)."""
            dialog = QDialog(parent_dialog)
            dialog.setWindowTitle("Create Chat Room")
            dialog.setMinimumWidth(400)
            
            layout = QVBoxLayout(dialog)
            
            # Common emoji options for room icons
            ROOM_EMOJIS = [
                "🌐", "💬", "📢", "🎮", "🛠️", "📱", "💻", "🎨", 
                "📚", "🎵", "🎬", "📸", "🔧", "⚙️", "🚀", "💡",
                "🔒", "👥", "🏠", "⭐", "🔥", "💎", "🎯", "📣",
                "🌟", "🎉", "💼", "🎓", "🏆", "🎁", "📌", "🔔"
            ]
            
            # Emoji selection
            emoji_label = QLabel("Room Icon (optional):")
            layout.addWidget(emoji_label)
            
            emoji_layout = QGridLayout()
            self._selected_room_emoji = ""
            emoji_buttons = []
            
            def select_emoji(emoji, btn):
                self._selected_room_emoji = emoji
                # Update selection visuals
                for b in emoji_buttons:
                    b.setStyleSheet("font-size: 20px; padding: 5px; background: #333; border: 1px solid #555;")
                btn.setStyleSheet("font-size: 20px; padding: 5px; background: #2d4a6d; border: 2px solid #4fc3f7;")
            
            for i, emoji in enumerate(ROOM_EMOJIS):
                btn = QPushButton(emoji)
                btn.setFixedSize(40, 40)
                btn.setStyleSheet("font-size: 20px; padding: 5px; background: #333; border: 1px solid #555;")
                btn.clicked.connect(lambda checked, e=emoji, b=btn: select_emoji(e, b))
                emoji_buttons.append(btn)
                emoji_layout.addWidget(btn, i // 8, i % 8)
            
            layout.addLayout(emoji_layout)
            
            # Room name
            name_label = QLabel("Room Name:")
            layout.addWidget(name_label)
            
            name_input = QLineEdit()
            name_input.setPlaceholderText("e.g., Announcements, Help Desk, etc.")
            layout.addWidget(name_input)
            
            # Description
            desc_label = QLabel("Description (optional):")
            layout.addWidget(desc_label)
            
            desc_input = QLineEdit()
            desc_input.setPlaceholderText("What is this room for?")
            layout.addWidget(desc_input)
            
            # Private room checkbox
            private_checkbox = QCheckBox("Private room (requires password)")
            layout.addWidget(private_checkbox)
            
            # Password field
            password_input = QLineEdit()
            password_input.setPlaceholderText("Room password")
            password_input.setEchoMode(QLineEdit.EchoMode.Password)
            password_input.setEnabled(False)
            layout.addWidget(password_input)
            
            private_checkbox.toggled.connect(password_input.setEnabled)
            
            # Buttons
            btn_layout = QHBoxLayout()
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            btn_layout.addWidget(cancel_btn)
            
            create_btn = QPushButton("Create Room")
            create_btn.setStyleSheet("background: #4CAF50; padding: 10px 20px;")
            
            def do_create():
                name = name_input.text().strip()
                if not name:
                    QMessageBox.warning(dialog, "Error", "Please enter a room name.")
                    return
                
                # Prepend emoji if selected
                full_name = f"{self._selected_room_emoji} {name}".strip() if self._selected_room_emoji else name
                
                try:
                    data = {
                        'name': full_name,
                        'description': desc_input.text().strip(),
                        'is_private': private_checkbox.isChecked(),
                    }
                    if private_checkbox.isChecked():
                        data['password'] = password_input.text()
                    
                    result = plugin_store_api._request('POST', '/api/admin/chat/rooms', data)
                    
                    if 'error' in result:
                        QMessageBox.warning(dialog, "Error", f"Failed to create room: {result['error']}")
                    else:
                        QMessageBox.information(dialog, "Success", f"Room '{full_name}' created successfully!")
                        dialog.accept()
                        # Refresh rooms list
                        self._load_admin_chat_data(parent_dialog)
                        
                except Exception as e:
                    QMessageBox.critical(dialog, "Error", f"Failed to create room: {e}")
            
            create_btn.clicked.connect(do_create)
            btn_layout.addWidget(create_btn)
            
            layout.addLayout(btn_layout)
            
            dialog.exec()
        
        def _load_admin_chat_data(self, dialog):
            """Load chat statistics, rooms, and users for admin panel."""
            self._admin_status.setText("Loading chat data...")
            self._admin_status.setStyleSheet("color: #888;")
            
            # Store dialog reference for callback
            self._chat_admin_dialog = dialog
            
            def do_load():
                try:
                    # Use plugin_store_api._request() — same path that works
                    # for all other admin endpoints (urllib + CF headers + app signature)
                    stats = plugin_store_api._request('GET', '/api/admin/chat/stats')
                    
                    # Check if endpoints are deployed
                    if isinstance(stats, dict) and stats.get('error'):
                        err = stats['error']
                        if '404' in str(err) or 'Not Found' in str(err):
                            return {'error': 'Chat admin API not deployed yet. Please deploy server.js to the server.'}
                        if '401' in str(err) or 'Authentication' in str(err).lower():
                            return {'error': 'Authentication expired. Please log out and log back in.'}
                        if '403' in str(err) or 'denied' in str(err).lower() or 'Admin' in str(err):
                            return {'error': f"Access denied: {err}"}
                        return {'error': err}
                    
                    rooms_result = plugin_store_api._request('GET', '/api/admin/chat/rooms')
                    rooms = rooms_result.get('rooms', []) if isinstance(rooms_result, dict) and 'error' not in rooms_result else []
                    
                    users_result = plugin_store_api._request('GET', '/api/admin/chat/users')
                    users = users_result.get('users', []) if isinstance(users_result, dict) and 'error' not in users_result else []
                    
                    return {'stats': stats, 'rooms': rooms, 'users': users}
                except Exception as e:
                    return {'error': str(e)}
            
            # Run in thread
            import threading
            def run_and_update():
                result = do_load()
                # Store result for callback
                self._chat_admin_result = result
                # Update UI in main thread - use invokeMethod pattern
                QTimer.singleShot(0, self._do_update_chat_admin_ui)
            
            thread = threading.Thread(target=run_and_update, daemon=True)
            thread.start()
        
        def _do_update_chat_admin_ui(self):
            """Internal callback to update chat admin UI from main thread."""
            try:
                result = getattr(self, '_chat_admin_result', {'error': 'No result'})
                dialog = getattr(self, '_chat_admin_dialog', None)
                if dialog:
                    self._update_chat_admin_ui(dialog, result)
            except Exception:
                pass  # Silently handle UI update errors
        
        def _update_chat_admin_ui(self, dialog, result):
            """Update chat admin UI with loaded data."""
            if 'error' in result:
                self._admin_status.setText(f"Error: {result['error']}")
                self._admin_status.setStyleSheet("color: #f44336;")
                return
            
            # Update stats
            stats = result.get('stats', {})
            stat_mapping = {
                'total_messages': stats.get('total_messages', 0),
                'messages_today': stats.get('messages_today', 0),
                'total_rooms': stats.get('total_rooms', 0),
                'active_users': stats.get('active_users_24h', 0),
                'online_now': stats.get('online_now', 0),
                'total_users': stats.get('total_users', 0),
            }
            for key, value in stat_mapping.items():
                if key in self._chat_stats_labels:
                    self._chat_stats_labels[key].setText(str(value))
            
            # Update rooms list
            self._admin_rooms_list.clear()
            rooms = result.get('rooms', [])
            self._chat_admin_rooms = rooms  # Store for later use
            
            for room in rooms:
                item = QListWidgetItem()
                item.setData(Qt.ItemDataRole.UserRole, room)
                
                icon = "🔒" if room.get('is_private') else "💬"
                if room.get('id') == 'general':
                    icon = "🌐"
                
                member_count = room.get('member_count', 0)
                msg_count = room.get('message_count', 0)
                owner = room.get('owner_name', 'System')
                
                text = f"{icon} {room.get('name', 'Unknown')}\n"
                text += f"   Owner: {owner} | Members: {member_count} | Messages: {msg_count}"
                if room.get('has_password'):
                    text += " | 🔑 Password"
                item.setText(text)
                
                self._admin_rooms_list.addItem(item)
            
            # Update users list
            self._admin_chat_users_list.clear()
            users = result.get('users', [])
            self._chat_admin_users = users  # Store for filtering
            
            for user in users:
                self._add_chat_user_item(user)
            
            self._admin_status.setText(f"Loaded {len(rooms)} rooms, {len(users)} users")
            self._admin_status.setStyleSheet("color: #4CAF50;")
        
        def _add_chat_user_item(self, user):
            """Add a user item to the chat users list."""
            item = QListWidgetItem()
            item.setData(Qt.ItemDataRole.UserRole, user)
            
            status_icon = "🟢" if user.get('is_online') else "⚫"
            admin_badge = " [ADMIN]" if user.get('is_admin') else ""
            ban_badge = " 🚫 BANNED" if user.get('is_banned') else ""
            mute_badge = " 🔇 MUTED" if user.get('is_muted') else ""
            
            msg_count = user.get('message_count', 0)
            last_seen = user.get('last_seen', 'Never')[:10] if user.get('last_seen') else 'Never'
            
            text = f"{status_icon} {user.get('username', 'Unknown')}{admin_badge}{ban_badge}{mute_badge}"
            text += f"\n   Messages: {msg_count} | Last seen: {last_seen}"
            item.setText(text)
            
            self._admin_chat_users_list.addItem(item)
        
        def _filter_chat_users(self):
            """Filter chat users list by search text."""
            search_text = self._chat_user_search.text().lower()
            self._admin_chat_users_list.clear()
            
            for user in getattr(self, '_chat_admin_users', []):
                username = user.get('username', '').lower()
                if search_text in username:
                    self._add_chat_user_item(user)
        
        def _view_room_messages(self, dialog):
            """View messages in a selected room."""
            item = self._admin_rooms_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a room.")
                return
            
            room = item.data(Qt.ItemDataRole.UserRole)
            room_id = room.get('id', 'general')
            room_name = room.get('name', 'Unknown')
            
            # Create messages dialog
            msg_dialog = QDialog(dialog)
            msg_dialog.setWindowTitle(f"💬 Messages in: {room_name}")
            msg_dialog.setMinimumWidth(600)
            msg_dialog.setMinimumHeight(500)
            
            layout = QVBoxLayout(msg_dialog)
            
            # Messages list
            messages_list = QListWidget()
            messages_list.setStyleSheet("""
                QListWidget::item { padding: 8px; border-bottom: 1px solid #333; }
            """)
            layout.addWidget(messages_list)
            
            # Load messages
            try:
                result = plugin_store_api._request('GET', f'/api/admin/chat/rooms/{room_id}/messages')
                
                if 'error' not in result:
                    messages = result.get('messages', [])
                    for msg in messages:
                        msg_item = QListWidgetItem()
                        msg_item.setData(Qt.ItemDataRole.UserRole, msg)
                        
                        username = msg.get('username', 'Unknown')
                        content = msg.get('message', '')[:200]
                        timestamp = msg.get('created_at', '')[:16]
                        deleted = " [DELETED]" if msg.get('is_deleted') else ""
                        
                        text = f"[{timestamp}] {username}: {content}{deleted}"
                        msg_item.setText(text)
                        messages_list.addItem(msg_item)
                    
                    if not messages:
                        messages_list.addItem("No messages in this room.")
                else:
                    messages_list.addItem(f"Error loading messages: {result.get('error', 'Unknown error')}")
            except Exception as e:
                messages_list.addItem(f"Error: {e}")
            
            # Buttons
            btn_layout = QHBoxLayout()
            
            delete_msg_btn = QPushButton("🗑️ Delete Selected Message")
            delete_msg_btn.setStyleSheet("background: #f44336;")
            delete_msg_btn.clicked.connect(lambda: self._delete_admin_message(msg_dialog, messages_list, room_id))
            btn_layout.addWidget(delete_msg_btn)
            
            btn_layout.addStretch()
            
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(msg_dialog.accept)
            btn_layout.addWidget(close_btn)
            
            layout.addLayout(btn_layout)
            msg_dialog.exec()
        
        def _delete_admin_message(self, dialog, messages_list, room_id):
            """Delete a message from admin panel."""
            item = messages_list.currentItem()
            if not item:
                return
            
            msg = item.data(Qt.ItemDataRole.UserRole)
            if not msg:
                return
            
            msg_id = msg.get('id')
            
            confirm = QMessageBox.question(
                dialog, "Delete Message",
                f"Delete this message?\n\n{msg.get('message', '')[:100]}",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if confirm != QMessageBox.StandardButton.Yes:
                return
            
            try:
                result = plugin_store_api._request('DELETE', f'/api/chat/messages/{msg_id}')
                
                if 'error' not in result:
                    messages_list.takeItem(messages_list.row(item))
                    QMessageBox.information(dialog, "Deleted", "Message deleted.")
                else:
                    QMessageBox.warning(dialog, "Error", f"Failed to delete: {result['error']}")
            except Exception as e:
                QMessageBox.warning(dialog, "Error", f"Failed: {e}")
        
        def _delete_admin_room(self, dialog):
            """Delete a chat room."""
            item = self._admin_rooms_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a room to delete.")
                return
            
            room = item.data(Qt.ItemDataRole.UserRole)
            room_id = room.get('id')
            room_name = room.get('name', 'Unknown')
            
            if room_id == 'general':
                QMessageBox.warning(dialog, "Cannot Delete", "Cannot delete the General room.")
                return
            
            confirm = QMessageBox.question(
                dialog, "Delete Room",
                f"Are you sure you want to delete '{room_name}'?\n\nThis will delete all messages and members.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if confirm != QMessageBox.StandardButton.Yes:
                return
            
            try:
                result = plugin_store_api._request('DELETE', f'/api/chat/rooms/{room_id}')
                
                if 'error' not in result:
                    self._admin_status.setText(f"✅ Deleted room: {room_name}")
                    self._admin_status.setStyleSheet("color: #4CAF50;")
                    self._load_admin_chat_data(dialog)
                else:
                    self._admin_status.setText(f"❌ Failed: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
            except Exception as e:
                self._admin_status.setText(f"❌ Error: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")
        
        def _admin_mute_user(self, dialog):
            """Mute a user from chat."""
            item = self._admin_chat_users_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a user to mute.")
                return
            
            user = item.data(Qt.ItemDataRole.UserRole)
            user_id = user.get('id')
            username = user.get('username', 'Unknown')
            
            duration, ok = QInputDialog.getItem(
                dialog, "Mute Duration", f"Mute {username} for:",
                ["5 minutes", "30 minutes", "1 hour", "6 hours", "24 hours", "7 days"],
                0, False
            )
            
            if not ok:
                return
            
            try:
                result = plugin_store_api._request('POST', '/api/chat/mute', {'user_id': user_id, 'duration': duration})
                
                if 'error' not in result:
                    self._admin_status.setText(f"✅ Muted {username} for {duration}")
                    self._admin_status.setStyleSheet("color: #4CAF50;")
                    self._load_admin_chat_data(dialog)
                else:
                    self._admin_status.setText(f"❌ Failed: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
            except Exception as e:
                self._admin_status.setText(f"❌ Error: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")
        
        def _admin_ban_chat_user(self, dialog):
            """Ban a user from chat."""
            item = self._admin_chat_users_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a user to ban.")
                return
            
            user = item.data(Qt.ItemDataRole.UserRole)
            user_id = user.get('id')
            username = user.get('username', 'Unknown')
            
            if user.get('is_admin'):
                QMessageBox.warning(dialog, "Cannot Ban", "Cannot ban an admin user.")
                return
            
            duration, ok = QInputDialog.getItem(
                dialog, "Ban Duration", f"Ban {username} from chat for:",
                ["1 hour", "24 hours", "7 days", "30 days", "Permanent"],
                0, False
            )
            
            if not ok:
                return
            
            reason, ok2 = QInputDialog.getText(
                dialog, "Ban Reason", "Reason for ban (optional):"
            )
            
            try:
                result = plugin_store_api._request('POST', '/api/chat/ban', {
                    'user_id': user_id, 'duration': duration, 'reason': reason or 'Banned by admin'
                })
                
                if 'error' not in result:
                    self._admin_status.setText(f"✅ Banned {username} for {duration}")
                    self._admin_status.setStyleSheet("color: #4CAF50;")
                    self._load_admin_chat_data(dialog)
                else:
                    self._admin_status.setText(f"❌ Failed: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
            except Exception as e:
                self._admin_status.setText(f"❌ Error: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")
        
        def _admin_unban_chat_user(self, dialog):
            """Unban a user from chat."""
            item = self._admin_chat_users_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a user to unban.")
                return
            
            user = item.data(Qt.ItemDataRole.UserRole)
            user_id = user.get('id')
            username = user.get('username', 'Unknown')
            
            if not user.get('is_banned'):
                QMessageBox.information(dialog, "Not Banned", f"{username} is not banned.")
                return
            
            try:
                result = plugin_store_api._request('DELETE', f'/api/chat/ban/{user_id}')
                
                if 'error' not in result:
                    self._admin_status.setText(f"✅ Unbanned {username}")
                    self._admin_status.setStyleSheet("color: #4CAF50;")
                    self._load_admin_chat_data(dialog)
                else:
                    self._admin_status.setText(f"❌ Failed: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
            except Exception as e:
                self._admin_status.setText(f"❌ Error: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")
        
        def _broadcast_chat_message(self, dialog):
            """Broadcast a system message to all chat users."""
            message = self._chat_broadcast_input.text().strip()
            if not message:
                QMessageBox.warning(dialog, "Empty Message", "Please enter a message to broadcast.")
                return
            
            confirm = QMessageBox.question(
                dialog, "Broadcast Message",
                f"Send this message to ALL chat users?\n\n{message}",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if confirm != QMessageBox.StandardButton.Yes:
                return
            
            try:
                result = plugin_store_api._request('POST', '/api/admin/chat/broadcast', {'message': message})
                
                if 'error' not in result:
                    self._admin_status.setText("✅ Broadcast sent!")
                    self._admin_status.setStyleSheet("color: #4CAF50;")
                    self._chat_broadcast_input.clear()
                else:
                    self._admin_status.setText(f"❌ Failed: {result['error']}")
                    self._admin_status.setStyleSheet("color: #f44336;")
            except Exception as e:
                self._admin_status.setText(f"❌ Error: {e}")
                self._admin_status.setStyleSheet("color: #f44336;")

        def _review_selected_plugin(self, dialog):
            """Review detailed info for a pending plugin."""
            item = self._admin_pending_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a plugin to review.")
                return
            plugin = item.data(Qt.ItemDataRole.UserRole)
            self._show_plugin_review_dialog(dialog, plugin.get('id'), plugin.get('name', 'Unknown'))
        
        def _review_all_selected_plugin(self, dialog):
            """Review detailed info for a plugin from all plugins list."""
            item = self._admin_all_list.currentItem()
            if not item:
                QMessageBox.warning(dialog, "No Selection", "Please select a plugin to review.")
                return
            plugin = item.data(Qt.ItemDataRole.UserRole)
            self._show_plugin_review_dialog(dialog, plugin.get('id'), plugin.get('name', 'Unknown'))
        
        def _show_plugin_review_dialog(self, parent, plugin_id, plugin_name):
            """Show detailed review dialog for a plugin."""
            review_dialog = QDialog(parent)
            review_dialog.setWindowTitle(f"🔍 Review: {plugin_name}")
            review_dialog.setMinimumWidth(900)
            review_dialog.setMinimumHeight(700)
            
            layout = QVBoxLayout(review_dialog)
            
            # Loading
            status_label = QLabel("⏳ Loading plugin details...")
            status_label.setStyleSheet("font-size: 14px; padding: 10px;")
            layout.addWidget(status_label)
            
            QApplication.processEvents()
            
            # Fetch details
            result = plugin_store_api.get_plugin_review_details(plugin_id)
            
            if 'error' in result:
                status_label.setText(f"❌ Error: {result['error']}")
                status_label.setStyleSheet("color: #f44336;")
                return
            
            # Remove loading label
            layout.removeWidget(status_label)
            status_label.deleteLater()
            
            plugin = result.get('plugin', {})
            scan_results = result.get('scanResults', [])
            binaries = result.get('binaries', [])
            all_files = result.get('allFiles', [])
            external_deps = result.get('externalDependencies', [])
            summary = result.get('summary', {})
            
            # Create scrollable content
            scroll = QScrollArea()
            scroll.setWidgetResizable(True)
            scroll_content = QWidget()
            scroll_layout = QVBoxLayout(scroll_content)
            
            # ---- Plugin Info Section ----
            info_group = QGroupBox("📦 Plugin Information")
            info_layout = QFormLayout(info_group)
            
            info_layout.addRow("ID:", QLabel(f"<code>{plugin.get('id', '?')}</code>"))
            info_layout.addRow("Name:", QLabel(f"<b>{plugin.get('name', '?')}</b>"))
            info_layout.addRow("Version:", QLabel(plugin.get('version', '?')))
            info_layout.addRow("Author:", QLabel(f"{plugin.get('author_name', '?')} ({plugin.get('author_email', '?')})"))
            info_layout.addRow("Category:", QLabel(plugin.get('category', '?')))
            info_layout.addRow("License:", QLabel(plugin.get('license_type', '?')))
            info_layout.addRow("Status:", QLabel(f"<b>{plugin.get('status', '?').upper()}</b>"))
            info_layout.addRow("File Size:", QLabel(f"{plugin.get('file_size', 0) / 1024:.1f} KB"))
            info_layout.addRow("Submitted:", QLabel(plugin.get('created_at', '?')))
            
            scroll_layout.addWidget(info_group)
            
            # ---- Description Section ----
            desc_group = QGroupBox("📝 Description")
            desc_layout = QVBoxLayout(desc_group)
            
            short_desc = QLabel(plugin.get('description', 'No description'))
            short_desc.setWordWrap(True)
            short_desc.setStyleSheet("font-weight: bold;")
            desc_layout.addWidget(short_desc)
            
            long_desc = plugin.get('long_description', '')
            if long_desc:
                long_desc_edit = QTextEdit()
                long_desc_edit.setReadOnly(True)
                long_desc_edit.setHtml(long_desc)
                long_desc_edit.setMaximumHeight(200)
                desc_layout.addWidget(long_desc_edit)
            
            scroll_layout.addWidget(desc_group)
            
            # ---- Dependencies & Git Clone Section ----
            deps_info_group = QGroupBox("📦 Plugin Dependencies")
            deps_info_layout = QVBoxLayout(deps_info_group)
            
            # Pip requirements
            requirements = plugin.get('requirements', [])
            if requirements:
                req_label = QLabel(f"<b>📋 Pip Requirements ({len(requirements)}):</b>")
                deps_info_layout.addWidget(req_label)
                req_list = QLabel("<code>" + ", ".join(requirements) + "</code>")
                req_list.setWordWrap(True)
                req_list.setStyleSheet("padding: 5px; background: rgba(33, 150, 243, 0.1); border-radius: 4px;")
                deps_info_layout.addWidget(req_list)
            else:
                deps_info_layout.addWidget(QLabel("📋 No pip requirements"))
            
            # Git clone
            git_clone = plugin.get('git_clone', {})
            if git_clone:
                git_label = QLabel("<b>📦 Git Repository Clone:</b>")
                git_label.setStyleSheet("margin-top: 10px;")
                deps_info_layout.addWidget(git_label)
                
                git_info_text = f"<b>Repo:</b> <code>{git_clone.get('repo', '?')}</code><br>"
                git_info_text += f"<b>Target Directory:</b> <code>{git_clone.get('target', 'repo root')}</code>"
                if git_clone.get('requirements_file'):
                    git_info_text += f"<br><b>Requirements File:</b> <code>{git_clone.get('requirements_file')}</code>"
                
                git_info_label = QLabel(git_info_text)
                git_info_label.setWordWrap(True)
                git_info_label.setStyleSheet("padding: 8px; background: rgba(76, 175, 80, 0.1); border-radius: 4px;")
                deps_info_layout.addWidget(git_info_label)
                
                # Warning about git clone
                git_warning = QLabel("⚠️ <span style='color:#ff9800;'>Plugin will clone this repository when installed. Verify the source!</span>")
                git_warning.setTextFormat(Qt.TextFormat.RichText)
                git_warning.setStyleSheet("margin-top: 5px;")
                deps_info_layout.addWidget(git_warning)
            else:
                no_git_label = QLabel("📦 No git clone required")
                no_git_label.setStyleSheet("margin-top: 10px;")
                deps_info_layout.addWidget(no_git_label)
            
            # Bundled binaries from manifest
            bundled_bins = plugin.get('bundled_binaries', [])
            if bundled_bins:
                bundled_label = QLabel(f"<b>📁 Bundled Binaries ({len(bundled_bins)}):</b>")
                bundled_label.setStyleSheet("margin-top: 10px;")
                deps_info_layout.addWidget(bundled_label)
                for bb in bundled_bins:
                    bb_label = QLabel(f"• <code>{bb}</code>")
                    bb_label.setStyleSheet("padding-left: 10px;")
                    deps_info_layout.addWidget(bb_label)
            
            # Setup commands from manifest
            setup_commands = plugin.get('setup_commands', [])
            if setup_commands:
                cmd_label = QLabel(f"<b>⚡ Setup Commands ({len(setup_commands)}):</b>")
                cmd_label.setStyleSheet("margin-top: 10px;")
                deps_info_layout.addWidget(cmd_label)
                for cmd in setup_commands:
                    cmd_display = QLabel(f"• <code>{cmd}</code>")
                    cmd_display.setStyleSheet("padding-left: 10px;")
                    deps_info_layout.addWidget(cmd_display)
                
                # Warning about setup commands
                cmd_warning = QLabel("⚠️ <span style='color:#ff9800;'>Review these commands carefully! They will run during plugin setup.</span>")
                cmd_warning.setTextFormat(Qt.TextFormat.RichText)
                cmd_warning.setStyleSheet("margin-top: 5px;")
                deps_info_layout.addWidget(cmd_warning)
            
            scroll_layout.addWidget(deps_info_group)
            
            # ---- Security Scan Section ----
            scan_group = QGroupBox(f"🔒 Security Scan Results ({len(scan_results)} scan(s))")
            scan_layout = QVBoxLayout(scan_group)
            
            if scan_results:
                for scan in scan_results:
                    scan_text = f"<b>File:</b> {scan.get('file_name', '?')}<br>"
                    scan_text += f"<b>Safe:</b> {'✅ Yes' if scan.get('is_safe') else '❌ NO - THREATS DETECTED'}<br>"
                    scan_text += f"<b>Context:</b> {scan.get('scan_context', '?')}<br>"
                    scan_text += f"<b>ClamAV:</b> {scan.get('clamav_result') or '✅ Clean'}<br>"
                    scan_text += f"<b>VirusTotal:</b> {scan.get('virustotal_detections', 0)}/{scan.get('virustotal_total', 0)} detections"
                    if scan.get('virustotal_scan_id'):
                        scan_text += f" (ID: {scan.get('virustotal_scan_id')[:16]}...)"
                    
                    threats = scan.get('threats', [])
                    if threats:
                        scan_text += f"<br><b style='color: #f44336;'>Threats:</b> {', '.join(threats)}"
                    
                    scan_label = QLabel(scan_text)
                    scan_label.setWordWrap(True)
                    scan_label.setStyleSheet("padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-bottom: 5px;")
                    scan_layout.addWidget(scan_label)
            else:
                scan_layout.addWidget(QLabel("No scan results available"))
            
            scroll_layout.addWidget(scan_group)
            
            # ---- Binaries Section ----
            bin_group = QGroupBox(f"⚙️ Binaries/Executables ({len(binaries)})")
            bin_layout = QVBoxLayout(bin_group)
            
            if binaries:
                for b in binaries:
                    size_kb = b.get('size', 0) / 1024
                    bin_label = QLabel(f"📁 <code>{b.get('path', '?')}</code> ({size_kb:.1f} KB)")
                    bin_label.setStyleSheet("padding: 3px;")
                    bin_layout.addWidget(bin_label)
            else:
                bin_layout.addWidget(QLabel("✅ No binaries found in package"))
            
            scroll_layout.addWidget(bin_group)
            
            # ---- All Files Section ----
            files_group = QGroupBox(f"📂 All Files ({len(all_files)})")
            files_layout = QVBoxLayout(files_group)
            
            files_list = QListWidget()
            files_list.setMaximumHeight(150)
            for f in all_files[:50]:  # Limit to 50
                size_kb = f.get('size', 0) / 1024
                files_list.addItem(f"{f.get('path', '?')} ({size_kb:.1f} KB)")
            if len(all_files) > 50:
                files_list.addItem(f"... and {len(all_files) - 50} more files")
            files_layout.addWidget(files_list)
            
            scroll_layout.addWidget(files_group)
            
            # ---- External Dependencies Section ----
            if external_deps:
                deps_group = QGroupBox(f"🌐 External Dependencies ({len(external_deps)})")
                deps_layout = QVBoxLayout(deps_group)
                
                deps_status = plugin.get('deps_status', 'unknown')
                deps_label = QLabel(f"<b>Status:</b> {deps_status.upper()}")
                deps_layout.addWidget(deps_label)
                
                for dep in external_deps:
                    dep_text = f"<b>{dep.get('name', '?')}</b><br>"
                    dep_text += f"URL: <code>{dep.get('url', '?')[:80]}...</code><br>"
                    dep_text += f"Target: {dep.get('targetPath', './')}"
                    dep_label = QLabel(dep_text)
                    dep_label.setWordWrap(True)
                    dep_label.setStyleSheet("padding: 5px; background: rgba(255,152,0,0.1); border-radius: 4px; margin: 2px 0;")
                    deps_layout.addWidget(dep_label)
                
                scroll_layout.addWidget(deps_group)
            
            # ---- Summary Section ----
            summary_group = QGroupBox("📊 Summary")
            summary_layout = QFormLayout(summary_group)
            summary_layout.addRow("Total Files:", QLabel(str(summary.get('totalFiles', 0))))
            
            # Show both in-ZIP binaries and manifest bundled_binaries
            in_zip_binaries = summary.get('totalBinaries', 0)
            bundled_binaries_count = len(plugin.get('bundled_binaries', []))
            if bundled_binaries_count > 0:
                summary_layout.addRow("Binaries (in ZIP):", QLabel(str(in_zip_binaries)))
                summary_layout.addRow("Binaries (to download):", QLabel(f"⬇️ {bundled_binaries_count}"))
            else:
                summary_layout.addRow("Binaries:", QLabel(str(in_zip_binaries)))
            
            summary_layout.addRow("Scans Performed:", QLabel(str(summary.get('totalScans', 0))))
            summary_layout.addRow("Has Threats:", QLabel("❌ YES" if summary.get('hasThreats') else "✅ No"))
            summary_layout.addRow("Pending Deps:", QLabel("⏳ Yes" if summary.get('hasPendingDeps') else "✅ No"))
            summary_layout.addRow("Git Clone:", QLabel("📦 Yes" if summary.get('hasGitClone') else "No"))
            summary_layout.addRow("Pip Requirements:", QLabel("📋 Yes" if summary.get('hasRequirements') else "No"))
            scroll_layout.addWidget(summary_group)
            
            scroll_layout.addStretch()
            scroll.setWidget(scroll_content)
            layout.addWidget(scroll)
            
            # Close button
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(review_dialog.accept)
            layout.addWidget(close_btn)
            
            review_dialog.exec()

        def _show_upload_dialog(self):
            """Show dialog to upload a plugin."""
            if not plugin_store_api.is_logged_in():
                QMessageBox.warning(
                    self,
                    "Login Required",
                    "You must be logged in to upload plugins.\n"
                    "Click 'Login' to create an account or sign in."
                )
                return
            
            dialog = QDialog(self)
            dialog.setWindowTitle("Upload Plugin to Store")
            dialog.setMinimumWidth(600)
            dialog.setMinimumHeight(800)
            
            scroll = QScrollArea()
            scroll.setWidgetResizable(True)
            scroll.setFrameShape(QFrame.Shape.NoFrame)
            
            scroll_widget = QWidget()
            layout = QVBoxLayout(scroll_widget)
            
            # Instructions
            intro = QLabel(
                "📤 <b>Upload Your Plugin to the Image Anarchy Store</b><br><br>"
                "Package your plugin as a ZIP file containing:<br>"
                "• <code>manifest.json</code> - Plugin metadata and configuration<br>"
                "• Your main Python file with a <code>Plugin</code> class<br><br>"
                "Your plugin will be reviewed before appearing in the store."
            )
            intro.setTextFormat(Qt.TextFormat.RichText)
            intro.setWordWrap(True)
            layout.addWidget(intro)
            
            # Manifest requirements info box
            manifest_info = QFrame()
            manifest_info.setStyleSheet("""
                QFrame {
                    background-color: #2a4a6a;
                    border: 1px solid #4fc3f7;
                    border-radius: 6px;
                    padding: 10px;
                }
            """)
            manifest_info_layout = QVBoxLayout(manifest_info)
            manifest_label = QLabel(
                "<b>📋 manifest.json Requirements</b><br><br>"
                "<b>Required fields:</b> id, name, version, description, author<br><br>"
                "<b>📦 Python Dependencies:</b> Add pip packages your plugin needs:<br>"
                "<code style='background:#1a1a1a;padding:4px;'>"
                '&nbsp;&nbsp;"requirements": ["package1", "package2>=1.0"]'
                "</code><br><br>"
                "<b>Example manifest.json:</b><br>"
                "<code style='background:#1a1a1a;padding:4px;font-size:10px;'>"
                '{<br>'
                '&nbsp;&nbsp;"id": "my_plugin",<br>'
                '&nbsp;&nbsp;"name": "My Plugin",<br>'
                '&nbsp;&nbsp;"version": "1.0.0",<br>'
                '&nbsp;&nbsp;"author": "Your Name",<br>'
                '&nbsp;&nbsp;"description": "Short description",<br>'
                '&nbsp;&nbsp;"icon": "🔧",<br>'
                '&nbsp;&nbsp;"category": "tools",<br>'
                '&nbsp;&nbsp;"requirements": ["requests", "pillow>=9.0"],<br>'
                '&nbsp;&nbsp;"license_type": "free"<br>'
                '}'
                "</code>"
            )
            manifest_label.setTextFormat(Qt.TextFormat.RichText)
            manifest_label.setWordWrap(True)
            manifest_label.setStyleSheet("color: #e0e0e0; font-size: 11px;")
            manifest_info_layout.addWidget(manifest_label)
            layout.addWidget(manifest_info)
            
            layout.addSpacing(10)
            
            # Plugin file selector
            file_group = QGroupBox("Plugin File")
            file_group_layout = QVBoxLayout(file_group)
            
            file_layout = QHBoxLayout()
            self._upload_file_path = QLineEdit()
            self._upload_file_path.setReadOnly(True)
            self._upload_file_path.setPlaceholderText("Select your plugin.zip file...")
            file_layout.addWidget(self._upload_file_path)
            
            browse_btn = QPushButton("Browse...")
            browse_btn.clicked.connect(lambda: self._browse_upload_file(dialog))
            file_layout.addWidget(browse_btn)
            file_group_layout.addLayout(file_layout)
            
            layout.addWidget(file_group)
            
            # Screenshots
            screenshots_group = QGroupBox("Screenshots (Optional, up to 5)")
            screenshots_layout = QVBoxLayout(screenshots_group)
            
            self._screenshot_list = QListWidget()
            self._screenshot_list.setMaximumHeight(80)
            screenshots_layout.addWidget(self._screenshot_list)
            
            ss_btn_layout = QHBoxLayout()
            add_ss_btn = QPushButton("➕ Add Screenshot")
            add_ss_btn.clicked.connect(lambda: self._add_screenshot(dialog))
            ss_btn_layout.addWidget(add_ss_btn)
            
            remove_ss_btn = QPushButton("➖ Remove")
            remove_ss_btn.clicked.connect(self._remove_screenshot)
            ss_btn_layout.addWidget(remove_ss_btn)
            ss_btn_layout.addStretch()
            screenshots_layout.addLayout(ss_btn_layout)
            
            ss_note = QLabel("Screenshots help users understand your plugin. Max 5MB each, JPG/PNG/GIF/WebP.")
            ss_note.setStyleSheet("color: #888; font-size: 11px;")
            screenshots_layout.addWidget(ss_note)
            
            layout.addWidget(screenshots_group)
            
            # Manifest override fields (optional)
            override_group = QGroupBox("Plugin Details (auto-filled from manifest.json)")
            override_layout = QFormLayout(override_group)
            
            self._upload_name = QLineEdit()
            self._upload_name.setPlaceholderText("Auto-filled from manifest")
            override_layout.addRow("Name:", self._upload_name)
            
            self._upload_version = QLineEdit()
            self._upload_version.setPlaceholderText("1.0.0")
            override_layout.addRow("Version:", self._upload_version)
            
            self._upload_desc = QTextEdit()
            self._upload_desc.setMaximumHeight(60)
            self._upload_desc.setPlaceholderText("Brief description (plain text)...")
            override_layout.addRow("Short Desc:", self._upload_desc)
            
            # Long description with HTML support
            long_desc_label = QLabel("Long Description (HTML supported):")
            override_layout.addRow(long_desc_label)
            
            self._upload_long_desc = QTextEdit()
            self._upload_long_desc.setMaximumHeight(100)
            self._upload_long_desc.setPlaceholderText(
                "Detailed description of your plugin. You can use HTML tags like:\n"
                "<b>bold</b>, <i>italic</i>, <ul><li>lists</li></ul>, <a href=''>links</a>, etc."
            )
            override_layout.addRow("", self._upload_long_desc)
            
            self._upload_category = QComboBox()
            self._upload_category.addItems(["tools", "extraction", "modification", "adb", "fastboot", "utilities", "other"])
            override_layout.addRow("Category:", self._upload_category)
            
            # Icon selector
            icon_layout = QHBoxLayout()
            
            # Available icons organized by category
            plugin_icons = [
                # Tools & Utilities
                "🔧", "⚙️", "🛠️", "🔩", "⚡", "🔌",
                # Package & Plugin
                "🧩", "📦", "📥", "📤", "💾", "🗃️",
                # Android & Mobile
                "📱", "🤖", "💻", "🖥️", "📟", "🔋",
                # Files & Data
                "📁", "📂", "🗂️", "📄", "📝", "🔍",
                # Security & Development
                "🔒", "🔓", "🔑", "🛡️", "🐛", "💡",
                # Action & Status
                "🚀", "✨", "🔥", "💫", "⭐", "🎯",
                # Communication
                "📡", "🌐", "🔗", "📶", "🔔", "💬",
                # Creative
                "🎨", "🎬", "🖼️", "📸", "🎵", "🎮"
            ]
            
            self._upload_icon = QLineEdit()
            self._upload_icon.setMaximumWidth(50)
            self._upload_icon.setPlaceholderText("🔧")
            self._upload_icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self._upload_icon.setStyleSheet("font-size: 20px;")
            icon_layout.addWidget(self._upload_icon)
            
            # Icon picker button
            icon_picker_btn = QPushButton("Choose Icon...")
            icon_picker_btn.setMaximumWidth(100)
            
            def show_icon_picker():
                icon_dialog = QDialog(dialog)
                icon_dialog.setWindowTitle("Select Plugin Icon")
                icon_dialog.setMinimumSize(520, 480)
                icon_dlg_layout = QVBoxLayout(icon_dialog)
                
                icon_label = QLabel("Select an icon for your plugin:")
                icon_label.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 10px;")
                icon_dlg_layout.addWidget(icon_label)
                
                # Create grid of icons
                icon_scroll = QScrollArea()
                icon_scroll.setWidgetResizable(True)
                icon_scroll.setFrameShape(QFrame.Shape.NoFrame)
                
                icon_grid_widget = QWidget()
                icon_grid = QGridLayout(icon_grid_widget)
                icon_grid.setSpacing(8)
                
                cols = 6
                for i, icon in enumerate(plugin_icons):
                    btn = QPushButton(icon)
                    btn.setFixedSize(70, 70)
                    btn.setStyleSheet("""
                        QPushButton {
                            font-size: 36px;
                            border: 2px solid #444;
                            border-radius: 8px;
                            background-color: #2a2a2a;
                        }
                        QPushButton:hover {
                            background-color: #3a3a3a;
                            border-color: #4fc3f7;
                        }
                        QPushButton:pressed {
                            background-color: #4fc3f7;
                        }
                    """)
                    btn.clicked.connect(lambda checked, ic=icon: (
                        self._upload_icon.setText(ic),
                        icon_dialog.accept()
                    ))
                    icon_grid.addWidget(btn, i // cols, i % cols)
                
                icon_scroll.setWidget(icon_grid_widget)
                icon_dlg_layout.addWidget(icon_scroll)
                
                # Custom icon input
                custom_layout = QHBoxLayout()
                custom_label = QLabel("Or enter custom emoji:")
                custom_label.setStyleSheet("font-size: 13px;")
                custom_layout.addWidget(custom_label)
                custom_input = QLineEdit()
                custom_input.setMaximumWidth(80)
                custom_input.setPlaceholderText("🔧")
                custom_input.setStyleSheet("font-size: 28px; padding: 4px;")
                custom_layout.addWidget(custom_input)
                custom_btn = QPushButton("Use")
                custom_btn.setStyleSheet("padding: 8px 16px;")
                custom_btn.clicked.connect(lambda: (
                    self._upload_icon.setText(custom_input.text()) if custom_input.text() else None,
                    icon_dialog.accept() if custom_input.text() else None
                ))
                custom_layout.addWidget(custom_btn)
                custom_layout.addStretch()
                icon_dlg_layout.addLayout(custom_layout)
                
                # Close button
                close_btn = QPushButton("Cancel")
                close_btn.setStyleSheet("padding: 8px 20px;")
                close_btn.clicked.connect(icon_dialog.reject)
                icon_dlg_layout.addWidget(close_btn)
                
                icon_dialog.exec()
            
            icon_picker_btn.clicked.connect(show_icon_picker)
            icon_layout.addWidget(icon_picker_btn)
            
            icon_hint = QLabel("(Emoji displayed in plugin store)")
            icon_hint.setStyleSheet("color: #888; font-size: 11px;")
            icon_layout.addWidget(icon_hint)
            icon_layout.addStretch()
            
            override_layout.addRow("Icon:", icon_layout)
            
            # License with coming soon labels
            license_layout = QHBoxLayout()
            self._upload_license = QComboBox()
            self._upload_license.addItems(["free", "donation"])
            license_layout.addWidget(self._upload_license)
            
            paid_label = QLabel("💰 Paid (coming soon)")
            paid_label.setStyleSheet("color: #888; font-style: italic;")
            license_layout.addWidget(paid_label)
            license_layout.addStretch()
            override_layout.addRow("License:", license_layout)
            
            # Price with coming soon
            price_layout = QHBoxLayout()
            self._upload_price = QDoubleSpinBox()
            self._upload_price.setRange(0, 1000)
            self._upload_price.setPrefix("$ ")
            self._upload_price.setEnabled(False)
            price_layout.addWidget(self._upload_price)
            
            price_soon = QLabel("(coming soon)")
            price_soon.setStyleSheet("color: #888; font-style: italic;")
            price_layout.addWidget(price_soon)
            price_layout.addStretch()
            override_layout.addRow("Price:", price_layout)
            
            layout.addWidget(override_group)
            
            # External Dependencies Section (Binaries)
            deps_group = QGroupBox("🔧 External Dependencies (Optional)")
            deps_layout = QVBoxLayout(deps_group)
            
            deps_info = QLabel(
                "<b>If your plugin needs external binaries (like ADB, Fastboot, etc.):</b><br>"
                "Add direct download URLs below. The server will download and package them with your plugin.<br>"
                "<span style='color:#ff9800;'>⚠️ Only direct download URLs are accepted (not pages with download buttons)</span>"
            )
            deps_info.setTextFormat(Qt.TextFormat.RichText)
            deps_info.setWordWrap(True)
            deps_info.setStyleSheet("font-size: 11px; margin-bottom: 10px;")
            deps_layout.addWidget(deps_info)
            
            # Dependencies list
            self._ext_deps_list = QListWidget()
            self._ext_deps_list.setMaximumHeight(120)
            self._ext_deps_list.setStyleSheet("QListWidget::item { padding: 4px; }")
            deps_layout.addWidget(self._ext_deps_list)
            
            # Add dependency form
            add_dep_layout = QHBoxLayout()
            
            self._dep_name = QLineEdit()
            self._dep_name.setPlaceholderText("Name (e.g., adb.exe)")
            self._dep_name.setMaximumWidth(150)
            add_dep_layout.addWidget(self._dep_name)
            
            self._dep_url = QLineEdit()
            self._dep_url.setPlaceholderText("Direct download URL (https://...)")
            add_dep_layout.addWidget(self._dep_url)
            
            self._dep_path = QLineEdit()
            self._dep_path.setPlaceholderText("Target path (e.g., platform-tools/)")
            self._dep_path.setMaximumWidth(150)
            add_dep_layout.addWidget(self._dep_path)
            
            add_dep_btn = QPushButton("➕ Add")
            add_dep_btn.clicked.connect(self._add_external_dep)
            add_dep_layout.addWidget(add_dep_btn)
            
            deps_layout.addLayout(add_dep_layout)
            
            # Remove and Validate buttons
            dep_btn_layout = QHBoxLayout()
            
            remove_dep_btn = QPushButton("➖ Remove Selected")
            remove_dep_btn.clicked.connect(self._remove_external_dep)
            dep_btn_layout.addWidget(remove_dep_btn)
            
            validate_deps_btn = QPushButton("🔍 Validate URLs")
            validate_deps_btn.setToolTip("Check if all URLs are valid and downloadable")
            validate_deps_btn.clicked.connect(self._validate_external_deps)
            dep_btn_layout.addWidget(validate_deps_btn)
            
            dep_btn_layout.addStretch()
            deps_layout.addLayout(dep_btn_layout)
            
            # Validation status
            self._deps_status = QLabel("")
            self._deps_status.setWordWrap(True)
            self._deps_status.setStyleSheet("font-size: 11px;")
            deps_layout.addWidget(self._deps_status)
            
            # Example
            deps_example = QLabel(
                "<b>Examples:</b><br>"
                "• Name: <code>adb.exe</code> | URL: <code>https://dl.google.com/.../adb.exe</code> | Path: <code>platform-tools/</code><br>"
                "• Name: <code>mtkclient.zip</code> | URL: <code>https://github.com/.../archive/refs/heads/main.zip</code> | Path: <code>./</code>"
            )
            deps_example.setTextFormat(Qt.TextFormat.RichText)
            deps_example.setWordWrap(True)
            deps_example.setStyleSheet("color: #888; font-size: 10px; background: #1a1a1a; padding: 8px; border-radius: 4px;")
            deps_layout.addWidget(deps_example)
            
            layout.addWidget(deps_group)
            
            # Initialize external deps list
            self._external_deps = []
            
            # Git Clone Section (for cloning repos at install time)
            git_group = QGroupBox("📦 Git Repository Clone (Optional)")
            git_layout = QVBoxLayout(git_group)
            
            git_info = QLabel(
                "<b>Clone a Git repository when your plugin is installed:</b><br>"
                "The repository will be cloned to a subfolder in your plugin directory.<br>"
                "<span style='color:#4fc3f7;'>💡 Ideal for tools like mtkclient that need their own repo structure.</span><br>"
                "<span style='color:#ff9800;'>⚠️ List ALL pip packages in manifest.json <code>requirements</code> field - not here!</span>"
            )
            git_info.setTextFormat(Qt.TextFormat.RichText)
            git_info.setWordWrap(True)
            git_info.setStyleSheet("font-size: 11px; margin-bottom: 10px;")
            git_layout.addWidget(git_info)
            
            git_form = QFormLayout()
            
            self._git_repo_url = QLineEdit()
            self._git_repo_url.setPlaceholderText("https://github.com/user/repo.git")
            git_form.addRow("Repository URL:", self._git_repo_url)
            
            self._git_target_dir = QLineEdit()
            self._git_target_dir.setPlaceholderText("e.g., mtkclient (subfolder in plugin dir)")
            git_form.addRow("Target Directory:", self._git_target_dir)
            
            git_layout.addLayout(git_form)
            
            git_example = QLabel(
                "<b>Example manifest.json with git_clone:</b><br>"
                "<code style='font-size:10px;'>{<br>"
                "&nbsp;&nbsp;\"requirements\": [\"pyusb\", \"pycryptodome\"],<br>"
                "&nbsp;&nbsp;\"git_clone\": {<br>"
                "&nbsp;&nbsp;&nbsp;&nbsp;\"repo\": \"https://github.com/bkerler/mtkclient.git\",<br>"
                "&nbsp;&nbsp;&nbsp;&nbsp;\"target\": \"mtkclient\"<br>"
                "&nbsp;&nbsp;}<br>"
                "}</code>"
            )
            git_example.setTextFormat(Qt.TextFormat.RichText)
            git_example.setWordWrap(True)
            git_example.setStyleSheet("color: #888; font-size: 10px; background: #1a1a1a; padding: 8px; border-radius: 4px;")
            git_layout.addWidget(git_example)
            
            layout.addWidget(git_group)
            
            # Setup Commands Section (commands to run after git clone and pip install)
            setup_cmd_group = QGroupBox("⚡ Setup Commands (Optional)")
            setup_cmd_layout = QVBoxLayout(setup_cmd_group)
            
            setup_cmd_info = QLabel(
                "<b>Commands to run after git clone and pip install:</b><br>"
                "These bash-compatible commands run in the plugin directory after dependencies are installed.<br>"
                "<span style='color:#4fc3f7;'>💡 Useful for 'pip install .' to install cloned repos as packages.</span><br>"
                "<span style='color:#ff9800;'>⚠️ All commands are reviewed before your plugin is approved.</span>"
            )
            setup_cmd_info.setTextFormat(Qt.TextFormat.RichText)
            setup_cmd_info.setWordWrap(True)
            setup_cmd_info.setStyleSheet("font-size: 11px; margin-bottom: 10px;")
            setup_cmd_layout.addWidget(setup_cmd_info)
            
            self._setup_commands = QTextEdit()
            self._setup_commands.setMaximumHeight(80)
            self._setup_commands.setPlaceholderText(
                "Enter one command per line, e.g.:\n"
                "pip install .\n"
                "python setup.py build"
            )
            setup_cmd_layout.addWidget(self._setup_commands)
            
            setup_cmd_example = QLabel(
                "<b>Example manifest.json with setup_commands:</b><br>"
                "<code style='font-size:10px;'>{<br>"
                "&nbsp;&nbsp;\"git_clone\": {\"repo\": \"https://github.com/bkerler/mtkclient.git\", \"target\": \"mtkclient\"},<br>"
                "&nbsp;&nbsp;\"setup_commands\": [\"pip install .\"]<br>"
                "}</code>"
            )
            setup_cmd_example.setTextFormat(Qt.TextFormat.RichText)
            setup_cmd_example.setWordWrap(True)
            setup_cmd_example.setStyleSheet("color: #888; font-size: 10px; background: #1a1a1a; padding: 8px; border-radius: 4px;")
            setup_cmd_layout.addWidget(setup_cmd_example)
            
            layout.addWidget(setup_cmd_group)
            
            # Legal Agreement Section
            legal_group = QGroupBox("📜 Developer Agreement & License")
            legal_layout = QVBoxLayout(legal_group)
            
            legal_text = QTextEdit()
            legal_text.setReadOnly(True)
            legal_text.setMaximumHeight(180)
            legal_text.setStyleSheet("background-color: #1a1a1a; color: #ccc; font-size: 10px;")
            legal_text.setHtml("""
<p><b>IMAGE ANARCHY PLUGIN DEVELOPER AGREEMENT</b></p>
<p><i>Last Updated: January 2026</i></p>

<p>By submitting a plugin to the Image Anarchy Plugin Store ("Store"), you ("Developer") agree to the following terms and conditions:</p>

<p><b>1. GRANT OF LICENSE</b><br>
For all plugins submitted with a "free" or "donation" license type, Developer hereby grants to Image Anarchy ("IA"), its successors, and assigns, an irrevocable, perpetual, worldwide, royalty-free, non-exclusive license to use, reproduce, modify, distribute, publicly display, publicly perform, sublicense, and create derivative works from the submitted plugin. Upon submission, such plugins become the property of Image Anarchy.</p>

<p><b>2. DISCLAIMER OF LIABILITY</b><br>
THE PLUGIN STORE AND ALL PLUGINS ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED. IMAGE ANARCHY DISCLAIMS ALL LIABILITY FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, ARISING OUT OF OR RELATED TO THE USE OR INABILITY TO USE ANY PLUGIN, REGARDLESS OF WHETHER SUCH DAMAGES WERE FORESEEABLE OR WHETHER IMAGE ANARCHY WAS ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>

<p><b>3. INDEMNIFICATION</b><br>
Developer agrees to indemnify, defend, and hold harmless Image Anarchy, its officers, directors, employees, agents, and affiliates from and against any and all claims, damages, obligations, losses, liabilities, costs, and expenses arising from: (a) Developer's plugin; (b) Developer's violation of any third-party rights; (c) Developer's violation of any applicable law or regulation.</p>

<p><b>4. CONTENT RESPONSIBILITY</b><br>
Developer is solely responsible for ensuring that submitted plugins do not infringe upon any intellectual property rights, contain malicious code, or violate any applicable laws. Image Anarchy reserves the right to remove any plugin at its sole discretion without notice.</p>

<p><b>5. TAKEDOWN REQUESTS</b><br>
Developers may submit takedown requests to: <b>requests@imageanarchy.com</b><br>
Developer agrees to allow Image Anarchy a minimum of forty-eight (48) hours to process and act upon any takedown request. Paid plugins (when available) will include a self-service removal option.</p>

<p><b>6. LIMITATION OF LIABILITY</b><br>
IN NO EVENT SHALL IMAGE ANARCHY'S TOTAL LIABILITY TO DEVELOPER EXCEED ZERO DOLLARS ($0.00 USD). IMAGE ANARCHY SHALL NOT BE LIABLE FOR ANY LOST PROFITS, LOST DATA, OR ANY FORM OF CONSEQUENTIAL DAMAGES.</p>

<p><b>7. GOVERNING LAW</b><br>
This Agreement shall be governed by the laws applicable to software distribution platforms, without regard to conflict of law principles.</p>

<p><b>8. ENTIRE AGREEMENT</b><br>
This Agreement constitutes the entire agreement between Developer and Image Anarchy regarding plugin submissions and supersedes all prior agreements and understandings.</p>

<p style="color:#ff9800;"><b>BY SIGNING BELOW, YOU ACKNOWLEDGE THAT YOU HAVE READ, UNDERSTOOD, AND AGREE TO BE BOUND BY ALL TERMS OF THIS AGREEMENT.</b></p>
            """)
            legal_layout.addWidget(legal_text)
            
            # Signature canvas
            sig_label = QLabel("✍️ Sign below with your mouse or finger to agree:")
            sig_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
            legal_layout.addWidget(sig_label)
            
            # Signature widget (custom drawing canvas)
            from PyQt6.QtGui import QPainterPath, QPainter, QPen, QColor
            
            class SignatureCanvas(QWidget):
                def __init__(self, parent=None):
                    super().__init__(parent)
                    self.setMinimumSize(400, 80)
                    self.setMaximumHeight(80)
                    self.setStyleSheet("background-color: #f5f5f5; border: 2px solid #444; border-radius: 4px;")
                    self.path = QPainterPath()
                    self.last_point = None
                    self.has_signature = False
                
                def clear(self):
                    self.path = QPainterPath()
                    self.last_point = None
                    self.has_signature = False
                    self.update()
                
                def paintEvent(self, event):
                    painter = QPainter(self)
                    painter.setRenderHint(QPainter.RenderHint.Antialiasing)
                    painter.fillRect(self.rect(), QColor("#f5f5f5"))
                    
                    if not self.has_signature:
                        painter.setPen(QColor("#aaa"))
                        painter.drawText(self.rect(), Qt.AlignmentFlag.AlignCenter, "Sign here...")
                    
                    painter.setPen(QPen(QColor("#1a1a1a"), 2))
                    painter.drawPath(self.path)
                
                def mousePressEvent(self, event):
                    if event.button() == Qt.MouseButton.LeftButton:
                        self.last_point = event.position()
                        self.path.moveTo(self.last_point)
                        self.has_signature = True
                
                def mouseMoveEvent(self, event):
                    if event.buttons() & Qt.MouseButton.LeftButton and self.last_point:
                        new_point = event.position()
                        self.path.lineTo(new_point)
                        self.last_point = new_point
                        self.update()
                
                def mouseReleaseEvent(self, event):
                    self.last_point = None
            
            self._signature_canvas = SignatureCanvas()
            legal_layout.addWidget(self._signature_canvas)
            
            # Clear signature button
            clear_sig_btn = QPushButton("🗑️ Clear Signature")
            clear_sig_btn.setMaximumWidth(150)
            clear_sig_btn.clicked.connect(self._signature_canvas.clear)
            legal_layout.addWidget(clear_sig_btn)
            
            layout.addWidget(legal_group)
            
            # Security notice
            security_notice = QLabel(
                "🔒 <b>Security Notice:</b> All plugins are scanned for malware before acceptance. "
                "Plugins containing executables (.exe, .dll) may take 1-2 minutes to upload while scanning completes."
            )
            security_notice.setWordWrap(True)
            security_notice.setStyleSheet("color: #888; font-size: 11px; padding: 8px; background-color: rgba(33, 150, 243, 0.1); border-radius: 4px;")
            layout.addWidget(security_notice)
            
            # Status
            self._upload_status = QLabel("")
            self._upload_status.setWordWrap(True)
            layout.addWidget(self._upload_status)
            
            layout.addStretch()
            
            scroll.setWidget(scroll_widget)
            
            dialog_layout = QVBoxLayout(dialog)
            dialog_layout.addWidget(scroll)
            
            # Buttons
            btn_layout = QHBoxLayout()
            btn_layout.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            btn_layout.addWidget(cancel_btn)
            
            upload_btn = QPushButton("📤 Upload Plugin")
            upload_btn.setObjectName("upload_btn")  # Set object name for finding later
            upload_btn.setStyleSheet("background-color: #4CAF50; padding: 8px 20px;")
            upload_btn.clicked.connect(lambda: self._do_upload(dialog))
            btn_layout.addWidget(upload_btn)
            
            dialog_layout.addLayout(btn_layout)
            
            # Initialize screenshot list
            self._screenshot_paths = []
            
            dialog.exec()
        
        def _add_external_dep(self):
            """Add an external dependency to the list."""
            name = self._dep_name.text().strip()
            url = self._dep_url.text().strip()
            target_path = self._dep_path.text().strip() or "./"
            
            if not name:
                self._deps_status.setText("⚠️ Please enter a dependency name")
                self._deps_status.setStyleSheet("color: #f44336;")
                return
            
            if not url:
                self._deps_status.setText("⚠️ Please enter a download URL")
                self._deps_status.setStyleSheet("color: #f44336;")
                return
            
            if not url.startswith(("http://", "https://")):
                self._deps_status.setText("⚠️ URL must start with http:// or https://")
                self._deps_status.setStyleSheet("color: #f44336;")
                return
            
            # Add to list
            dep = {"name": name, "url": url, "path": target_path, "validated": False}
            self._external_deps.append(dep)
            
            item_text = f"📦 {name} → {target_path} | {url[:60]}..."
            self._ext_deps_list.addItem(item_text)
            
            # Clear inputs
            self._dep_name.clear()
            self._dep_url.clear()
            self._dep_path.clear()
            
            self._deps_status.setText(f"✓ Added {name}")
            self._deps_status.setStyleSheet("color: #4CAF50;")
        
        def _remove_external_dep(self):
            """Remove selected external dependency."""
            current = self._ext_deps_list.currentRow()
            if current >= 0:
                self._ext_deps_list.takeItem(current)
                removed = self._external_deps.pop(current)
                self._deps_status.setText(f"Removed {removed['name']}")
                self._deps_status.setStyleSheet("color: #888;")
        
        def _validate_external_deps(self):
            """Validate all external dependency URLs."""
            if not self._external_deps:
                self._deps_status.setText("No dependencies to validate")
                self._deps_status.setStyleSheet("color: #888;")
                return
            
            self._deps_status.setText("🔄 Validating URLs...")
            self._deps_status.setStyleSheet("color: #4fc3f7;")
            QApplication.processEvents()
            
            import urllib.request
            import urllib.error
            
            valid_count = 0
            errors = []
            
            for i, dep in enumerate(self._external_deps):
                try:
                    # HEAD request to check if URL is valid and downloadable
                    req = urllib.request.Request(dep['url'], method='HEAD')
                    req.add_header('User-Agent', 'ImageAnarchy/1.1')
                    
                    with urllib.request.urlopen(req, timeout=10) as response:
                        status = response.getcode()
                        content_type = response.headers.get('Content-Type', '')
                        content_length = response.headers.get('Content-Length', 'unknown')
                        
                        if status == 200:
                            dep['validated'] = True
                            dep['size'] = content_length
                            valid_count += 1
                            
                            # Update list item with checkmark
                            item = self._ext_deps_list.item(i)
                            if item:
                                size_str = f" ({int(content_length) // 1024 // 1024}MB)" if content_length != 'unknown' else ""
                                item.setText(f"✅ {dep['name']} → {dep['path']}{size_str}")
                        else:
                            dep['validated'] = False
                            errors.append(f"{dep['name']}: HTTP {status}")
                            
                            item = self._ext_deps_list.item(i)
                            if item:
                                item.setText(f"❌ {dep['name']} - HTTP {status}")
                                
                except urllib.error.HTTPError as e:
                    dep['validated'] = False
                    errors.append(f"{dep['name']}: HTTP {e.code}")
                    item = self._ext_deps_list.item(i)
                    if item:
                        item.setText(f"❌ {dep['name']} - HTTP {e.code}")
                        
                except urllib.error.URLError as e:
                    dep['validated'] = False
                    errors.append(f"{dep['name']}: {str(e.reason)}")
                    item = self._ext_deps_list.item(i)
                    if item:
                        item.setText(f"❌ {dep['name']} - Connection failed")
                        
                except Exception as e:
                    dep['validated'] = False
                    errors.append(f"{dep['name']}: {str(e)}")
                    item = self._ext_deps_list.item(i)
                    if item:
                        item.setText(f"❌ {dep['name']} - Error")
                
                QApplication.processEvents()
            
            if valid_count == len(self._external_deps):
                self._deps_status.setText(f"✅ All {valid_count} URLs validated successfully!")
                self._deps_status.setStyleSheet("color: #4CAF50;")
            else:
                self._deps_status.setText(f"⚠️ {valid_count}/{len(self._external_deps)} valid. Errors: {'; '.join(errors)}")
                self._deps_status.setStyleSheet("color: #f44336;")
        
        def _add_screenshot(self, dialog):
            """Add a screenshot to the upload with image validation."""
            if len(self._screenshot_paths) >= 5:
                QMessageBox.warning(dialog, "Limit Reached", "Maximum 5 screenshots allowed.")
                return
            
            file_path, _ = QFileDialog.getOpenFileName(
                dialog,
                "Select Screenshot",
                "",
                "All Files (*.*)"
            )
            
            if file_path:
                # Validate that it's actually an image using magic bytes
                def is_valid_image(filepath):
                    """Check if file is a valid image using magic bytes, not extension."""
                    try:
                        with open(filepath, 'rb') as f:
                            header = f.read(32)
                        
                        # JPEG magic bytes
                        if header[:3] == b'\xff\xd8\xff':
                            return True, "JPEG"
                        # PNG magic bytes
                        if header[:8] == b'\x89PNG\r\n\x1a\n':
                            return True, "PNG"
                        # GIF magic bytes
                        if header[:6] in (b'GIF87a', b'GIF89a'):
                            return True, "GIF"
                        # WebP magic bytes (RIFF....WEBP)
                        if header[:4] == b'RIFF' and header[8:12] == b'WEBP':
                            return True, "WebP"
                        # BMP magic bytes
                        if header[:2] == b'BM':
                            return True, "BMP"
                        
                        return False, None
                    except Exception:
                        return False, None
                
                is_image, img_type = is_valid_image(file_path)
                
                if not is_image:
                    QMessageBox.warning(
                        dialog, 
                        "Invalid Image",
                        "The selected file is not a valid image.\n\n"
                        "Supported formats: JPEG, PNG, GIF, WebP, BMP\n\n"
                        "Note: Files are validated by their content, not extension."
                    )
                    return
                
                # Check file size (max 5MB)
                file_size = os.path.getsize(file_path)
                if file_size > 5 * 1024 * 1024:
                    QMessageBox.warning(
                        dialog,
                        "File Too Large",
                        f"Screenshot is too large ({file_size / 1024 / 1024:.1f}MB).\n\n"
                        "Maximum size: 5MB"
                    )
                    return
                
                self._screenshot_paths.append(file_path)
                self._screenshot_list.addItem(f"{os.path.basename(file_path)} ({img_type})")
        
        def _remove_screenshot(self):
            """Remove selected screenshot."""
            current = self._screenshot_list.currentRow()
            if current >= 0:
                self._screenshot_list.takeItem(current)
                self._screenshot_paths.pop(current)
        
        def _browse_upload_file(self, dialog):
            """Browse for plugin zip file."""
            file_path, _ = QFileDialog.getOpenFileName(
                dialog,
                "Select Plugin ZIP",
                "",
                "ZIP Files (*.zip)"
            )
            
            if file_path:
                self._upload_file_path.setText(file_path)
                
                # Try to read manifest from zip
                try:
                    import zipfile
                    with zipfile.ZipFile(file_path, 'r') as zf:
                        # Find manifest.json
                        for name in zf.namelist():
                            if name.endswith('manifest.json'):
                                with zf.open(name) as mf:
                                    manifest = json.load(mf)
                                    self._upload_name.setText(manifest.get('name', ''))
                                    self._upload_version.setText(manifest.get('version', '1.0'))
                                    self._upload_desc.setPlainText(manifest.get('description', ''))
                                    
                                    # Long description
                                    if manifest.get('long_description'):
                                        self._upload_long_desc.setPlainText(manifest.get('long_description', ''))
                                    
                                    # Set category
                                    cat = manifest.get('category', 'tools')
                                    idx = self._upload_category.findText(cat, Qt.MatchFlag.MatchFixedString)
                                    if idx >= 0:
                                        self._upload_category.setCurrentIndex(idx)
                                    
                                    # Set icon
                                    icon = manifest.get('icon', '🔧')
                                    self._upload_icon.setText(icon)
                                    
                                    # Set license
                                    lic = manifest.get('license_type', 'free')
                                    idx = self._upload_license.findText(lic, Qt.MatchFlag.MatchFixedString)
                                    if idx >= 0:
                                        self._upload_license.setCurrentIndex(idx)
                                    
                                    self._upload_price.setValue(manifest.get('price', 0))
                                    
                                    # Set git_clone if present
                                    git_clone = manifest.get('git_clone', {})
                                    if git_clone:
                                        self._git_repo_url.setText(git_clone.get('repo', ''))
                                        self._git_target_dir.setText(git_clone.get('target', ''))
                                    
                                    # Set setup_commands if present
                                    setup_commands = manifest.get('setup_commands', [])
                                    if setup_commands and isinstance(setup_commands, list):
                                        self._setup_commands.setPlainText('\n'.join(setup_commands))

                                    # Load bundled_binaries into external deps list
                                    bundled_binaries = manifest.get('bundled_binaries', [])
                                    if bundled_binaries:
                                        # Clear existing entries
                                        self._ext_deps_list.clear()
                                        self._external_deps = []

                                        for binary in bundled_binaries:
                                            if isinstance(binary, str):
                                                # Simple URL string
                                                if binary.startswith('http://') or binary.startswith('https://'):
                                                    name = binary.split('/')[-1] or 'binary'
                                                    dep_entry = {
                                                        'name': name,
                                                        'url': binary,
                                                        'path': './',
                                                        'validated': False
                                                    }
                                                    self._external_deps.append(dep_entry)
                                                    self._ext_deps_list.addItem(f"📦 {name} → {binary}")
                                            elif isinstance(binary, dict):
                                                # Object with url, target_path, etc.
                                                url = binary.get('url', '')
                                                target_path = binary.get('target_path', './')
                                                name = target_path.split('/')[-1] if target_path else url.split('/')[-1]
                                                if not name:
                                                    name = 'binary'
                                                dep_entry = {
                                                    'name': name,
                                                    'url': url,
                                                    'path': os.path.dirname(target_path) if target_path else './',
                                                    'validated': False
                                                }
                                                if binary.get('sha256'):
                                                    dep_entry['sha256'] = binary.get('sha256')
                                                self._external_deps.append(dep_entry)
                                                self._ext_deps_list.addItem(f"📦 {name} → {url[:60]}...")

                                    # Show requirements info in status
                                    reqs = manifest.get('requirements', [])
                                    status_parts = ["✓ Manifest loaded from ZIP"]
                                    if reqs:
                                        status_parts.append(f"📦 {len(reqs)} pip packages")
                                    if git_clone:
                                        status_parts.append(f"📥 Git clone: {git_clone.get('target', 'repo')}")
                                    if setup_commands:
                                        status_parts.append(f"⚡ {len(setup_commands)} setup command(s)")
                                    if bundled_binaries:
                                        status_parts.append(f"⬇️ {len(bundled_binaries)} binary download(s)")

                                    self._upload_status.setText(" | ".join(status_parts))
                                    self._upload_status.setStyleSheet("color: #4CAF50;")
                                break
                except Exception as e:
                    self._upload_status.setText(f"Could not read manifest: {str(e)}")
                    self._upload_status.setStyleSheet("color: #ff9800;")
        
        def _do_upload(self, dialog):
            """Perform the plugin upload."""
            # Check signature first
            if not hasattr(self, '_signature_canvas') or not self._signature_canvas.has_signature:
                self._upload_status.setText("⚠️ Please sign the Developer Agreement to continue")
                self._upload_status.setStyleSheet("color: #f44336;")
                return
            
            file_path = self._upload_file_path.text()
            
            if not file_path or not os.path.exists(file_path):
                self._upload_status.setText("Please select a plugin ZIP file")
                self._upload_status.setStyleSheet("color: #f44336;")
                return
            
            name = self._upload_name.text().strip()
            if not name:
                self._upload_status.setText("Please enter a plugin name")
                self._upload_status.setStyleSheet("color: #f44336;")
                return
            
            # Check if external deps are validated (if any exist)
            external_deps = getattr(self, '_external_deps', [])
            if external_deps:
                unvalidated = [d for d in external_deps if not d.get('validated', False)]
                if unvalidated:
                    self._upload_status.setText("⚠️ Please validate all external dependency URLs first")
                    self._upload_status.setStyleSheet("color: #f44336;")
                    return
            
            # Build manifest data
            manifest = {
                'name': name,
                'version': self._upload_version.text().strip() or '1.0.0',
                'description': self._upload_desc.toPlainText().strip(),
                'long_description': self._upload_long_desc.toPlainText().strip(),
                'category': self._upload_category.currentText(),
                'icon': self._upload_icon.text().strip() or '🔧',
                'license_type': self._upload_license.currentText(),
                'price': 0,  # Paid plugins coming soon
                'external_dependencies': external_deps  # Include validated dependencies
            }
            
            # Add git_clone if specified
            git_repo = self._git_repo_url.text().strip()
            if git_repo:
                git_clone_data = {
                    'repo': git_repo,
                    'target': self._git_target_dir.text().strip() or None
                }
                manifest['git_clone'] = git_clone_data
            
            # Show detailed upload progress message
            self._upload_status.setText("📤 Uploading plugin...\n🔒 Security scanning in progress (may take 1-2 minutes for plugins with binaries)")
            self._upload_status.setStyleSheet("color: #2196F3;")
            
            # Disable upload button during process
            upload_btn = dialog.findChild(QPushButton, "upload_btn")
            if upload_btn:
                upload_btn.setEnabled(False)
                upload_btn.setText("⏳ Scanning...")
            
            # Get screenshot paths
            screenshots = getattr(self, '_screenshot_paths', [])
            
            # Run upload in background thread to prevent UI freeze
            self._upload_thread = PluginUploadThread(plugin_store_api, manifest, file_path, screenshots)
            self._upload_dialog = dialog  # Store reference for callback
            self._upload_name_text = name  # Store for success message
            
            def on_upload_progress(msg):
                self._upload_status.setText(msg + "\n🔒 Security scanning in progress...")
            
            def on_upload_finished(result):
                # Re-enable upload button
                if upload_btn:
                    upload_btn.setEnabled(True)
                    upload_btn.setText("📤 Upload Plugin")
                
                if 'error' in result:
                    # Check for re-login needed
                    if result.get('code') == 'USER_NOT_FOUND':
                        self._upload_status.setText("❌ Session expired. Please log out and log in again.")
                    else:
                        self._upload_status.setText(f"❌ Upload failed: {result['error']}")
                    self._upload_status.setStyleSheet("color: #f44336;")
                else:
                    self._upload_dialog.accept()
                    ss_count = result.get('screenshots', 0)
                    deps_count = result.get('external_deps', 0)
                    
                    deps_msg = f"\nExternal Dependencies: {deps_count} (will be downloaded during review)\n" if deps_count else ""
                    
                    QMessageBox.information(
                        self,
                        "Plugin Submitted",
                        f"Your plugin '{self._upload_name_text}' has been submitted!\n\n"
                        f"Screenshots: {ss_count}{deps_msg}\n"
                        "It will be reviewed by an admin before appearing in the store.\n"
                        "External dependencies will be downloaded and validated during review.\n\n"
                        "You'll receive an email when it's approved.\n\n"
                        "📜 By signing, you agreed to the Developer Agreement.\n"
                        "Free plugins become property of Image Anarchy.\n"
                        "Takedown requests: requests@imageanarchy.com (48hr response)"
                    )
            
            self._upload_thread.progress.connect(on_upload_progress)
            self._upload_thread.finished.connect(on_upload_finished)
            self._upload_thread.start()

    # =========================================================================
    # FORUM TAB - Embedded Forum with QWebEngineView
    # =========================================================================
    
    class ForumTab(QWidget):
        """Forum tab with embedded web view for forum.imageanarchy.com"""
        
        def __init__(self, parent=None):
            super().__init__(parent)
            self._setup_ui()
            
        def _setup_ui(self):
            layout = QVBoxLayout(self)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setSpacing(0)
            
            # Mini toolbar for forum controls
            toolbar = QHBoxLayout()
            toolbar.setContentsMargins(8, 4, 8, 4)
            toolbar.setSpacing(8)
            
            self.back_btn = QPushButton("◀")
            self.back_btn.setFixedSize(32, 28)
            self.back_btn.setToolTip("Back")
            self.back_btn.setEnabled(False)
            toolbar.addWidget(self.back_btn)
            
            self.forward_btn = QPushButton("▶")
            self.forward_btn.setFixedSize(32, 28)
            self.forward_btn.setToolTip("Forward")
            self.forward_btn.setEnabled(False)
            toolbar.addWidget(self.forward_btn)
            
            self.refresh_btn = QPushButton("🔄")
            self.refresh_btn.setFixedSize(32, 28)
            self.refresh_btn.setToolTip("Refresh")
            toolbar.addWidget(self.refresh_btn)
            
            self.home_btn = QPushButton("🏠")
            self.home_btn.setFixedSize(32, 28)
            self.home_btn.setToolTip("Forum Home")
            toolbar.addWidget(self.home_btn)
            
            toolbar.addStretch()
            
            self.loading_label = QLabel("")
            self.loading_label.setStyleSheet("color: #4fc3f7; font-size: 11px;")
            toolbar.addWidget(self.loading_label)
            
            self.open_external_btn = QPushButton("🌐 Open in Browser")
            self.open_external_btn.setToolTip("Open forum in external browser")
            toolbar.addWidget(self.open_external_btn)
            
            toolbar_widget = QWidget()
            toolbar_widget.setLayout(toolbar)
            toolbar_widget.setStyleSheet("background: #252535;")
            layout.addWidget(toolbar_widget)
            
            # Web view or fallback - use the pre-imported _QWebEngineView class
            self._has_webview = False
            self._webview_error = None
            
            if _webengine_available and _QWebEngineView is not None:
                try:
                    self.webview = _QWebEngineView()
                    self.webview.setUrl(QUrl("https://forum.imageanarchy.com"))
                    
                    # Connect signals
                    self.webview.loadStarted.connect(self._on_load_started)
                    self.webview.loadFinished.connect(self._on_load_finished)
                    self.webview.loadProgress.connect(self._on_load_progress)
                    
                    self.back_btn.clicked.connect(self.webview.back)
                    self.forward_btn.clicked.connect(self.webview.forward)
                    self.refresh_btn.clicked.connect(self.webview.reload)
                    self.home_btn.clicked.connect(lambda: self.webview.setUrl(QUrl("https://forum.imageanarchy.com")))
                    
                    # Update nav buttons on history change
                    self.webview.urlChanged.connect(self._update_nav_buttons)
                    
                    layout.addWidget(self.webview, 1)
                    self._has_webview = True
                    
                except Exception as e:
                    self._webview_error = f"Error: {e}"
            else:
                self._webview_error = "PyQt6-WebEngine not installed."
            
            if not self._has_webview:
                # Fallback UI
                fallback = QWidget()
                fallback_layout = QVBoxLayout(fallback)
                fallback_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
                
                icon_label = QLabel("🌐")
                icon_label.setStyleSheet("font-size: 64px;")
                icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                fallback_layout.addWidget(icon_label)
                
                title = QLabel("Image Anarchy Forum")
                title.setStyleSheet("font-size: 24px; font-weight: bold; color: #4fc3f7;")
                title.setAlignment(Qt.AlignmentFlag.AlignCenter)
                fallback_layout.addWidget(title)
                
                error_msg = self._webview_error or "PyQt6-WebEngine not installed."
                desc = QLabel(f"{error_msg}\nInstall with: pip install PyQt6-WebEngine")
                desc.setStyleSheet("font-size: 14px; color: #888; margin: 20px;")
                desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
                desc.setWordWrap(True)
                fallback_layout.addWidget(desc)
                
                layout.addWidget(fallback, 1)
            
            # External browser button always works
            self.open_external_btn.clicked.connect(lambda: __import__('webbrowser').open("https://forum.imageanarchy.com"))
            
        def _on_load_started(self):
            self.loading_label.setText("Loading...")
            
        def _on_load_finished(self, ok):
            self.loading_label.setText("" if ok else "Load failed")
            self._update_nav_buttons()
            
        def _on_load_progress(self, progress):
            if progress < 100:
                self.loading_label.setText(f"Loading... {progress}%")
            else:
                self.loading_label.setText("")
                
        def _update_nav_buttons(self):
            if self._has_webview:
                history = self.webview.history()
                self.back_btn.setEnabled(history.canGoBack())
                self.forward_btn.setEnabled(history.canGoForward())

    # =========================================================================
    # CHAT TAB - Full-Featured Community Chat
    # =========================================================================
    
    class ChatTab(QWidget):
        """Full-featured community chat tab with dock/undock and Remote Play support.
        
        Remote Play Roles:
            HOST         = User sharing their device for repair
            PROFESSIONAL = Technician operating Host's tools remotely
        """
        
        def __init__(self, parent=None):
            super().__init__(parent)
            self.main_window = parent
            self._floating_window = None
            self._is_docked = True
            self._chat_widget = None
            # Remote Play state
            self._share_session = None          # DeviceShareSession (Host side)
            self._active_device_session = None  # Session info when Professional connects
            self._remote_console = None         # Floating master console window
            self._pro_socket = None             # Professional's socket to remote-ctl
            self._trust_mode = 'ask'            # ask | trust_read | trust_all
            self._screen_viewer = None          # ScreenViewerWidget (Professional side)
            self._setup_ui()
            
        def _setup_ui(self):
            layout = QVBoxLayout(self)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setSpacing(0)
            
            # Main content splitter (features | chat)
            self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
            
            # Left side - Feature buttons panel
            features_panel = self._create_features_panel()
            self.main_splitter.addWidget(features_panel)
            
            # Right side - Chat area
            chat_panel = self._create_chat_panel()
            self.main_splitter.addWidget(chat_panel)
            
            # Set initial sizes (features: 350px, chat: rest)
            self.main_splitter.setSizes([350, 800])
            
            layout.addWidget(self.main_splitter)
            
        def _create_features_panel(self):
            """Create the left panel with large feature buttons."""
            panel = QWidget()
            panel.setMinimumWidth(300)
            panel.setMaximumWidth(450)
            panel.setStyleSheet("background: #1e1e2e;")
            
            layout = QVBoxLayout(panel)
            layout.setContentsMargins(20, 20, 20, 20)
            layout.setSpacing(16)
            
            # Header
            header = QLabel("💬 Community Hub")
            header.setStyleSheet("font-size: 24px; font-weight: bold; color: #4fc3f7; margin-bottom: 10px;")
            layout.addWidget(header)
            
            desc = QLabel("Connect with the Image Anarchy community")
            desc.setStyleSheet("font-size: 12px; color: #888; margin-bottom: 20px;")
            desc.setWordWrap(True)
            layout.addWidget(desc)
            
            # Feature buttons grid
            buttons_widget = QWidget()
            buttons_layout = QGridLayout(buttons_widget)
            buttons_layout.setSpacing(12)
            
            # Button definitions: (icon, title, subtitle, enabled, callback)
            self.feature_buttons = {}
            features = [
                ("💬", "Chat", "Join conversations", True, self._focus_chat),
                ("📨", "Invites", "Room invitations", True, self._show_invites),
                ("📁", "Files", "Shared attachments", True, self._show_shared_files),
                ("👥", "Members", "Online users", True, self._show_members),
                ("🔧", "Share Device", "Host: let pros help", True, self._share_device),
                ("⚙️", "Settings", "Chat preferences", True, self._show_settings),
            ]
            
            for i, (icon, title, subtitle, enabled, callback) in enumerate(features):
                btn = self._create_feature_button(icon, title, subtitle, enabled)
                if callback:
                    btn.clicked.connect(callback)
                self.feature_buttons[title] = btn
                buttons_layout.addWidget(btn, i // 2, i % 2)
            
            layout.addWidget(buttons_widget)
            
            # Remote Play section
            layout.addSpacing(20)
            
            remote_header = QLabel("🔌 Remote Play")
            remote_header.setStyleSheet("font-size: 14px; font-weight: bold; color: #4fc3f7; margin-top: 10px;")
            layout.addWidget(remote_header)
            
            self._share_status = QLabel("⚫ Not sharing")
            self._share_status.setStyleSheet("font-size: 11px; color: #888; margin: 4px 0;")
            self._share_status.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self._share_status.customContextMenuRequested.connect(self._share_status_context_menu)
            layout.addWidget(self._share_status)
            
            self.remote_connect_btn = QPushButton("📱 Connect as Professional")
            self.remote_connect_btn.setStyleSheet("""
                QPushButton {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #1a3a4a, stop:1 #2a2a3a);
                    color: #4fc3f7;
                    border: 1px solid #4fc3f7;
                    border-radius: 8px;
                    padding: 15px;
                    font-size: 14px;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #2a4a5a, stop:1 #3a3a4a);
                    border-color: #81d4fa;
                }
                QPushButton:pressed {
                    background: #1a2a3a;
                }
            """)
            self.remote_connect_btn.setToolTip("Connect to a Host's shared device as a Professional")
            self.remote_connect_btn.clicked.connect(self._connect_to_device)
            layout.addWidget(self.remote_connect_btn)
            
            layout.addStretch()
            
            # Window controls at bottom
            controls = QHBoxLayout()
            controls.setSpacing(8)
            
            self.undock_btn = QPushButton("📤 Undock Chat")
            self.undock_btn.setToolTip("Open chat in a floating window")
            self.undock_btn.clicked.connect(self._toggle_dock)
            controls.addWidget(self.undock_btn)
            
            self.stay_on_top_btn = QPushButton("📌")
            self.stay_on_top_btn.setFixedWidth(40)
            self.stay_on_top_btn.setCheckable(True)
            self.stay_on_top_btn.setToolTip("Keep floating window on top")
            self.stay_on_top_btn.setEnabled(False)
            self.stay_on_top_btn.clicked.connect(self._toggle_stay_on_top)
            controls.addWidget(self.stay_on_top_btn)
            
            controls.addStretch()
            
            layout.addLayout(controls)
            
            return panel
            
        def _create_feature_button(self, icon, title, subtitle, enabled=True):
            """Create a large feature button with icon, title and subtitle."""
            btn = QPushButton()
            btn.setMinimumSize(140, 100)
            
            # Create layout for button content
            btn_layout = QVBoxLayout(btn)
            btn_layout.setContentsMargins(10, 10, 10, 10)
            btn_layout.setSpacing(4)
            
            icon_label = QLabel(icon)
            icon_label.setStyleSheet("font-size: 28px;")
            icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            btn_layout.addWidget(icon_label)
            
            title_label = QLabel(title)
            title_label.setStyleSheet("font-size: 13px; font-weight: bold;")
            title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            btn_layout.addWidget(title_label)
            
            sub_label = QLabel(subtitle)
            sub_label.setStyleSheet("font-size: 10px; color: #888;")
            sub_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            btn_layout.addWidget(sub_label)
            
            if enabled:
                btn.setStyleSheet("""
                    QPushButton {
                        background: #2a2a3a;
                        border: 1px solid #3a3a4a;
                        border-radius: 12px;
                    }
                    QPushButton:hover {
                        background: #3a3a4a;
                        border-color: #4fc3f7;
                    }
                    QPushButton:pressed {
                        background: #4a4a5a;
                    }
                """)
            else:
                btn.setEnabled(False)
                btn.setStyleSheet("""
                    QPushButton {
                        background: #222;
                        border: 1px dashed #333;
                        border-radius: 12px;
                        color: #555;
                    }
                """)
                sub_label.setText("Coming Soon")
                sub_label.setStyleSheet("font-size: 10px; color: #555; font-style: italic;")
            
            return btn
            
        def _create_chat_panel(self):
            """Create the right panel with embedded chat widget or auth prompt."""
            panel = QWidget()
            self._chat_panel_layout = QVBoxLayout(panel)
            self._chat_panel_layout.setContentsMargins(0, 0, 0, 0)
            self._chat_panel_layout.setSpacing(0)
            
            # Chat widget (always created, shown/hidden based on auth state)
            self._chat_widget = CommunityChatWidget(self)
            self._chat_panel_layout.addWidget(self._chat_widget, 1)
            
            # Auth overlay (shown when not logged in)
            self._auth_overlay = self._create_auth_overlay()
            self._chat_panel_layout.addWidget(self._auth_overlay, 1)
            
            # Show correct view based on login state
            if plugin_store_api.token:
                self._auth_overlay.setVisible(False)
                self._chat_widget.setVisible(True)
                QTimer.singleShot(500, self._connect_chat)
            else:
                self._auth_overlay.setVisible(True)
                self._chat_widget.setVisible(False)
            
            return panel
        
        def _create_auth_overlay(self):
            """Create login/register overlay for the chat panel."""
            overlay = QWidget()
            overlay.setStyleSheet("background: #1a1a2e;")
            
            main_layout = QVBoxLayout(overlay)
            main_layout.setContentsMargins(40, 40, 40, 40)
            main_layout.setSpacing(0)
            
            main_layout.addStretch(1)
            
            # Container card
            card = QWidget()
            card.setMaximumWidth(420)
            card.setStyleSheet("""
                QWidget {
                    background: #252540;
                    border: 1px solid #3a3a5a;
                    border-radius: 16px;
                }
            """)
            card_layout = QVBoxLayout(card)
            card_layout.setContentsMargins(30, 30, 30, 30)
            card_layout.setSpacing(16)
            
            # Icon + title
            icon_label = QLabel("🏴")
            icon_label.setStyleSheet("font-size: 48px; background: transparent; border: none;")
            icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            card_layout.addWidget(icon_label)
            
            title = QLabel("Join the Community")
            title.setStyleSheet("font-size: 22px; font-weight: bold; color: #4fc3f7; background: transparent; border: none;")
            title.setAlignment(Qt.AlignmentFlag.AlignCenter)
            card_layout.addWidget(title)
            
            subtitle = QLabel("Sign in or create an account to chat, share devices,\nand connect with other users.")
            subtitle.setStyleSheet("font-size: 12px; color: #888; background: transparent; border: none;")
            subtitle.setAlignment(Qt.AlignmentFlag.AlignCenter)
            subtitle.setWordWrap(True)
            card_layout.addWidget(subtitle)
            
            card_layout.addSpacing(8)
            
            # Tab widget for Login / Register
            self._auth_tabs = QTabWidget()
            self._auth_tabs.setStyleSheet("""
                QTabWidget::pane {
                    border: 1px solid #3a3a5a;
                    border-radius: 8px;
                    background: #1e1e35;
                    top: -1px;
                }
                QTabBar::tab {
                    background: #2a2a42;
                    color: #888;
                    padding: 8px 24px;
                    border: 1px solid #3a3a5a;
                    border-bottom: none;
                    border-top-left-radius: 8px;
                    border-top-right-radius: 8px;
                    font-weight: bold;
                    font-size: 12px;
                }
                QTabBar::tab:selected {
                    background: #1e1e35;
                    color: #4fc3f7;
                }
                QTabBar::tab:hover:!selected {
                    background: #333355;
                }
            """)
            
            field_style = """
                QLineEdit {
                    background: #2a2a42;
                    border: 1px solid #3a3a5a;
                    border-radius: 8px;
                    padding: 10px 14px;
                    color: #e0e0e0;
                    font-size: 13px;
                }
                QLineEdit:focus {
                    border-color: #4fc3f7;
                }
            """
            
            btn_style = """
                QPushButton {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #c62828, stop:1 #d32f2f);
                    color: white;
                    border: none;
                    border-radius: 8px;
                    padding: 12px;
                    font-size: 14px;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #d32f2f, stop:1 #e53935);
                }
                QPushButton:pressed {
                    background: #b71c1c;
                }
                QPushButton:disabled {
                    background: #555;
                }
            """
            
            # ── Login Tab ──
            login_tab = QWidget()
            login_tab.setStyleSheet("background: transparent; border: none;")
            login_lay = QVBoxLayout(login_tab)
            login_lay.setContentsMargins(16, 16, 16, 16)
            login_lay.setSpacing(12)
            
            self._login_user = QLineEdit()
            self._login_user.setPlaceholderText("Username")
            self._login_user.setStyleSheet(field_style)
            login_lay.addWidget(self._login_user)
            
            self._login_pass = QLineEdit()
            self._login_pass.setPlaceholderText("Password")
            self._login_pass.setEchoMode(QLineEdit.EchoMode.Password)
            self._login_pass.setStyleSheet(field_style)
            login_lay.addWidget(self._login_pass)
            
            self._login_btn = QPushButton("Sign In")
            self._login_btn.setStyleSheet(btn_style)
            self._login_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            self._login_btn.clicked.connect(self._do_login)
            login_lay.addWidget(self._login_btn)
            
            self._login_status = QLabel("")
            self._login_status.setStyleSheet("color: #f44336; font-size: 11px; background: transparent; border: none;")
            self._login_status.setWordWrap(True)
            self._login_status.setAlignment(Qt.AlignmentFlag.AlignCenter)
            login_lay.addWidget(self._login_status)
            
            # Enter key triggers login
            self._login_pass.returnPressed.connect(self._do_login)
            self._login_user.returnPressed.connect(lambda: self._login_pass.setFocus())
            
            self._auth_tabs.addTab(login_tab, "Sign In")
            
            # ── Register Tab ──
            reg_tab = QWidget()
            reg_tab.setStyleSheet("background: transparent; border: none;")
            reg_lay = QVBoxLayout(reg_tab)
            reg_lay.setContentsMargins(16, 16, 16, 16)
            reg_lay.setSpacing(10)
            
            self._reg_user = QLineEdit()
            self._reg_user.setPlaceholderText("Choose a username")
            self._reg_user.setStyleSheet(field_style)
            reg_lay.addWidget(self._reg_user)
            
            self._reg_email = QLineEdit()
            self._reg_email.setPlaceholderText("Email address")
            self._reg_email.setStyleSheet(field_style)
            reg_lay.addWidget(self._reg_email)
            
            self._reg_pass = QLineEdit()
            self._reg_pass.setPlaceholderText("Password (min 6 characters)")
            self._reg_pass.setEchoMode(QLineEdit.EchoMode.Password)
            self._reg_pass.setStyleSheet(field_style)
            reg_lay.addWidget(self._reg_pass)
            
            self._reg_pass2 = QLineEdit()
            self._reg_pass2.setPlaceholderText("Confirm password")
            self._reg_pass2.setEchoMode(QLineEdit.EchoMode.Password)
            self._reg_pass2.setStyleSheet(field_style)
            reg_lay.addWidget(self._reg_pass2)
            
            self._reg_btn = QPushButton("Create Account")
            self._reg_btn.setStyleSheet(btn_style)
            self._reg_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            self._reg_btn.clicked.connect(self._do_register)
            reg_lay.addWidget(self._reg_btn)
            
            self._reg_status = QLabel("")
            self._reg_status.setStyleSheet("color: #f44336; font-size: 11px; background: transparent; border: none;")
            self._reg_status.setWordWrap(True)
            self._reg_status.setAlignment(Qt.AlignmentFlag.AlignCenter)
            reg_lay.addWidget(self._reg_status)
            
            # Enter key triggers register
            self._reg_pass2.returnPressed.connect(self._do_register)
            
            self._auth_tabs.addTab(reg_tab, "Register")
            
            card_layout.addWidget(self._auth_tabs)
            
            # Forum note
            note = QLabel("Your account also works on the <a href='https://forum.imageanarchy.com/forum/' style='color: #4fc3f7;'>Image Anarchy Forum</a>")
            note.setStyleSheet("font-size: 11px; color: #666; background: transparent; border: none;")
            note.setAlignment(Qt.AlignmentFlag.AlignCenter)
            note.setOpenExternalLinks(True)
            card_layout.addWidget(note)
            
            # Center the card horizontally
            h_layout = QHBoxLayout()
            h_layout.addStretch(1)
            h_layout.addWidget(card)
            h_layout.addStretch(1)
            
            main_layout.addLayout(h_layout)
            main_layout.addStretch(1)
            
            return overlay
        
        def _do_login(self):
            """Handle login from the auth overlay."""
            username = self._login_user.text().strip()
            password = self._login_pass.text()
            
            if not username or not password:
                self._login_status.setText("Please enter username and password")
                return
            
            self._login_btn.setEnabled(False)
            self._login_status.setText("Signing in...")
            self._login_status.setStyleSheet("color: #888; font-size: 11px; background: transparent; border: none;")
            QApplication.processEvents()
            
            result = plugin_store_api.login(username, password)
            
            self._login_btn.setEnabled(True)
            
            if 'error' in result:
                self._login_status.setText(result['error'])
                self._login_status.setStyleSheet("color: #f44336; font-size: 11px; background: transparent; border: none;")
            else:
                self._login_status.setText("")
                self._on_auth_success(username)
        
        def _do_register(self):
            """Handle registration from the auth overlay."""
            username = self._reg_user.text().strip()
            email = self._reg_email.text().strip()
            password = self._reg_pass.text()
            password2 = self._reg_pass2.text()
            
            if not username or not email or not password:
                self._reg_status.setText("Please fill in all fields")
                return
            
            if password != password2:
                self._reg_status.setText("Passwords don't match")
                return
            
            if len(password) < 6:
                self._reg_status.setText("Password must be at least 6 characters")
                return
            
            if '@' not in email or '.' not in email:
                self._reg_status.setText("Please enter a valid email address")
                return
            
            self._reg_btn.setEnabled(False)
            self._reg_status.setText("Creating account...")
            self._reg_status.setStyleSheet("color: #888; font-size: 11px; background: transparent; border: none;")
            QApplication.processEvents()
            
            result = plugin_store_api.register(username, email, password)
            
            self._reg_btn.setEnabled(True)
            
            if 'error' in result:
                self._reg_status.setText(result['error'])
                self._reg_status.setStyleSheet("color: #f44336; font-size: 11px; background: transparent; border: none;")
            else:
                self._reg_status.setText("")
                self._on_auth_success(username)
        
        def _on_auth_success(self, username):
            """Transition from auth overlay to live chat after login/register."""
            # Hide auth, show chat
            self._auth_overlay.setVisible(False)
            self._chat_widget.setVisible(True)
            
            # Connect to chat
            QTimer.singleShot(300, self._connect_chat)
            
            # Update Plugin Store tab auth UI if it exists
            try:
                main_win = self.main_window
                if main_win:
                    for i in range(main_win.tab_widget.count()):
                        tab = main_win.tab_widget.widget(i)
                        if hasattr(tab, '_update_auth_ui'):
                            tab._update_auth_ui()
            except Exception:
                pass
            
        def _connect_chat(self):
            """Connect to chat server."""
            if self._chat_widget and plugin_store_api.token and plugin_store_api.user:
                username = plugin_store_api.user.get('username', '')
                if username:
                    self._chat_widget.connect_chat(username)
                
        def _focus_chat(self):
            """Focus on the chat input."""
            if self._chat_widget:
                self._chat_widget.message_input.setFocus()
                
        def _show_invites(self):
            """Show pending invites dialog."""
            if self._chat_widget:
                self._chat_widget._show_invites_dialog()
                
        def _show_shared_files(self):
            """Show shared files in current room."""
            QMessageBox.information(self, "Shared Files", "📁 Shared files feature coming soon!\n\nView images and files shared in the current room.")
            
        def _show_members(self):
            """Show room members."""
            if self._chat_widget:
                # Trigger the online users popup
                count = self._chat_widget.online_count.text()
                QMessageBox.information(self, "Online Members", f"👥 {count}\n\nClick the online count in chat to see the full list.")
                
        def _show_settings(self):
            """Show chat settings dialog."""
            dialog = QDialog(self)
            dialog.setWindowTitle("Chat Settings")
            dialog.setMinimumWidth(400)
            
            layout = QVBoxLayout(dialog)
            
            # Notifications section
            notif_group = QGroupBox("🔔 Notifications")
            notif_layout = QVBoxLayout(notif_group)
            
            self._notif_sounds = QCheckBox("Play sound on new messages")
            self._notif_sounds.setChecked(True)
            notif_layout.addWidget(self._notif_sounds)
            
            self._notif_toast = QCheckBox("Show toast notifications")
            self._notif_toast.setChecked(True)
            notif_layout.addWidget(self._notif_toast)
            
            layout.addWidget(notif_group)
            
            # Appearance section
            appear_group = QGroupBox("🎨 Appearance")
            appear_layout = QVBoxLayout(appear_group)
            
            self._compact_mode = QCheckBox("Compact message view")
            appear_layout.addWidget(self._compact_mode)
            
            self._show_timestamps = QCheckBox("Show message timestamps")
            self._show_timestamps.setChecked(True)
            appear_layout.addWidget(self._show_timestamps)
            
            layout.addWidget(appear_group)
            
            # Remote Play — Trust Settings
            remote_group = QGroupBox("🔧 Remote Play — Trust Settings")
            remote_group.setStyleSheet("QGroupBox { color: #4fc3f7; font-weight: bold; }")
            remote_layout = QVBoxLayout(remote_group)
            
            remote_label = QLabel("When a Professional requests to run a command on your device:")
            remote_label.setWordWrap(True)
            remote_label.setStyleSheet("color: #ccc;")
            remote_layout.addWidget(remote_label)
            
            ask_radio = QRadioButton("❓ Ask me for every command (safest)")
            ask_radio.setChecked(self._trust_mode == 'ask')
            remote_layout.addWidget(ask_radio)
            
            trust_read_radio = QRadioButton("📖 Auto-approve READ operations, ask for others")
            trust_read_radio.setChecked(self._trust_mode == 'trust_read')
            remote_layout.addWidget(trust_read_radio)
            
            trust_all_radio = QRadioButton("⚡ Trust mode — auto-approve everything (⚠️ dangerous)")
            trust_all_radio.setChecked(self._trust_mode == 'trust_all')
            trust_all_radio.setStyleSheet("QRadioButton { color: #f44336; }")
            remote_layout.addWidget(trust_all_radio)
            
            trust_warning = QLabel("⚠️ Trust mode lets the Professional run ANY command without asking you!")
            trust_warning.setStyleSheet("font-size: 10px; color: #f44336; font-style: italic; margin-top: 4px;")
            trust_warning.setWordWrap(True)
            remote_layout.addWidget(trust_warning)
            
            # Save trust mode on change
            ask_radio.toggled.connect(lambda c: setattr(self, '_trust_mode', 'ask') if c else None)
            trust_read_radio.toggled.connect(lambda c: setattr(self, '_trust_mode', 'trust_read') if c else None)
            trust_all_radio.toggled.connect(lambda c: setattr(self, '_trust_mode', 'trust_all') if c else None)
            
            layout.addWidget(remote_group)
            
            # Buttons
            btn_layout = QHBoxLayout()
            btn_layout.addStretch()
            
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(dialog.accept)
            btn_layout.addWidget(close_btn)
            
            layout.addLayout(btn_layout)
            
            dialog.exec()
        
        # ═══════════════════════════════════════════════════════════════
        # REMOTE PLAY — HOST METHODS
        # ═══════════════════════════════════════════════════════════════
        
        def _share_device(self):
            """Host: Open dialog to share device with Professionals."""
            if self._share_session:
                reply = QMessageBox.question(
                    self, "Stop Sharing?",
                    "🔴 You are currently sharing your device.\n\nStop sharing?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    self._stop_sharing()
                return
            
            # Get current room
            room_id = None
            if self._chat_widget and hasattr(self._chat_widget, 'current_room'):
                room_id = self._chat_widget.current_room
            if not room_id:
                QMessageBox.warning(self, "No Room", "Join a chat room first to share your device.")
                return
            
            username = ''
            if hasattr(plugin_store_api, 'user') and plugin_store_api.user:
                username = plugin_store_api.user.get('username', '')
            if not username:
                QMessageBox.warning(self, "Not Logged In", "Please log in to share your device.")
                return
            
            # Build list of remote-capable plugins (from manifests, not just loaded ones)
            pm = plugin_manager
            remote_plugins = []
            for pid, manifest in pm.manifests.items():
                if getattr(manifest, 'remote_capable', False):
                    # Check if plugin is loaded; if so, verify it has remote ops
                    plugin = pm.plugins.get(pid)
                    has_ops = plugin is not None and hasattr(plugin, 'get_remote_operations')
                    remote_plugins.append((pid, manifest.name, has_ops, plugin is not None))
            
            if not remote_plugins:
                QMessageBox.information(self, "No Remote Plugins",
                    "No plugins with remote capabilities are installed.")
                return
            
            # Show share dialog
            dialog = QDialog(self)
            dialog.setWindowTitle("🔧 Share Your Device")
            dialog.setMinimumWidth(480)
            dialog.setStyleSheet("background: #1e1e2e; color: #eee;")
            
            dlg_layout = QVBoxLayout(dialog)
            dlg_layout.setSpacing(16)
            
            title = QLabel("Share Your Device with a Professional")
            title.setStyleSheet("font-size: 18px; font-weight: bold; color: #4fc3f7;")
            dlg_layout.addWidget(title)
            
            desc = QLabel(
                "Select which tools a Professional can use to help repair or "
                "modify your device. You'll be asked to approve commands "
                "based on your trust settings."
            )
            desc.setWordWrap(True)
            desc.setStyleSheet("color: #aaa; font-size: 12px;")
            dlg_layout.addWidget(desc)
            
            # Plugin checkboxes
            plugins_group = QGroupBox("Available Tools")
            plugins_group.setStyleSheet("QGroupBox { color: #4fc3f7; font-weight: bold; }")
            plugins_layout = QVBoxLayout(plugins_group)
            
            checkboxes = {}
            for pid, pname, has_ops, is_loaded in remote_plugins:
                cb = QCheckBox(f"  {pname}")
                if has_ops:
                    cb.setChecked(True)
                elif is_loaded:
                    # Loaded but no remote ops method
                    cb.setChecked(False)
                    cb.setEnabled(False)
                    cb.setToolTip("Plugin hasn't implemented remote operations yet")
                    cb.setStyleSheet("color: #666;")
                else:
                    # Not loaded yet — will be loaded on share
                    cb.setChecked(True)
                    cb.setToolTip("Will be loaded when sharing starts")
                checkboxes[pid] = cb
                plugins_layout.addWidget(cb)
            
            dlg_layout.addWidget(plugins_group)
            
            # Trust mode
            trust_group = QGroupBox("Trust Settings for This Session")
            trust_group.setStyleSheet("QGroupBox { color: #4fc3f7; font-weight: bold; }")
            trust_layout = QVBoxLayout(trust_group)
            
            ask_radio = QRadioButton("❓ Ask me for every command (safest)")
            ask_radio.setChecked(self._trust_mode == 'ask')
            trust_layout.addWidget(ask_radio)
            
            trust_read_radio = QRadioButton("📖 Auto-approve READ operations")
            trust_read_radio.setChecked(self._trust_mode == 'trust_read')
            trust_layout.addWidget(trust_read_radio)
            
            trust_all_radio = QRadioButton("⚡ Trust everything (⚠️ dangerous)")
            trust_all_radio.setChecked(self._trust_mode == 'trust_all')
            trust_all_radio.setStyleSheet("QRadioButton { color: #f44336; }")
            trust_layout.addWidget(trust_all_radio)
            
            dlg_layout.addWidget(trust_group)
            
            # Room info
            room_label = QLabel(f"📍 Sharing in room: {room_id}")
            room_label.setStyleSheet("color: #888; font-size: 11px;")
            dlg_layout.addWidget(room_label)
            
            # Buttons
            share_btn_row = QHBoxLayout()
            share_btn_row.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            share_btn_row.addWidget(cancel_btn)
            
            share_btn = QPushButton("🔧 Start Sharing")
            share_btn.setStyleSheet("""
                QPushButton {
                    background: #c62828;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    padding: 10px 24px;
                    font-size: 14px;
                    font-weight: bold;
                }
                QPushButton:hover { background: #d32f2f; }
            """)
            
            def on_share():
                if trust_all_radio.isChecked():
                    self._trust_mode = 'trust_all'
                elif trust_read_radio.isChecked():
                    self._trust_mode = 'trust_read'
                else:
                    self._trust_mode = 'ask'
                selected = [pid for pid, cb in checkboxes.items() if cb.isChecked()]
                if not selected:
                    QMessageBox.warning(dialog, "No Tools", "Select at least one tool to share.")
                    return
                dialog.accept()
                self._start_sharing(room_id, username, selected)
            
            share_btn.clicked.connect(on_share)
            share_btn_row.addWidget(share_btn)
            dlg_layout.addLayout(share_btn_row)
            
            dialog.exec()
        
        def _start_sharing(self, room_id, username, plugin_ids):
            """Create DeviceShareSession and begin sharing."""
            try:
                session = DeviceShareSession(parent=self)
                
                pm = plugin_manager
                for pid in plugin_ids:
                    plugin = pm.plugins.get(pid)
                    if not plugin:
                        # Lazy-load the plugin
                        try:
                            plugin = pm.load_plugin(pid)
                        except Exception as e:
                            logging.warning(f"Failed to load plugin {pid} for sharing: {e}")
                    if plugin:
                        session.register_plugin(pid, plugin)
                
                session.build_capabilities()
                
                # Connect signals
                session.session_started.connect(self._on_sharing_started)
                session.session_stopped.connect(self._on_sharing_stopped)
                session.command_received.connect(self._handle_approval_request)
                session.professional_joined_signal.connect(self._on_professional_joined)
                session.screen_share_requested.connect(self._handle_screen_share_request)
                session.screen_share_ended_signal.connect(
                    lambda reason: self._share_status.setText(f"📺 Screen share ended: {reason}")
                )
                session.log_message.connect(lambda msg: self._on_command_log({'operation': msg}))
                
                session.start_sharing(room_id, username)
                self._share_session = session
                
                self._share_status.setText("🟡 Connecting...")
                self._share_status.setStyleSheet("font-size: 11px; color: #ff9800; margin: 4px 0;")
                
            except Exception as e:
                logging.error(f"Failed to start sharing: {e}")
                QMessageBox.critical(self, "Share Failed", f"Could not start sharing:\n{e}")
        
        def _on_sharing_started(self, session_id=None):
            """Callback when sharing is successfully started."""
            self._current_session_id = session_id
            self._share_status.setText("🟢 Sharing — waiting for Professional")
            if session_id:
                self._share_status.setToolTip(f"Session ID: {session_id}\nRight-click to copy")
            self._share_status.setStyleSheet(
                "font-size: 11px; color: #4caf50; margin: 4px 0; font-weight: bold;"
            )
            # Auto-copy to clipboard
            if session_id:
                try:
                    QApplication.clipboard().setText(session_id)
                    logging.info(f"Session ID copied to clipboard: {session_id}")
                except Exception:
                    pass
        
        def _copy_session_id(self):
            """Copy the current session ID to clipboard."""
            sid = getattr(self, '_current_session_id', None)
            if sid:
                QApplication.clipboard().setText(sid)
                # Brief visual feedback
                old = self._share_status.text()
                self._share_status.setText("📋 Session ID copied!")
                QTimer.singleShot(1500, lambda: self._share_status.setText(old))
        
        def _share_status_context_menu(self, pos):
            """Right-click menu on share status label."""
            sid = getattr(self, '_current_session_id', None)
            if not sid:
                return
            menu = QMenu(self)
            copy_action = menu.addAction("📋 Copy Session ID")
            stop_action = menu.addAction("🔴 Stop Sharing")
            action = menu.exec(self._share_status.mapToGlobal(pos))
            if action == copy_action:
                self._copy_session_id()
            elif action == stop_action:
                self._stop_sharing()
        
        def _on_professional_joined(self, pro_name):
            """Callback when a Professional connects to our session."""
            self._share_status.setText(f"🟢 Sharing with {pro_name}")
            self._share_status.setStyleSheet(
                "font-size: 11px; color: #4caf50; margin: 4px 0; font-weight: bold;"
            )
        
        def _on_sharing_stopped(self):
            """Callback when sharing stops."""
            self._share_status.setText("⚫ Not sharing")
            self._share_status.setStyleSheet("font-size: 11px; color: #888; margin: 4px 0;")
            self._share_session = None
        
        def _stop_sharing(self):
            """Stop sharing device."""
            if self._share_session:
                self._share_session.stop_sharing()
                self._share_session = None
            self._share_status.setText("⚫ Not sharing")
            self._share_status.setStyleSheet("font-size: 11px; color: #888; margin: 4px 0;")
        
        def _on_command_log(self, data):
            """Host: log remote command execution."""
            cmd = data.get('operation') or data.get('raw_command', 'unknown')
            success = data.get('success', False)
            icon = '✅' if success else '❌'
            logging.info(f"Remote command {icon}: {cmd}")
        
        # ═══════════════════════════════════════════════════════════════
        # REMOTE PLAY — APPROVAL DIALOG (HOST)
        # ═══════════════════════════════════════════════════════════════
        
        def _handle_approval_request(self, data):
            """Host: Show approval dialog for incoming Professional command."""
            cmd_type = data.get('type', 'operation')
            command_id = data.get('command_id', '')
            pro_name = data.get('technician', data.get('professional_name', 'Unknown'))
            risk = data.get('risk_level', data.get('risk', 'MODIFY'))
            
            if cmd_type == 'raw_command':
                cmd_text = data.get('raw_command', '')
                title_text = "Raw Console Command"
            else:
                cmd_text = data.get('operation', '')
                plugin_id = data.get('plugin_id', '')
                title_text = f"{plugin_id}: {cmd_text}"
            
            # Auto-approve logic
            if self._trust_mode == 'trust_all':
                if self._share_session:
                    self._share_session.approve_command(command_id)
                return
            
            if self._trust_mode == 'trust_read' and risk == 'READ':
                if self._share_session:
                    self._share_session.approve_command(command_id)
                return
            
            # Show dialog
            risk_colors = {
                'READ': '#4caf50',
                'MODIFY': '#ff9800',
                'DANGER': '#f44336',
            }
            risk_color = risk_colors.get(risk, '#ff9800')
            
            approval_dlg = QDialog(self)
            approval_dlg.setWindowTitle("⚠️ Remote Command Request")
            approval_dlg.setMinimumWidth(450)
            approval_dlg.setStyleSheet("background: #1e1e2e; color: #eee;")
            
            a_layout = QVBoxLayout(approval_dlg)
            a_layout.setSpacing(12)
            
            header = QLabel(f"👤 {pro_name} wants to run a command:")
            header.setStyleSheet("font-size: 14px; font-weight: bold; color: #4fc3f7;")
            a_layout.addWidget(header)
            
            # Command display frame
            cmd_frame = QWidget()
            cmd_frame.setStyleSheet(
                f"background: #111; border: 1px solid {risk_color}; "
                f"border-radius: 8px; padding: 12px;"
            )
            cmd_frame_layout = QVBoxLayout(cmd_frame)
            
            type_label = QLabel(f"Type: {title_text}")
            type_label.setStyleSheet("color: #aaa; font-size: 11px;")
            cmd_frame_layout.addWidget(type_label)
            
            cmd_display = QLabel(cmd_text)
            cmd_display.setStyleSheet(
                "font-size: 14px; color: #00ff41; font-family: Consolas; padding: 4px 0;"
            )
            cmd_display.setWordWrap(True)
            cmd_frame_layout.addWidget(cmd_display)
            
            risk_label = QLabel(f"Risk Level: {risk}")
            risk_label.setStyleSheet(f"font-size: 12px; color: {risk_color}; font-weight: bold; margin-top: 4px;")
            cmd_frame_layout.addWidget(risk_label)
            
            a_layout.addWidget(cmd_frame)
            
            # Approve / Reject buttons
            approval_btns = QHBoxLayout()
            approval_btns.addStretch()
            
            reject_btn = QPushButton("🚫 Reject")
            reject_btn.setStyleSheet("""
                QPushButton {
                    background: #333; color: #f44336;
                    border: 1px solid #f44336; border-radius: 6px;
                    padding: 8px 20px; font-weight: bold;
                }
                QPushButton:hover { background: #3a1a1a; }
            """)
            
            approve_btn = QPushButton("✅ Approve")
            approve_btn.setStyleSheet("""
                QPushButton {
                    background: #1b5e20; color: white;
                    border: none; border-radius: 6px;
                    padding: 8px 20px; font-weight: bold;
                }
                QPushButton:hover { background: #2e7d32; }
            """)
            
            def on_approve():
                if self._share_session:
                    self._share_session.approve_command(command_id)
                approval_dlg.accept()
            
            def on_reject():
                if self._share_session:
                    self._share_session.reject_command(command_id)
                approval_dlg.accept()
            
            reject_btn.clicked.connect(on_reject)
            approve_btn.clicked.connect(on_approve)
            
            approval_btns.addWidget(reject_btn)
            approval_btns.addWidget(approve_btn)
            a_layout.addLayout(approval_btns)
            
            # Auto-reject after 60 seconds
            auto_reject_timer = QTimer(approval_dlg)
            auto_reject_timer.setSingleShot(True)
            auto_reject_timer.timeout.connect(on_reject)
            auto_reject_timer.start(60000)
            
            approval_dlg.exec()
        
        # ═══════════════════════════════════════════════════════════════
        # REMOTE PLAY — PROFESSIONAL METHODS
        # ═══════════════════════════════════════════════════════════════
        
        def _connect_to_device(self):
            """Professional: Connect to a Host's shared device."""
            if self._active_device_session:
                reply = QMessageBox.question(
                    self, "Already Connected",
                    f"Connected to {self._active_device_session.get('host_name', 'device')}.\n\n"
                    "Disconnect first?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    self._disconnect_professional()
                return
            
            username = ''
            if hasattr(plugin_store_api, 'user') and plugin_store_api.user:
                username = plugin_store_api.user.get('username', '')
            if not username:
                QMessageBox.warning(self, "Not Logged In", "Please log in first.")
                return
            
            # Connect dialog
            connect_dlg = QDialog(self)
            connect_dlg.setWindowTitle("📱 Connect as Professional")
            connect_dlg.setMinimumWidth(420)
            connect_dlg.setStyleSheet("background: #1e1e2e; color: #eee;")
            
            c_layout = QVBoxLayout(connect_dlg)
            c_layout.setSpacing(12)
            
            title = QLabel("Connect to a Shared Device")
            title.setStyleSheet("font-size: 18px; font-weight: bold; color: #4fc3f7;")
            c_layout.addWidget(title)
            
            desc = QLabel(
                "Enter the session code shared by the Host, or browse "
                "available sessions in your room."
            )
            desc.setWordWrap(True)
            desc.setStyleSheet("color: #aaa; font-size: 12px;")
            c_layout.addWidget(desc)
            
            # Session code input
            code_group = QGroupBox("Session Code")
            code_group.setStyleSheet("QGroupBox { color: #4fc3f7; }")
            code_input_layout = QHBoxLayout(code_group)
            
            session_input = QLineEdit()
            session_input.setPlaceholderText("Paste session code from Host...")
            session_input.setStyleSheet("""
                QLineEdit {
                    background: #111; color: #eee;
                    border: 1px solid #333; border-radius: 6px;
                    padding: 10px; font-size: 13px; font-family: Consolas;
                }
            """)
            code_input_layout.addWidget(session_input, 1)
            c_layout.addWidget(code_group)
            
            status_label = QLabel("")
            status_label.setStyleSheet("color: #888; font-size: 11px;")
            c_layout.addWidget(status_label)
            
            # Buttons
            connect_btn_row = QHBoxLayout()
            connect_btn_row.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(connect_dlg.reject)
            connect_btn_row.addWidget(cancel_btn)
            
            go_btn = QPushButton("🔌 Connect")
            go_btn.setStyleSheet("""
                QPushButton {
                    background: #0d47a1; color: white;
                    border: none; border-radius: 6px;
                    padding: 10px 24px; font-size: 14px; font-weight: bold;
                }
                QPushButton:hover { background: #1565c0; }
            """)
            
            def on_connect():
                code = session_input.text().strip()
                if not code:
                    status_label.setText("⚠️ Enter a session code")
                    status_label.setStyleSheet("color: #f44336; font-size: 11px;")
                    return
                status_label.setText("🔄 Connecting...")
                status_label.setStyleSheet("color: #ff9800; font-size: 11px;")
                connect_dlg.accept()
                # Show immediate feedback on the main tab
                self._share_status.setText("🔄 Connecting to session...")
                self._share_status.setStyleSheet("font-size: 11px; color: #ff9800; margin: 4px 0;")
                self._join_professional_session(code, username)
            
            go_btn.clicked.connect(on_connect)
            connect_btn_row.addWidget(go_btn)
            c_layout.addLayout(connect_btn_row)
            
            connect_dlg.exec()
        
        def _join_professional_session(self, session_code, username):
            """Professional: Join a Host's session via Socket.IO (non-blocking)."""
            # Get JWT token
            token = getattr(plugin_store_api, 'token', None)
            if not token:
                QMessageBox.warning(self, "Not Logged In",
                    "Please log in via Plugin Store first.")
                return
            
            try:
                import socketio
                import threading
                
                # Thread-safe GUI update via custom QEvent
                class _CallableEvent(QEvent):
                    EVENT_TYPE = QEvent.Type(QEvent.registerEventType())
                    def __init__(self, fn):
                        super().__init__(self.EVENT_TYPE)
                        self.fn = fn
                
                class _CallableEventFilter(QObject):
                    def event(self, e):
                        if isinstance(e, _CallableEvent):
                            try:
                                e.fn()
                            except Exception as ex:
                                logging.error(f"[PRO] GUI callback error: {ex}")
                            return True
                        return super().event(e)
                
                _event_receiver = _CallableEventFilter()
                self._pro_event_receiver = _event_receiver  # prevent GC
                
                def _gui(fn):
                    """Thread-safe: post callable to GUI thread event loop."""
                    QApplication.instance().postEvent(_event_receiver, _CallableEvent(fn))
                
                # Build HTTP session with CF auth (curl_cffi for Cloudflare bypass)
                http_session = None
                try:
                    from curl_cffi.requests import Session as CurlSession
                    http_session = CurlSession()
                    http_session.headers.update(get_rc_cf_headers())
                except ImportError:
                    try:
                        import requests
                        http_session = requests.Session()
                        http_session.headers.update(get_rc_cf_headers())
                    except ImportError:
                        QMessageBox.critical(
                            self, "Missing Library",
                            "No HTTP library available.\nInstall: pip install curl_cffi"
                        )
                        return
                
                sio = socketio.Client(
                    reconnection=True,
                    reconnection_attempts=5,
                    reconnection_delay=2,
                    reconnection_delay_max=15,
                    logger=False,
                    engineio_logger=False,
                    http_session=http_session,
                )
                
                _self = self  # capture for closures
                
                @sio.event
                def connect():
                    logging.info("[PRO] Connected to remote-ctl relay server")
                    sio.emit('join_device_session', {
                        'session_id': session_code,
                        'professional_name': username,
                    })
                    logging.info(f"[PRO] Emitted join_device_session for session {session_code[:8]}...")
                
                @sio.event
                def disconnect():
                    logging.warning("[PRO] Disconnected from remote-ctl relay server")
                    def _on_disconnect():
                        _self._share_status.setText("🔴 Disconnected from relay")
                        _self._share_status.setStyleSheet("font-size: 11px; color: #f44336; margin: 4px 0;")
                    _gui(_on_disconnect)
                
                @sio.on('device_session_joined')
                def on_joined(data):
                    logging.info(f"[PRO] Received device_session_joined: {data}")
                    host_name = data.get('owner_name', 'Host')
                    caps = data.get('capabilities', [])
                    def _update():
                        logging.info(f"[PRO] GUI update: Connected to {host_name}, {len(caps)} capabilities")
                        _self._active_device_session = {
                            'session_id': session_code,
                            'host_name': host_name,
                            'capabilities': caps,
                        }
                        _self._share_status.setText(f"🔵 Connected to {host_name}")
                        _self._share_status.setStyleSheet(
                            "font-size: 11px; color: #2196f3; margin: 4px 0; font-weight: bold;"
                        )
                        _self.remote_connect_btn.setText("📱 Disconnect")
                        # Notify user visibly
                        QMessageBox.information(
                            _self, "Connected!",
                            f"✅ Connected to {host_name}'s device!\n\n"
                            f"Capabilities: {len(caps)} plugin(s)\n"
                            f"Opening master console..."
                        )
                        QTimer.singleShot(500, _self._show_master_console)
                    _gui(_update)
                
                @sio.on('device_command_result')
                def on_result(data):
                    _gui(lambda: _self._on_console_result(data))
                
                @sio.on('device_command_log')
                def on_log(data):
                    _gui(lambda: _self._on_console_result(data))
                
                @sio.on('device_capabilities_update')
                def on_caps_update(data):
                    if _self._active_device_session:
                        _self._active_device_session['capabilities'] = data.get('capabilities', [])
                
                @sio.on('device_share_ended')
                def on_share_ended(data):
                    logging.info(f"[PRO] Received device_share_ended: {data}")
                    def _handle():
                        _self._disconnect_professional()
                        QMessageBox.information(
                            _self, "Session Ended",
                            "The Host has stopped sharing their device."
                        )
                    _gui(_handle)
                
                @sio.on('device_unshared')
                def on_unshared(data):
                    logging.info(f"[PRO] Received device_unshared: {data}")
                    reason = data.get('reason', 'Host stopped sharing')
                    def _handle():
                        _self._disconnect_professional()
                        QMessageBox.information(
                            _self, "Session Ended",
                            f"The Host has stopped sharing their device.\n\nReason: {reason}"
                        )
                    _gui(_handle)
                
                @sio.on('error')
                def on_error(data):
                    msg = data.get('message', str(data)) if isinstance(data, dict) else str(data)
                    logging.error(f"[PRO] Socket error: {msg}")
                    def _show_err():
                        _self._share_status.setText(f"❌ {msg[:60]}")
                        _self._share_status.setStyleSheet("font-size: 11px; color: #f44336; margin: 4px 0;")
                    _gui(_show_err)
                
                # ── Screen Share handlers (Professional receives from relay) ──
                @sio.on('screen_share_approved')
                def on_screen_approved(data):
                    ssid = data.get('screen_session_id', '')
                    perms = data.get('permissions', {})
                    def _open():
                        _self._open_screen_viewer(ssid, perms)
                    _gui(_open)

                @sio.on('screen_share_denied')
                def on_screen_denied(data):
                    msg = data.get('message', 'Host denied the request')
                    def _show():
                        if hasattr(_self, '_console_output') and _self._console_output:
                            _self._console_output.append(
                                f'<span style="color:#ff9800">📺 Screen share denied: {msg}</span>'
                            )
                    _gui(_show)

                @sio.on('screen_share_ended')
                def on_screen_ended(data):
                    reason = data.get('reason', 'Session ended')
                    def _close():
                        _self._close_screen_viewer()
                        if hasattr(_self, '_console_output') and _self._console_output:
                            _self._console_output.append(
                                f'<span style="color:#ff9800">📺 Screen share ended: {reason}</span>'
                            )
                    _gui(_close)

                @sio.on('screen_frame')
                def on_screen_frame(data):
                    if not data or len(data) < 20:
                        return
                    # Strip 16-byte UUID prefix, pass JPEG data to viewer
                    jpeg_data = bytes(data[16:]) if not isinstance(data, bytes) else data[16:]
                    viewer = getattr(_self, '_screen_viewer', None)
                    if viewer and viewer.isVisible():
                        _gui(lambda jd=jpeg_data: viewer.update_frame(jd))

                @sio.on('screen_permissions_updated')
                def on_screen_perms(data):
                    perms = data.get('permissions', {})
                    viewer = getattr(_self, '_screen_viewer', None)
                    if viewer:
                        _gui(lambda p=perms: viewer.update_permissions(p))

                self._pro_socket = sio
                
                # Connect in background thread (blocks during HTTP handshake)
                def _do_connect():
                    try:
                        sio.connect(
                            REMOTE_CTL_URL,
                            auth={'token': token},
                            transports=['polling'],
                        )
                    except Exception as e:
                        logging.error(f"Failed to connect as Professional: {e}")
                        _gui(lambda: _self._share_status.setText(f"❌ {str(e)[:60]}"))
                        _gui(lambda: _self._share_status.setStyleSheet("font-size: 11px; color: #f44336; margin: 4px 0;"))
                
                threading.Thread(target=_do_connect, daemon=True).start()
                
            except Exception as e:
                logging.error(f"Failed to connect as Professional: {e}")
                QMessageBox.critical(self, "Connection Failed", f"Could not connect:\n{e}")
        
        def _disconnect_professional(self):
            """Professional: Disconnect from Host's session."""
            if self._pro_socket:
                try:
                    self._pro_socket.disconnect()
                except Exception:
                    pass
                self._pro_socket = None
            
            self._active_device_session = None
            self._share_status.setText("⚫ Not sharing")
            self._share_status.setStyleSheet("font-size: 11px; color: #888; margin: 4px 0;")
            self.remote_connect_btn.setText("📱 Connect as Professional")
            
            if self._remote_console:
                self._remote_console.close()
                self._remote_console = None
            
            self._close_screen_viewer()
        
        # ═══════════════════════════════════════════════════════════════
        # REMOTE PLAY — SCREEN SHARE UI (PROFESSIONAL + HOST)
        # ═══════════════════════════════════════════════════════════════
        
        def _request_screen_share(self):
            """Professional: Request screen share from Host."""
            if not self._pro_socket or not self._active_device_session:
                QMessageBox.warning(self, "Not Connected", "Connect to a device session first.")
                return

            session_id = self._active_device_session.get('session_id', '')
            self._pro_socket.emit('screen_share_request', {
                'session_id': session_id,
            })
            if hasattr(self, '_console_output') and self._console_output:
                self._console_output.append(
                    '<span style="color:#4fc3f7">📺 Screen share requested — waiting for Host approval...</span>'
                )

        def _open_screen_viewer(self, screen_session_id, permissions):
            """Professional: Open the screen viewer widget."""
            self._close_screen_viewer()
            host_name = ''
            if self._active_device_session:
                host_name = self._active_device_session.get('host_name', '')

            viewer = ScreenViewerWidget(
                screen_session_id=screen_session_id,
                host_name=host_name,
                permissions=permissions,
                parent=None,
            )
            viewer.closed.connect(self._on_screen_viewer_closed)
            viewer.input_event.connect(self._send_screen_input)
            viewer.show()
            self._screen_viewer = viewer

            # Start heartbeat timer — keeps relay from killing the session
            self._screen_hb_timer = QTimer()
            self._screen_hb_timer.timeout.connect(
                lambda: self._send_screen_heartbeat(screen_session_id)
            )
            self._screen_hb_timer.start(2000)  # Every 2 seconds

            if hasattr(self, '_console_output') and self._console_output:
                self._console_output.append(
                    '<span style="color:#4caf50">📺 Screen share started! Viewer opened.</span>'
                )

        def _close_screen_viewer(self):
            """Close the screen viewer if open."""
            hb = getattr(self, '_screen_hb_timer', None)
            if hb:
                hb.stop()
                self._screen_hb_timer = None
            viewer = getattr(self, '_screen_viewer', None)
            if viewer:
                viewer.close()
                viewer.deleteLater()
            self._screen_viewer = None

        def _on_screen_viewer_closed(self):
            """Called when viewer window is closed by Professional."""
            if self._pro_socket:
                ssid = ''
                viewer = getattr(self, '_screen_viewer', None)
                if viewer:
                    ssid = viewer.screen_session_id
                if ssid:
                    self._pro_socket.emit('screen_viewer_disconnect', {
                        'screen_session_id': ssid,
                    })
            self._screen_viewer = None

        def _send_screen_input(self, data):
            """Professional: Send touch/key input to relay → Host."""
            if self._pro_socket:
                self._pro_socket.emit('screen_input', data)

        def _send_screen_heartbeat(self, screen_session_id):
            """Professional: Send heartbeat to keep screen session alive."""
            if self._pro_socket:
                try:
                    self._pro_socket.emit('screen_heartbeat', {
                        'screen_session_id': screen_session_id,
                    })
                except Exception:
                    pass

        def _handle_screen_share_request(self, data):
            """Host: Show screen share approval dialog."""
            ssid = data.get('screen_session_id', '')
            pro_name = data.get('professional_name', 'Unknown')

            dlg = QDialog(self)
            dlg.setWindowTitle("📺 Screen Share Request")
            dlg.setMinimumWidth(420)
            dlg.setStyleSheet("background: #1e1e2e; color: #eee;")
            lay = QVBoxLayout(dlg)

            lay.addWidget(QLabel(
                f"<h3>📺 {pro_name} wants to see your device screen</h3>"
            ))

            # Privacy notice
            privacy = QLabel(
                "🔒 <b>Zero-Persistence Policy</b><br>"
                "• No frames are stored on any server<br>"
                "• No metadata persists after session ends<br>"
                "• All data is RAM-only and purged immediately<br>"
                '• Verify: <a href="https://github.com/vehoelite/image-anarchy">'
                "github.com/vehoelite/image-anarchy</a>"
            )
            privacy.setOpenExternalLinks(True)
            privacy.setStyleSheet(
                "color: #aaa; font-size: 11px; padding: 8px; "
                "background: #111; border-radius: 4px;"
            )
            privacy.setWordWrap(True)
            lay.addWidget(privacy)

            # Permissions checkboxes
            perm_group = QGroupBox("Permissions")
            perm_group.setStyleSheet("QGroupBox { color: #4fc3f7; }")
            perm_lay = QVBoxLayout(perm_group)

            view_cb = QCheckBox("👁️ View screen (required)")
            view_cb.setChecked(True)
            view_cb.setEnabled(False)
            perm_lay.addWidget(view_cb)

            touch_cb = QCheckBox("👆 Allow touch input (tap, swipe)")
            perm_lay.addWidget(touch_cb)

            kb_cb = QCheckBox("⌨️ Allow keyboard input")
            perm_lay.addWidget(kb_cb)

            lay.addWidget(perm_group)

            # Banner warning
            banner = QLabel("🔴 A persistent banner will show while your screen is shared")
            banner.setStyleSheet("color: #ff9800; font-size: 11px; padding: 4px;")
            lay.addWidget(banner)

            # Buttons
            btn_row = QHBoxLayout()
            deny_btn = QPushButton("❌ Deny")
            deny_btn.clicked.connect(lambda: (
                self._share_session.deny_screen_share(ssid) if self._share_session else None,
                dlg.reject(),
            ))
            btn_row.addWidget(deny_btn)

            btn_row.addStretch()

            approve_btn = QPushButton("✅ Share Screen")
            approve_btn.setStyleSheet("""
                QPushButton {
                    background: #2e7d32; color: white; border: none;
                    border-radius: 6px; padding: 10px 24px;
                    font-size: 14px; font-weight: bold;
                }
                QPushButton:hover { background: #388e3c; }
            """)

            def on_approve():
                perms = {
                    'view': True,
                    'touch': touch_cb.isChecked(),
                    'keyboard': kb_cb.isChecked(),
                }
                if self._share_session:
                    self._share_session.approve_screen_share(ssid, perms)
                    self._share_status.setText("📺🔴 SCREEN IS BEING SHARED")
                    self._share_status.setStyleSheet(
                        "font-size: 12px; color: #f44336; margin: 4px 0; font-weight: bold;"
                    )
                dlg.accept()

            approve_btn.clicked.connect(on_approve)
            btn_row.addWidget(approve_btn)
            lay.addLayout(btn_row)

            dlg.exec()

        # ═══════════════════════════════════════════════════════════════
        # REMOTE PLAY — MASTER CONSOLE (PROFESSIONAL)
        # ═══════════════════════════════════════════════════════════════
        
        def _show_master_console(self):
            """Open the floating master console for raw command entry."""
            if self._remote_console and self._remote_console.isVisible():
                self._remote_console.raise_()
                self._remote_console.activateWindow()
                return
            
            host_name = ''
            caps = []
            if self._active_device_session:
                host_name = self._active_device_session.get('host_name', '')
                caps = self._active_device_session.get('capabilities', [])
            
            # Build prefix list from capabilities
            prefixes = set()
            for cap in caps:
                pid = cap.get('plugin_id', '')
                if pid:
                    short = pid.replace('_toolkit', '').replace('_patcher', '')
                    prefixes.add(short)
            prefix_str = ' | '.join(sorted(prefixes)) or 'adb | fastboot | mtk'
            
            console = QWidget()
            console.setWindowTitle(f"🖥️ Master Console — {host_name or 'Not Connected'}")
            console.setWindowFlags(Qt.WindowType.Window)
            console.resize(750, 520)
            console.setMinimumSize(500, 300)
            console.setStyleSheet("background: #0a0a0a;")
            
            con_layout = QVBoxLayout(console)
            con_layout.setContentsMargins(8, 8, 8, 8)
            con_layout.setSpacing(6)
            
            # Top bar with prefix hints
            top_bar = QHBoxLayout()
            hints = QLabel(f"⌨️ Prefixes: {prefix_str}")
            hints.setStyleSheet("color: #4fc3f7; font-size: 11px; font-family: Consolas;")
            top_bar.addWidget(hints)
            top_bar.addStretch()
            
            caps_btn = QPushButton("📋 Capabilities")
            caps_btn.setStyleSheet("""
                QPushButton {
                    background: #1a1a2a; color: #4fc3f7;
                    border: 1px solid #333; border-radius: 4px;
                    padding: 4px 10px; font-size: 11px;
                }
                QPushButton:hover { background: #2a2a3a; }
            """)
            caps_btn.clicked.connect(lambda: self._show_capabilities_popup(caps))
            top_bar.addWidget(caps_btn)
            
            screen_btn = QPushButton("📺 View Screen")
            screen_btn.setStyleSheet("""
                QPushButton {
                    background: #1a2a1a; color: #4caf50;
                    border: 1px solid #333; border-radius: 4px;
                    padding: 4px 10px; font-size: 11px;
                }
                QPushButton:hover { background: #2a3a2a; }
            """)
            screen_btn.clicked.connect(self._request_screen_share)
            top_bar.addWidget(screen_btn)
            con_layout.addLayout(top_bar)
            
            # Output area
            self._console_output = QTextEdit()
            self._console_output.setReadOnly(True)
            self._console_output.setStyleSheet("""
                QTextEdit {
                    background: #0a0a0a; color: #00ff41;
                    font-family: Consolas, 'Courier New', monospace;
                    font-size: 12px;
                    border: 1px solid #222; border-radius: 4px;
                    padding: 8px;
                    selection-background-color: #264f78;
                }
            """)
            self._console_output.setHtml(
                '<span style="color:#4fc3f7">&#9552;&#9552;&#9552; Image Anarchy Master Console &#9552;&#9552;&#9552;</span><br>'
                f'<span style="color:#888">Connected to: <b>{host_name}</b></span><br>'
                f'<span style="color:#888">Available prefixes: {prefix_str}</span><br>'
                '<span style="color:#888">Type a command and press Enter. Examples:</span><br>'
                '<span style="color:#555">  adb devices</span><br>'
                '<span style="color:#555">  fastboot getvar all</span><br>'
                '<span style="color:#555">  mtk read_imei</span><br>'
                '<span style="color:#4fc3f7">&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;</span><br>'
            )
            con_layout.addWidget(self._console_output, 1)
            
            # Input row
            input_row = QHBoxLayout()
            input_row.setSpacing(6)
            
            prompt_label = QLabel("IA$")
            prompt_label.setStyleSheet(
                "color: #c62828; font-size: 15px; font-family: Consolas; font-weight: bold;"
            )
            input_row.addWidget(prompt_label)
            
            self._console_input = QLineEdit()
            self._console_input.setPlaceholderText(f"  {prefix_str} ...")
            self._console_input.setStyleSheet("""
                QLineEdit {
                    background: #0d0d0d; color: #00ff41;
                    font-family: Consolas, 'Courier New', monospace;
                    font-size: 13px;
                    border: 1px solid #333; border-radius: 4px;
                    padding: 8px;
                }
                QLineEdit:focus { border-color: #4fc3f7; }
            """)
            self._console_input.returnPressed.connect(self._send_console_command)
            input_row.addWidget(self._console_input, 1)
            
            send_btn = QPushButton("▶")
            send_btn.setFixedWidth(40)
            send_btn.setStyleSheet("""
                QPushButton {
                    background: #c62828; color: white;
                    border: none; border-radius: 4px;
                    font-size: 16px; padding: 8px;
                }
                QPushButton:hover { background: #d32f2f; }
            """)
            send_btn.clicked.connect(self._send_console_command)
            input_row.addWidget(send_btn)
            
            con_layout.addLayout(input_row)
            
            self._remote_console = console
            console.show()
            self._console_input.setFocus()
        
        def _show_capabilities_popup(self, capabilities):
            """Show dialog listing all capabilities from the Host."""
            cap_dlg = QDialog(self._remote_console or self)
            cap_dlg.setWindowTitle("📋 Host Capabilities")
            cap_dlg.setMinimumWidth(500)
            cap_dlg.setMinimumHeight(400)
            cap_dlg.setStyleSheet("background: #1e1e2e; color: #eee;")
            
            cap_layout = QVBoxLayout(cap_dlg)
            
            scroll = QScrollArea()
            scroll.setWidgetResizable(True)
            scroll.setStyleSheet("border: none;")
            
            content = QWidget()
            content_layout = QVBoxLayout(content)
            content_layout.setSpacing(4)
            
            risk_colors = {'READ': '#4caf50', 'MODIFY': '#ff9800', 'DANGER': '#f44336'}
            
            current_plugin = None
            for cap in sorted(capabilities, key=lambda c: c.get('plugin_id', '')):
                pid = cap.get('plugin_id', '')
                if pid != current_plugin:
                    current_plugin = pid
                    plbl = QLabel(f"\n🔌 {pid}")
                    plbl.setStyleSheet(
                        "font-size: 14px; font-weight: bold; color: #4fc3f7; margin-top: 8px;"
                    )
                    content_layout.addWidget(plbl)
                
                op_id = cap.get('id', '')
                op_name = cap.get('name', op_id)
                risk = cap.get('risk', 'MODIFY')
                op_desc = cap.get('description', '')
                color = risk_colors.get(risk, '#ff9800')
                
                op_lbl = QLabel(
                    f"  {op_name}  [{risk}]  — {op_desc}"
                )
                op_lbl.setStyleSheet(f"font-size: 11px; color: {color}; margin-left: 16px;")
                content_layout.addWidget(op_lbl)
            
            if not capabilities:
                empty = QLabel("No capabilities reported by Host")
                empty.setStyleSheet("color: #888; font-style: italic;")
                content_layout.addWidget(empty)
            
            content_layout.addStretch()
            scroll.setWidget(content)
            cap_layout.addWidget(scroll)
            
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(cap_dlg.accept)
            cap_layout.addWidget(close_btn)
            
            cap_dlg.exec()
        
        def _send_console_command(self):
            """Professional: Send a raw command from the master console."""
            if not hasattr(self, '_console_input') or not self._console_input:
                return
            cmd = self._console_input.text().strip()
            if not cmd:
                return
            self._console_input.clear()
            
            # Echo command in output
            self._console_output.append(
                f'<span style="color:#4fc3f7">IA$ </span>'
                f'<span style="color:#eee">{cmd}</span>'
            )
            
            if not self._pro_socket or not self._active_device_session:
                self._console_output.append(
                    '<span style="color:#f44336">✗ Not connected to any device</span>'
                )
                return
            
            session_id = self._active_device_session.get('session_id', '')
            pro_name = ''
            if hasattr(plugin_store_api, 'user') and plugin_store_api.user:
                pro_name = plugin_store_api.user.get('username', '')
            
            self._console_output.append(
                '<span style="color:#888">⏳ Sending to Host for approval...</span>'
            )
            
            try:
                self._pro_socket.emit('raw_command', {
                    'session_id': session_id,
                    'raw_command': cmd,
                    'professional_name': pro_name,
                })
            except Exception as e:
                self._console_output.append(
                    f'<span style="color:#f44336">✗ Send failed: {e}</span>'
                )
        
        def _on_console_result(self, data):
            """Professional: Handle command result from Host."""
            if not hasattr(self, '_console_output') or not self._console_output:
                return
            
            success = data.get('success', False)
            output = data.get('output', data.get('result', ''))
            error = data.get('error', '')
            operation = data.get('operation', data.get('raw_command', ''))
            
            if success:
                self._console_output.append(
                    f'<span style="color:#4caf50">✓ {operation}</span>'
                )
                if output:
                    safe = str(output).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                    for line in safe.split('\n'):
                        self._console_output.append(
                            f'<span style="color:#00ff41">{line}</span>'
                        )
            else:
                err_msg = error or output or 'Command failed'
                safe_err = str(err_msg).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                self._console_output.append(
                    f'<span style="color:#f44336">✗ {safe_err}</span>'
                )
            
            self._console_output.append('')
            sb = self._console_output.verticalScrollBar()
            sb.setValue(sb.maximum())
        
        def _toggle_dock(self):
            """Toggle between docked and floating chat window."""
            if self._is_docked:
                self._undock_chat()
            else:
                self._dock_chat()
                
        def _undock_chat(self):
            """Undock chat into a floating window."""
            if self._floating_window:
                self._floating_window.show()
                self._floating_window.raise_()
                return
                
            self._floating_window = QWidget()
            self._floating_window.setWindowTitle("💬 Image Anarchy Chat")
            self._floating_window.setWindowFlags(Qt.WindowType.Window)
            self._floating_window.resize(500, 700)
            self._floating_window.setMinimumSize(350, 400)
            
            float_layout = QVBoxLayout(self._floating_window)
            float_layout.setContentsMargins(0, 0, 0, 0)
            
            # Move chat widget to floating window
            if self._chat_widget:
                self._chat_widget.setParent(self._floating_window)
                float_layout.addWidget(self._chat_widget)
                self._chat_widget.setVisible(True)
            
            # Bottom bar with dock button
            bottom_bar = QHBoxLayout()
            bottom_bar.setContentsMargins(8, 4, 8, 4)
            
            dock_btn = QPushButton("📥 Dock Back")
            dock_btn.clicked.connect(self._dock_chat)
            bottom_bar.addWidget(dock_btn)
            
            bottom_bar.addStretch()
            
            self._float_stay_on_top = QPushButton("📌 Stay on Top")
            self._float_stay_on_top.setCheckable(True)
            self._float_stay_on_top.clicked.connect(self._toggle_stay_on_top)
            bottom_bar.addWidget(self._float_stay_on_top)
            
            float_layout.addLayout(bottom_bar)
            
            self._floating_window.show()
            self._is_docked = False
            self.undock_btn.setText("📥 Dock Chat")
            self.stay_on_top_btn.setEnabled(True)
            
            # Handle window close - dock back
            def on_close(event):
                self._dock_chat()
                event.ignore()
            self._floating_window.closeEvent = on_close
            
        def _dock_chat(self):
            """Dock chat back into the main tab."""
            if not self._floating_window:
                return
                
            # Move chat widget back
            if self._chat_widget:
                self._chat_widget.setParent(self)
                # Find the chat panel and add widget back
                chat_panel = self.main_splitter.widget(1)
                if chat_panel:
                    chat_panel.layout().addWidget(self._chat_widget)
                self._chat_widget.setVisible(True)
            
            self._floating_window.hide()
            self._floating_window.deleteLater()
            self._floating_window = None
            self._is_docked = True
            self.undock_btn.setText("📤 Undock Chat")
            self.stay_on_top_btn.setEnabled(False)
            self.stay_on_top_btn.setChecked(False)
            
        def _toggle_stay_on_top(self):
            """Toggle stay-on-top for floating window."""
            if self._floating_window:
                is_on_top = self.stay_on_top_btn.isChecked()
                flags = self._floating_window.windowFlags()
                
                if is_on_top:
                    flags |= Qt.WindowType.WindowStaysOnTopHint
                else:
                    flags &= ~Qt.WindowType.WindowStaysOnTopHint
                
                self._floating_window.setWindowFlags(flags)
                self._floating_window.show()  # Need to show again after changing flags
                
                if hasattr(self, '_float_stay_on_top'):
                    self._float_stay_on_top.setChecked(is_on_top)

    return QApplication, ImageAnarchyGUI, QPalette, QColor, PluginsTab, PreReadyChecklistDialog, ForumTab, ChatTab


# =============================================================================
# COMMAND LINE INTERFACE
# =============================================================================

def run_cli(args):
    """Run the command-line interface."""
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    partition_names = [n.strip() for n in args.images.split(',') if n.strip()] or None
    
    Path(args.out).mkdir(parents=True, exist_ok=True)
    
    with PayloadFile(args.payload_path) as payload_file:
        magic = payload_file.read(4)
        if magic != PAYLOAD_MAGIC:
            raise PayloadError(f"Invalid magic header: expected {PAYLOAD_MAGIC!r}, got {magic!r}")
        
        format_version = unpack_u64(payload_file.read(8))
        if format_version != SUPPORTED_FORMAT_VERSION:
            raise PayloadError(f"Unsupported format version: {format_version}")
        
        manifest_size = unpack_u64(payload_file.read(8))
        metadata_signature_size = unpack_u32(payload_file.read(4))
        
        manifest_data = payload_file.read(manifest_size)
        payload_file.read(metadata_signature_size)
        data_offset = payload_file.tell()
        
        manifest = DeltaArchiveManifest()
        manifest.ParseFromString(manifest_data)
        
        handler = OperationHandler(payload_file, data_offset, manifest.block_size)
        
        # Get partitions to extract
        if partition_names:
            available = {p.partition_name: p for p in manifest.partitions}
            partitions = []
            for name in partition_names:
                if name in available:
                    partitions.append(available[name])
                else:
                    logger.warning(f"Partition '{name}' not found in payload")
        else:
            partitions = list(manifest.partitions)
        
        # Extract each partition
        for partition in partitions:
            name = partition.partition_name
            logger.info(f"Processing {name} partition...")
            
            output_path = Path(args.out) / f"{name}.img"
            old_file = None
            
            if args.diff:
                old_path = Path(args.old) / f"{name}.img"
                if old_path.exists():
                    old_file = open(old_path, 'rb')
                else:
                    logger.warning(f"Original image not found: {old_path}")
            
            try:
                with open(output_path, 'wb') as out_file:
                    for op in partition.operations:
                        handler.process(op, out_file, old_file)
                        sys.stdout.write(".")
                        sys.stdout.flush()
                sys.stdout.write(" Done\n")
                sys.stdout.flush()
            finally:
                if old_file:
                    old_file.close()
        
        # Extract super partition contents if requested
        if getattr(args, 'extract_super', False):
            super_path = Path(args.out) / "super.img"
            if super_path.exists():
                _extract_super_cli(str(super_path), args.out)
            else:
                logger.info("No super.img found, skipping super extraction")


def _extract_super_cli(super_path: str, output_dir: str):
    """Extract partitions from super.img in CLI mode."""
    logger.info("\n" + "="*50)
    logger.info("Extracting super partition contents...")
    logger.info("="*50)
    
    try:
        # Check if it's a valid super image
        img_type = detect_image_type(super_path)
        
        if img_type == 'sparse':
            # First convert sparse to raw
            logger.info("Super image is sparse, converting to raw first...")
            raw_path = super_path.replace('.img', '_raw.img')
            converter = SparseImageConverter()
            converter.convert(super_path, raw_path)
            logger.info(f"  Converted to: {raw_path}")
            super_path = raw_path
            img_type = detect_image_type(super_path)
        
        if img_type != 'super':
            logger.warning(f"super.img is not a dynamic partition image (type: {img_type})")
            logger.warning("Skipping super extraction")
            return
        
        # Create output directory for super contents
        super_output_dir = Path(output_dir) / "super_extracted"
        super_output_dir.mkdir(parents=True, exist_ok=True)
        
        # List partitions in super image
        extractor = SuperImageExtractor()
        partitions = extractor.list_partitions(super_path)
        
        if not partitions:
            logger.info("No partitions found in super image")
            return
        
        valid_partitions = [p for p in partitions if p.size > 0]
        logger.info(f"Found {len(valid_partitions)} partition(s) in super image:")
        
        for p in valid_partitions:
            logger.info(f"  - {p.name}: {p.size / (1024*1024):.2f} MB")
        
        # Extract all partitions
        logger.info("\nExtracting partitions from super image...")
        results = extractor.extract(super_path, str(super_output_dir))
        
        for name, path in results.items():
            logger.info(f"  Extracted: {name}")
            
            # Detect and report sub-partition types
            if Path(path).exists():
                sub_type = detect_image_type(path)
                if sub_type != 'raw':
                    logger.info(f"    (Type: {sub_type})")
        
        logger.info(f"\nSuper partition contents extracted to: {super_output_dir}")
        
    except Exception as e:
        logger.error(f"Error extracting super partition: {e}")


# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

def main():
    # Check for admin privileges on Windows (required for USB device access)
    if sys.platform == 'win32' and not is_admin():
        print("⚠️  Image Anarchy requires Administrator privileges for USB device access.")
        print("🔄 Requesting elevation...")
        if run_as_admin():
            # Elevation requested, exit this instance
            sys.exit(0)
        else:
            print("⚠️  Could not elevate to admin. Some features may not work.")
            print("💡 Try right-clicking and selecting 'Run as Administrator'")
    
    parser = argparse.ArgumentParser(
        description='Image Anarchy - Android Image Swiss Army Knife | https://github.com/vehoelite/image-anarchy',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                                    Launch GUI
  
  Extract (dump) payload:
  %(prog)s --extract payload.bin              Extract all partitions
  %(prog)s --extract ota.zip -i system        Extract only system partition
  %(prog)s --extract payload.bin --diff       Extract differential OTA
  %(prog)s --extract payload.bin -s           Extract payload + super partition contents
  
  Create (repack) payload:
  %(prog)s --create ./images -o payload.bin   Create payload from images
  %(prog)s --create ./images --compression xz Create with XZ compression
  
  Process Android images:
  %(prog)s --image super.img                  Extract partitions from super image
  %(prog)s --image boot.img                   Extract kernel/ramdisk from boot image
  %(prog)s --image system.img --analyze       Analyze image without extracting
  %(prog)s --image sparse.img --no-convert-sparse  Keep as sparse format
        """
    )
    
    # Mode selection
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument(
        '--extract', '--cli',
        dest='extract_path',
        metavar='PAYLOAD',
        help='Extract partitions from a payload file'
    )
    mode_group.add_argument(
        '--create',
        dest='input_dir',
        metavar='DIR',
        help='Create payload from partition images in directory'
    )
    
    # Common options
    parser.add_argument(
        '--out', '-o',
        default=None,
        help='Output directory (extract) or file (create)'
    )
    parser.add_argument(
        '--images', '-i',
        default='',
        help='Comma-separated list of partition names (default: all)'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose output'
    )
    
    # Extract-specific options
    parser.add_argument(
        '--diff', '-d',
        action='store_true',
        help='Extract differential OTA (requires --old directory)'
    )
    parser.add_argument(
        '--old',
        default='old',
        help='Directory with original images for differential OTA (default: old)'
    )
    parser.add_argument(
        '--extract-super', '-s',
        action='store_true',
        help='Extract super partition contents (system, vendor, etc.) after extraction'
    )
    
    # Create-specific options
    parser.add_argument(
        '--compression', '-c',
        choices=['zstd', 'xz', 'bz2', 'none'],
        default='zstd',
        help='Compression algorithm for payload creation (default: zstd)'
    )
    parser.add_argument(
        '--level', '-l',
        type=int,
        default=9,
        help='Compression level 1-22 (default: 9)'
    )
    
    # Image extraction mode
    mode_group.add_argument(
        '--image',
        dest='image_path',
        metavar='IMAGE',
        help='Extract/convert an Android image file (sparse, boot, super)'
    )
    parser.add_argument(
        '--analyze',
        action='store_true',
        help='Only analyze the image, don\'t extract (use with --image)'
    )
    parser.add_argument(
        '--no-convert-sparse',
        action='store_true',
        help='Don\'t convert sparse images to raw (use with --image)'
    )
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    if args.extract_path:
        # Extract mode
        args.payload_path = args.extract_path
        args.out = args.out or 'output'
        try:
            run_cli(args)
        except PayloadError as e:
            logger.error(f"Error: {e}")
            sys.exit(1)
        except KeyboardInterrupt:
            logger.info("\nAborted by user")
            sys.exit(130)
    
    elif args.input_dir:
        # Create mode
        args.output = args.out or 'payload.bin'
        try:
            run_create(args)
        except PayloadError as e:
            logger.error(f"Error: {e}")
            sys.exit(1)
        except KeyboardInterrupt:
            logger.info("\nAborted by user")
            sys.exit(130)
    
    elif args.image_path:
        # Image extraction mode
        args.out = args.out or 'extracted_images'
        try:
            run_image_extract(args)
        except PayloadError as e:
            logger.error(f"Error: {e}")
            sys.exit(1)
        except KeyboardInterrupt:
            logger.info("\nAborted by user")
            sys.exit(130)
    
    else:
        # GUI mode
        try:
            QApplication, ImageAnarchyGUI, QPalette, QColor, PluginsTab, PreReadyChecklistDialog, ForumTab, ChatTab = create_gui_app()
        except ImportError:
            print("PyQt6 is required for GUI mode. Install with: pip install PyQt6")
            print("Or use CLI mode: python image_anarchy.py --cli payload.bin")
            sys.exit(1)
        
        app = QApplication(sys.argv)
        app.setApplicationName("Image Anarchy")
        app.setStyle("Fusion")
        
        # Dark palette
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(30, 30, 30))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(212, 212, 212))
        palette.setColor(QPalette.ColorRole.Base, QColor(45, 45, 45))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(37, 37, 37))
        palette.setColor(QPalette.ColorRole.Text, QColor(212, 212, 212))
        palette.setColor(QPalette.ColorRole.Button, QColor(45, 45, 45))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(212, 212, 212))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(38, 79, 120))
        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))
        app.setPalette(palette)
        
        # Show Pre-Ready Checklist splash screen
        splash = PreReadyChecklistDialog()
        result = splash.exec()
        
        # Clean up splash dialog explicitly
        splash.deleteLater()
        
        # Process pending events to ensure clean state before creating main window
        app.processEvents()
        
        window = ImageAnarchyGUI()
        
        # Add Plugins tab
        plugins_tab = PluginsTab(window)
        window.tab_widget.addTab(plugins_tab, "🔌 Plugins")
        
        # Add Chat tab
        chat_tab = ChatTab(window)
        window.tab_widget.addTab(chat_tab, "💬 Chat")
        
        # Add Forum tab
        forum_tab = ForumTab(window)
        window.tab_widget.addTab(forum_tab, "🌐 Forum")
        
        window.show()
        
        sys.exit(app.exec())


if __name__ == "__main__":
    main()
